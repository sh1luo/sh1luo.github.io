<!doctype html><html lang=zh-hans><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=theme-color content="#494f5c"><meta name=msapplication-TileColor content="#494f5c"><meta itemprop=name content="深入理解 Go map"><meta itemprop=description content="哈希表 几乎所有语言都有 哈希表 这个数据结构，能够在平均 O(1)，最差 O(n) 的时间复杂度内增删改查元素，Go 语言哈希表的精妙设计使得它几乎不会出现 O(n) 的糟糕情况。这篇文章我就带你从使用到底层由浅入深地探究 Go map 的奥秘，一起作一个不只是会用的 ”大神“。
问题来源于实际，我们先看看这些实际问题 ：
 声明。当我使用 :=，var，make，甚至 new 声明 map 的时候，编译器帮我们做了什么事情，它们有什么区别？ 增删改查。使用 数组+链表 的情况下如何设计才能避免 O(n) 的最差情况？ 注意事项。map 的键有什么要求？map 是值类型还是引用类型，函数传参时会有上层影响吗？是并发安全的吗？  还有一个常识是 Go map 的 遍历是随机的，即多次遍历输出的结果不同，这个的原因会在后面提到。
设计方式/数据结构 Go map 实现哈希表使用的是 数组+链表 的形式，也就是使用链地址法解决的哈希冲突。这种方式桶的大小和元素个数之间没有关系，另外还有开放定址法，这是个宽泛的名字，具体包含线性探测法，再哈希法，平方探测法等等。
为了降低 map 操作的时间复杂度，引入了一个 负载因子 的概念，这个概念在其他实现哈希表这个数据结构的语言里也都有，比如 python 中这个值被定义为 2/3，Java 中是 0.75，这个值评估了哈希表里 实际上最好只存 多少比例的元素，而不是一直等到满载再处理，因为多到一定程度效率 可能 就低了。在 Go 语言里这个值被定义为 6.5，即每个桶里最多存 6.5 个，包括溢出桶。
当我们在 Go 语言中声明一个 map 的时候，实际上就是创建了一个 hmap 的结构体，它定义在 runtime/map.go 文件下，这个结构体包含了许多信息：map 的大小，桶数量、地址，溢出桶数量、地址等等。 哈希表就是实现一个映射关系，给出自变量 x，能够通过 平均 O(1) 的时间复杂度方法找到这个元素所对应的因变量 y=f(x) 来对它进行操作。"><meta itemprop=datePublished content="2021-01-22T23:35:20+00:00"><meta itemprop=dateModified content="2021-01-22T23:35:20+00:00"><meta itemprop=wordCount content="1165"><meta itemprop=keywords content="Go,源码,"><meta property="og:title" content="深入理解 Go map"><meta property="og:description" content="哈希表 几乎所有语言都有 哈希表 这个数据结构，能够在平均 O(1)，最差 O(n) 的时间复杂度内增删改查元素，Go 语言哈希表的精妙设计使得它几乎不会出现 O(n) 的糟糕情况。这篇文章我就带你从使用到底层由浅入深地探究 Go map 的奥秘，一起作一个不只是会用的 ”大神“。
问题来源于实际，我们先看看这些实际问题 ：
 声明。当我使用 :=，var，make，甚至 new 声明 map 的时候，编译器帮我们做了什么事情，它们有什么区别？ 增删改查。使用 数组+链表 的情况下如何设计才能避免 O(n) 的最差情况？ 注意事项。map 的键有什么要求？map 是值类型还是引用类型，函数传参时会有上层影响吗？是并发安全的吗？  还有一个常识是 Go map 的 遍历是随机的，即多次遍历输出的结果不同，这个的原因会在后面提到。
设计方式/数据结构 Go map 实现哈希表使用的是 数组+链表 的形式，也就是使用链地址法解决的哈希冲突。这种方式桶的大小和元素个数之间没有关系，另外还有开放定址法，这是个宽泛的名字，具体包含线性探测法，再哈希法，平方探测法等等。
为了降低 map 操作的时间复杂度，引入了一个 负载因子 的概念，这个概念在其他实现哈希表这个数据结构的语言里也都有，比如 python 中这个值被定义为 2/3，Java 中是 0.75，这个值评估了哈希表里 实际上最好只存 多少比例的元素，而不是一直等到满载再处理，因为多到一定程度效率 可能 就低了。在 Go 语言里这个值被定义为 6.5，即每个桶里最多存 6.5 个，包括溢出桶。
当我们在 Go 语言中声明一个 map 的时候，实际上就是创建了一个 hmap 的结构体，它定义在 runtime/map.go 文件下，这个结构体包含了许多信息：map 的大小，桶数量、地址，溢出桶数量、地址等等。 哈希表就是实现一个映射关系，给出自变量 x，能够通过 平均 O(1) 的时间复杂度方法找到这个元素所对应的因变量 y=f(x) 来对它进行操作。"><meta property="og:type" content="article"><meta property="og:url" content="https://kcode.icu/posts/go/2021-02-22-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3go-map/"><meta property="article:published_time" content="2021-01-22T23:35:20+00:00"><meta property="article:modified_time" content="2021-01-22T23:35:20+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="深入理解 Go map"><meta name=twitter:description content="哈希表 几乎所有语言都有 哈希表 这个数据结构，能够在平均 O(1)，最差 O(n) 的时间复杂度内增删改查元素，Go 语言哈希表的精妙设计使得它几乎不会出现 O(n) 的糟糕情况。这篇文章我就带你从使用到底层由浅入深地探究 Go map 的奥秘，一起作一个不只是会用的 ”大神“。
问题来源于实际，我们先看看这些实际问题 ：
 声明。当我使用 :=，var，make，甚至 new 声明 map 的时候，编译器帮我们做了什么事情，它们有什么区别？ 增删改查。使用 数组+链表 的情况下如何设计才能避免 O(n) 的最差情况？ 注意事项。map 的键有什么要求？map 是值类型还是引用类型，函数传参时会有上层影响吗？是并发安全的吗？  还有一个常识是 Go map 的 遍历是随机的，即多次遍历输出的结果不同，这个的原因会在后面提到。
设计方式/数据结构 Go map 实现哈希表使用的是 数组+链表 的形式，也就是使用链地址法解决的哈希冲突。这种方式桶的大小和元素个数之间没有关系，另外还有开放定址法，这是个宽泛的名字，具体包含线性探测法，再哈希法，平方探测法等等。
为了降低 map 操作的时间复杂度，引入了一个 负载因子 的概念，这个概念在其他实现哈希表这个数据结构的语言里也都有，比如 python 中这个值被定义为 2/3，Java 中是 0.75，这个值评估了哈希表里 实际上最好只存 多少比例的元素，而不是一直等到满载再处理，因为多到一定程度效率 可能 就低了。在 Go 语言里这个值被定义为 6.5，即每个桶里最多存 6.5 个，包括溢出桶。
当我们在 Go 语言中声明一个 map 的时候，实际上就是创建了一个 hmap 的结构体，它定义在 runtime/map.go 文件下，这个结构体包含了许多信息：map 的大小，桶数量、地址，溢出桶数量、地址等等。 哈希表就是实现一个映射关系，给出自变量 x，能够通过 平均 O(1) 的时间复杂度方法找到这个元素所对应的因变量 y=f(x) 来对它进行操作。"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color><link rel="shortcut icon" href=/favicon.ico><title>深入理解 Go map</title><link rel=stylesheet href=https://kcode.icu/css/style.min.d3141168199607bf3a517216ce3c263814eecdbc8fca72a9a88700799a838219.css></head><body id=page><header id=site-header class="animated slideInUp faster"><div class="hdr-wrapper section-inner"><div class=hdr-left><div class=site-branding><a href=https://kcode.icu/>wasabi</a></div><nav class="site-nav hide-in-mobile"><a href=https://kcode.icu/posts/>文章</a>
<a href=https://kcode.icu/summary>总结</a>
<a href=https://kcode.icu/chore>杂项</a>
<a href=https://kcode.icu/go>Go系列</a></nav></div><div class="hdr-right hdr-icons"><span class="hdr-social hide-in-mobile"><a href=https://github.com/sh1luo target=_blank rel="noopener me" title=Github><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77a5.44 5.44.0 00-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=mailto:silo1999@163.com target=_blank rel="noopener me" title=Email><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-mail"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a><a href="http://wpa.qq.com/msgrd?v=3&uin=690898835&site=qq&menu=yes" target=_blank rel="noopener me" title=Qq><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"/></svg></a></span><button id=menu-btn class=hdr-btn title=Menu><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button></div></div></header><div id=mobile-menu class="animated fast"><ul><li><a href=https://kcode.icu/posts/>文章</a></li><li><a href=https://kcode.icu/tags/>标签</a></li><li><a href=https://kcode.icu/about/>关于</a></li></ul></div><main class="site-main section-inner animated fadeIn faster"><article id=articles class=thin><header class=post-header><div class=post-meta><span>Jan 22, 2021</span></div><h1>深入理解 Go map</h1></header><div class=content><h2 id=哈希表>哈希表<a href=#哈希表 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>几乎所有语言都有 <a href=https://en.wikipedia.org/wiki/Hash_table>哈希表</a> 这个数据结构，能够在平均 O(1)，最差 O(n) 的时间复杂度内增删改查元素，Go 语言哈希表的精妙设计使得它几乎不会出现 O(n) 的糟糕情况。这篇文章我就带你从使用到底层由浅入深地探究 Go map 的奥秘，一起作一个不只是会用的 ”大神“。</p><p>问题来源于实际，我们先看看这些实际问题 ：</p><ul><li><strong>声明</strong>。当我使用 <code>:=</code>，<code>var</code>，<code>make</code>，甚至 <code>new</code> 声明 map 的时候，编译器帮我们做了什么事情，它们有什么区别？</li><li><strong>增删改查</strong>。使用 数组+链表 的情况下如何设计才能避免 O(n) 的最差情况？</li><li><strong>注意事项</strong>。map 的键有什么要求？map 是值类型还是引用类型，函数传参时会有上层影响吗？是并发安全的吗？</li></ul><p>还有一个常识是 Go map 的 <strong>遍历是随机的</strong>，即多次遍历输出的结果不同，这个的原因会在后面提到。</p><h3 id=设计方式数据结构>设计方式/数据结构<a href=#设计方式数据结构 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>Go map 实现哈希表使用的是 <strong>数组+链表</strong> 的形式，也就是使用链地址法解决的哈希冲突。这种方式桶的大小和元素个数之间没有关系，另外还有开放定址法，这是个宽泛的名字，具体包含线性探测法，再哈希法，平方探测法等等。</p><p>为了降低 map 操作的时间复杂度，引入了一个 <a href=https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/map.go#L70>负载因子</a> 的概念，这个概念在其他实现哈希表这个数据结构的语言里也都有，比如 python 中这个值被定义为 2/3，Java 中是 0.75，这个值评估了哈希表里 <strong>实际上最好只存</strong> 多少比例的元素，而不是一直等到满载再处理，因为多到一定程度效率 <strong>可能</strong> 就低了。在 Go 语言里这个值被定义为 6.5，即每个桶里最多存 6.5 个，包括溢出桶。</p><p>当我们在 Go 语言中声明一个 map 的时候，实际上就是创建了一个 <a href=https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/map.go#L115>hmap</a> 的结构体，它定义在 <code>runtime/map.go</code> 文件下，这个结构体包含了许多信息：map 的大小，桶数量、地址，溢出桶数量、地址等等。 哈希表就是实现一个映射关系，给出自变量 x，能够通过 <strong>平均</strong> O(1) 的时间复杂度方法找到这个元素所对应的因变量 y=f(x) 来对它进行操作。</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>hmap</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>count</span>     <span class=kt>int</span> 		<span class=c1>// map的大小，len()的结果就是这个字段值
</span><span class=c1></span>	<span class=nx>flags</span>     <span class=kt>uint8</span>		<span class=c1>// map的状态，有四个
</span><span class=c1></span>	<span class=nx>B</span>         <span class=kt>uint8</span>  	<span class=c1>// 桶数量的log_2对数，如B=5，桶数量就是2^5=32
</span><span class=c1></span>	<span class=nx>noverflow</span> <span class=kt>uint16</span> 	<span class=c1>// 溢出桶的数量
</span><span class=c1></span>	<span class=nx>hash0</span>     <span class=kt>uint32</span> 	<span class=c1>// 哈希种子
</span><span class=c1></span>
	<span class=nx>buckets</span>    <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=c1>// 桶数组的底层地址
</span><span class=c1></span>	<span class=nx>oldbuckets</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=c1>// 旧桶数组的底层地址
</span><span class=c1></span>	<span class=nx>nevacuate</span>  <span class=kt>uintptr</span>        <span class=c1>// 迁移进度
</span><span class=c1></span>
	<span class=nx>extra</span> <span class=o>*</span><span class=nx>mapextra</span> <span class=c1>// 溢出桶
</span><span class=c1></span><span class=p>}</span>

<span class=kd>type</span> <span class=nx>mapextra</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>overflow</span>    <span class=o>*</span><span class=p>[]</span><span class=o>*</span><span class=nx>bmap</span>
	<span class=nx>oldoverflow</span> <span class=o>*</span><span class=p>[]</span><span class=o>*</span><span class=nx>bmap</span>

	<span class=c1>// 指向下一个空闲溢出桶
</span><span class=c1></span>	<span class=nx>nextOverflow</span> <span class=o>*</span><span class=nx>bmap</span>
<span class=p>}</span>
</code></pre></div><p>需要注意的是，如果 map 的键值都不包含指针并且是内联的，那么我们就会标注 map 为 ”不含指针类型“，这样就可以避免 GC 扫描 map，从而避免在 map 在过大时由于指针过多造成的 GC 扫描对象过多而缓慢的问题。所以将所有关于溢出桶的指针都放在了 extra 字段中。mapextra 字段保存了与溢出桶相关的信息，<code>overflow</code> 指向当前桶 <code>hmap.buckets</code> 的溢出桶，<code>oldoverflow</code> 指向旧桶 <code>hmap.oldbuckets</code> 的溢出桶。</p><p>真正存储数据的地方是 <a href=https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L149>bmap</a>，map 有 2^B 个 bmap，但是每个 bmap 只能存储 8 个键值对，多出来的就要找到一个溢出桶放进去，每个桶的数据结构都是一样的，bmap 结构只有 tophash 字段是因为 map 的 key 和 value 是需要 <strong>在编译时计算确定</strong>，所以需要在编译时动态构造桶结构。唯一的 tophash 字段是键值经过哈希函数计算后的值高八位。</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>bmap</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>tophash</span> <span class=p>[</span><span class=nx>bucketCnt</span><span class=p>]</span><span class=kt>uint8</span>
<span class=p>}</span>
</code></pre></div><p>此外，动态运行时构造的 key 和 value 键值对并没有按照 key1/value1、key2/value2、&mldr;、keyN/valueN 的方式存储，而是如图形式，是为了避免因为字节对齐造成的内存浪费，也是因为 CPU 从内存中读取数据是每次读取固定大小的块（因为数据总线条数固定），这块内存也并不是连续的，这里不展开说了，总之，如果采用 key1/value1、key2/value2、&mldr;、keyN/valueN 的方式，如果 map 是 map[int64]int8 的时候，每个键值对就会由于内存不对齐造成 7 字节的内存浪费，其实也并不一定浪费，现在很多 CPU 也可以读取多块内存然后拼接组合成最终的数据，但是这样性能并不好。这一点在官方源代码里的 <a href=https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/map.go#L148>bmap</a> 结构体注释中有说明。</p><p><img src=https://gitee.com/sh1luo/imgs/raw/master/imgs/map_zipper.svg alt></p><h3 id=初始化>初始化<a href=#初始化 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>Go 语言初始化 map 的方式有两种，字面量和运行时。</p><h4 id=字面量->字面量 &ldquo;:=&rdquo;<a href=#字面量- class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=nx>m</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>string</span> <span class=p>{</span>
    <span class=mi>1</span><span class=p>:</span> <span class=s>&#34;go&#34;</span><span class=p>,</span>
    <span class=mi>2</span><span class=p>:</span> <span class=s>&#34;lang&#34;</span><span class=p>,</span>
<span class=p>}</span>
</code></pre></div><p>几乎所有语言都会提供字面量的方式进行初始化，Go 语言里的字面量初始化是使用了 &ldquo;:=&rdquo; 符号，这样来代表创建一个局部变量。Go 语言里的 map 也可以通过这种方式初始化，但是需要注意的是，还有一种初始化方式 <code>var m map[Type]Type</code> ，如果仅仅这样声明后就直接使用 <code>m[key] = value</code> 来写入是会 panic 的，因为没有分配实际内存。</p><p>通过这种方式初始化的 map 会调用 <a href=https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/cmd/compile/internal/gc/sinit.go#L753>maplit</a> 函数来执行具体的创建逻辑：</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>maplit</span><span class=p>(</span><span class=nx>n</span> <span class=o>*</span><span class=nx>Node</span><span class=p>,</span> <span class=nx>m</span> <span class=o>*</span><span class=nx>Node</span><span class=p>,</span> <span class=nx>init</span> <span class=o>*</span><span class=nx>Nodes</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>a</span> <span class=o>:=</span> <span class=nf>nod</span><span class=p>(</span><span class=nx>OMAKE</span><span class=p>,</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
	<span class=nx>a</span><span class=p>.</span><span class=nx>Esc</span> <span class=p>=</span> <span class=nx>n</span><span class=p>.</span><span class=nx>Esc</span>
	<span class=nx>a</span><span class=p>.</span><span class=nx>List</span><span class=p>.</span><span class=nf>Set2</span><span class=p>(</span><span class=nf>typenod</span><span class=p>(</span><span class=nx>n</span><span class=p>.</span><span class=nx>Type</span><span class=p>),</span> <span class=nf>nodintconst</span><span class=p>(</span><span class=nb>int64</span><span class=p>(</span><span class=nx>n</span><span class=p>.</span><span class=nx>List</span><span class=p>.</span><span class=nf>Len</span><span class=p>())))</span>
	<span class=nf>litas</span><span class=p>(</span><span class=nx>m</span><span class=p>,</span> <span class=nx>a</span><span class=p>,</span> <span class=nx>init</span><span class=p>)</span>

	<span class=nx>entries</span> <span class=o>:=</span> <span class=nx>n</span><span class=p>.</span><span class=nx>List</span><span class=p>.</span><span class=nf>Slice</span><span class=p>()</span>

    <span class=c1>// ...
</span><span class=c1></span>
	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>entries</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>25</span> <span class=p>{</span>
		<span class=c1>// 如果数量非常多（指大于25个），就放进数组中循环处理。
</span><span class=c1></span>
		<span class=c1>// 构建 [count]Tindex 和 [count]Tvalue
</span><span class=c1></span>		<span class=nx>tk</span> <span class=o>:=</span> <span class=nx>types</span><span class=p>.</span><span class=nf>NewArray</span><span class=p>(</span><span class=nx>n</span><span class=p>.</span><span class=nx>Type</span><span class=p>.</span><span class=nf>Key</span><span class=p>(),</span> <span class=nb>int64</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>entries</span><span class=p>)))</span>
		<span class=nx>te</span> <span class=o>:=</span> <span class=nx>types</span><span class=p>.</span><span class=nf>NewArray</span><span class=p>(</span><span class=nx>n</span><span class=p>.</span><span class=nx>Type</span><span class=p>.</span><span class=nf>Elem</span><span class=p>(),</span> <span class=nb>int64</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>entries</span><span class=p>)))</span>
        
        <span class=c1>// 后续循环插入，类似
</span><span class=c1></span>        <span class=c1>// for i = 0; i &lt; len(vstatk); i++ {
</span><span class=c1></span>		<span class=c1>//	 map[vstatk[i]] = vstate[i]
</span><span class=c1></span>		<span class=c1>// }
</span><span class=c1></span>        
        <span class=o>...</span>
    <span class=p>}</span>
</code></pre></div><p>不管是哪种情况，最终都会通过 make 来创建哈希表数据结构并且通过 map[key] = value 的形式插入数据。</p><h4 id=运行时-make>运行时 &ldquo;make&rdquo;<a href=#运行时-make class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><p>使用 make 创建 map 时有两种情况，一种是不给出大小，或者大小小于 8 的时候，会调用 <a href=https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L292>makemap_small</a> 来快速初始化一个 map：</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>makemap_small</span><span class=p>()</span> <span class=o>*</span><span class=nx>hmap</span> <span class=p>{</span>
	<span class=nx>h</span> <span class=o>:=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>hmap</span><span class=p>)</span>
	<span class=nx>h</span><span class=p>.</span><span class=nx>hash0</span> <span class=p>=</span> <span class=nf>fastrand</span><span class=p>()</span>
	<span class=k>return</span> <span class=nx>h</span>
<span class=p>}</span>
</code></pre></div><p>显而易见，这种的方式的 map 是声明在堆上的。除了这种方式之外，map 会通过 <a href=https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L282>makemap64</a> 来将 map 的大小设置为 int32 后再调用 makemap 函数进行创建的主要逻辑：</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>makemap</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>maptype</span><span class=p>,</span> <span class=nx>hint</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>h</span> <span class=o>*</span><span class=nx>hmap</span><span class=p>)</span> <span class=o>*</span><span class=nx>hmap</span> <span class=p>{</span>
	<span class=nx>mem</span><span class=p>,</span> <span class=nx>overflow</span> <span class=o>:=</span> <span class=nx>math</span><span class=p>.</span><span class=nf>MulUintptr</span><span class=p>(</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>hint</span><span class=p>),</span> <span class=nx>t</span><span class=p>.</span><span class=nx>bucket</span><span class=p>.</span><span class=nx>size</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>overflow</span> <span class=o>||</span> <span class=nx>mem</span> <span class=p>&gt;</span> <span class=nx>maxAlloc</span> <span class=p>{</span>
		<span class=nx>hint</span> <span class=p>=</span> <span class=mi>0</span>
	<span class=p>}</span>

	<span class=k>if</span> <span class=nx>h</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=nx>h</span> <span class=p>=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>hmap</span><span class=p>)</span>
	<span class=p>}</span>
	<span class=nx>h</span><span class=p>.</span><span class=nx>hash0</span> <span class=p>=</span> <span class=nf>fastrand</span><span class=p>()</span>

	<span class=nx>B</span> <span class=o>:=</span> <span class=nb>uint8</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
	<span class=k>for</span> <span class=nf>overLoadFactor</span><span class=p>(</span><span class=nx>hint</span><span class=p>,</span> <span class=nx>B</span><span class=p>)</span> <span class=p>{</span>
		<span class=nx>B</span><span class=o>++</span>
	<span class=p>}</span>
	<span class=nx>h</span><span class=p>.</span><span class=nx>B</span> <span class=p>=</span> <span class=nx>B</span>

	<span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nx>B</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
		<span class=kd>var</span> <span class=nx>nextOverflow</span> <span class=o>*</span><span class=nx>bmap</span>
		<span class=nx>h</span><span class=p>.</span><span class=nx>buckets</span><span class=p>,</span> <span class=nx>nextOverflow</span> <span class=p>=</span> <span class=nf>makeBucketArray</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>h</span><span class=p>.</span><span class=nx>B</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
		<span class=k>if</span> <span class=nx>nextOverflow</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=nx>h</span><span class=p>.</span><span class=nx>extra</span> <span class=p>=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>mapextra</span><span class=p>)</span>
			<span class=nx>h</span><span class=p>.</span><span class=nx>extra</span><span class=p>.</span><span class=nx>nextOverflow</span> <span class=p>=</span> <span class=nx>nextOverflow</span>
		<span class=p>}</span>
	<span class=p>}</span>

	<span class=k>return</span> <span class=nx>h</span>
<span class=p>}</span>
</code></pre></div><p><a href=https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L303>makemap</a> 函数做了这几件事：</p><ul><li><p>用桶的个数*8，判断内存是否足够分配，会不会溢出，如果会的话就置 0。</p></li><li><p>声明一个 map 结构体变量，初始化一个随机数用于哈希函数的计算。</p></li><li><p>用 make 内置函数的第二个参数 hint 判断出需要多少个桶，转换为对数存到 B 中。</p></li><li><p>如果 B 是 0 的话，就不分配内存，后续用的时候懒加载分配，所以从这里我们也能明白为什么平时说提前给出 map 的大小后续使用速度更快了。如果不是 0，就调用 <a href=https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L344>makeBucketArray</a> 分配底层的桶内存和溢出桶内存。</p></li></ul><p>这里会有一个判断 <code>nextOverflow != nil</code> ，这里就涉及在什么情况下初始化时要提前分配溢出桶，Go 语言是这样解决的：如果 B 大于 4，那么就认为后续使用溢出桶的概率比较大，就会预先分配 <code>2^(B-4)</code> 个溢出桶。然后分配专门用来描述溢出桶的结构 <code>hmap.extra</code>，其中指向下一个溢出桶地址的 <code>nextOverflow</code> 字段就指向分配好的溢出桶首地址。</p><p>正常桶和溢出桶的地址是连续的，只是被不同的字段引用而已，如果溢出桶不够用，会调用 <a href=runtime/newobject>runtime/newobject</a> 分配新的溢出桶。直到达到元素数量过多需要全量扩容或者重新哈希等量扩容，这个问题下文会详说。</p><h3 id=读写操作>读写操作<a href=#读写操作 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>Go 内置数据类型 map 是并发不安全的，也就是说多个 goroutine 同时对 map 执行写入操作会导致程序发生 panic 中断。官方解释说这是因为大多数情况下 map 并不需要并发安全，如果为所有 map 都加上并发操作的特性会使得大多数场景性能下降，为此 Go 在 1.9 版本引入了一种并发安全的 map 类型 <a href=https://github.com/golang/go/blob/41d8e61a6b/src/sync/map.go#L27>sync/map</a> ，留给读者自行探索。</p><h4 id=访问>访问<a href=#访问 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><p>map 的访问有两种形式：</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=nx>value</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>[</span><span class=s>&#34;I&#39;m a Key&#34;</span><span class=p>]</span>
</code></pre></div><p>Or</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=nx>value</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>[</span><span class=s>&#34;I&#39;m a Key&#34;</span><span class=p>]</span>
</code></pre></div><p>第二种方式的第二个返回值是个布尔类型，代表该键在 map 中是否存在，类似于数据库或者其他概念中的 NULL 值，目的是为了不和所有该类型值冲突。两种方式的底层调用分别对应着 <a href=https://github.com/golang/go/blob/ac0ba6707c/src/runtime/map.go#L389>runtime/mapaccess1</a> 和 <a href=https://github.com/golang/go/blob/ac0ba6707c/src/runtime/map.go#L452>runtime/mapaccess2</a> ，Go 语言会在 <strong>运行时决定</strong> 使用哪种方式。</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>mapaccess1</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>maptype</span><span class=p>,</span> <span class=nx>h</span> <span class=o>*</span><span class=nx>hmap</span><span class=p>,</span> <span class=nx>key</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=p>{</span>
    <span class=c1>// ...
</span><span class=c1></span>	<span class=nx>hash</span> <span class=o>:=</span> <span class=nx>t</span><span class=p>.</span><span class=nf>hasher</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>hash0</span><span class=p>))</span>
	<span class=nx>m</span> <span class=o>:=</span> <span class=nf>bucketMask</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span>
	<span class=nx>b</span> <span class=o>:=</span> <span class=p>(</span><span class=o>*</span><span class=nx>bmap</span><span class=p>)(</span><span class=nf>add</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>buckets</span><span class=p>,</span> <span class=p>(</span><span class=nx>hash</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>)</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>bucketsize</span><span class=p>)))</span>
    <span class=c1>// ...
</span><span class=c1></span>	<span class=nx>top</span> <span class=o>:=</span> <span class=nf>tophash</span><span class=p>(</span><span class=nx>hash</span><span class=p>)</span>
<span class=nx>bucketloop</span><span class=p>:</span>
	<span class=k>for</span> <span class=p>;</span> <span class=nx>b</span> <span class=o>!=</span> <span class=kc>nil</span><span class=p>;</span> <span class=nx>b</span> <span class=p>=</span> <span class=nx>b</span><span class=p>.</span><span class=nf>overflow</span><span class=p>(</span><span class=nx>t</span><span class=p>)</span> <span class=p>{</span>
		<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nb>uintptr</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>bucketCnt</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
			<span class=k>if</span> <span class=nx>b</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>!=</span> <span class=nx>top</span> <span class=p>{</span>
				<span class=k>if</span> <span class=nx>b</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>==</span> <span class=nx>emptyRest</span> <span class=p>{</span>
					<span class=k>break</span> <span class=nx>bucketloop</span>
				<span class=p>}</span>
				<span class=k>continue</span>
			<span class=p>}</span>
			<span class=nx>k</span> <span class=o>:=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>b</span><span class=p>),</span> <span class=nx>dataOffset</span><span class=o>+</span><span class=nx>i</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>keysize</span><span class=p>))</span>
			<span class=k>if</span> <span class=nx>t</span><span class=p>.</span><span class=nf>indirectkey</span><span class=p>()</span> <span class=p>{</span>
				<span class=nx>k</span> <span class=p>=</span> <span class=o>*</span><span class=p>((</span><span class=o>*</span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)(</span><span class=nx>k</span><span class=p>))</span>
			<span class=p>}</span>
			<span class=k>if</span> <span class=nx>t</span><span class=p>.</span><span class=nx>key</span><span class=p>.</span><span class=nf>equal</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>k</span><span class=p>)</span> <span class=p>{</span>
				<span class=nx>e</span> <span class=o>:=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>b</span><span class=p>),</span> <span class=nx>dataOffset</span><span class=o>+</span><span class=nx>bucketCnt</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>keysize</span><span class=p>)</span><span class=o>+</span><span class=nx>i</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>elemsize</span><span class=p>))</span>
				<span class=k>if</span> <span class=nx>t</span><span class=p>.</span><span class=nf>indirectelem</span><span class=p>()</span> <span class=p>{</span>
					<span class=nx>e</span> <span class=p>=</span> <span class=o>*</span><span class=p>((</span><span class=o>*</span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)(</span><span class=nx>e</span><span class=p>))</span>
				<span class=p>}</span>
				<span class=k>return</span> <span class=nx>e</span>
			<span class=p>}</span>
		<span class=p>}</span>
	<span class=p>}</span>
	<span class=k>return</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>zeroVal</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
<span class=p>}</span>
</code></pre></div><p>mapaccess1 的返回值是一个指向目标值的指针，如果不存在的话会返回该类型的零值而不会返回 nil。</p><p>依次做了这些事：</p><ul><li>通过 map 最开始初始化的哈希种子，用哈希函数计算出该键的哈希值 <code>hash</code>，这里的哈希函数使用了依赖注入的方式，并不固定。</li><li>计算桶的位掩码 <code>m</code>，也就是 B-1，用于后续做与运算确定该键位于哪个桶中。</li><li>与运算找到桶，桶的首地址+桶序号*桶大小动态计算出目标桶地址 <code>b</code>，取高八位哈希值 <code>tophash</code>，这里是通过位运算的方式取高位的，因为除法代价太高。</li><li>最后从桶的第一个 cell 开始，到最后一个溢出桶的最后一个 cell 为止遍历，先比较 tophash，如果一致了就用 tophash 值的下标和 map key 的大小计算出该 key 的偏移，再比较一次，这样可以加速查找，</li></ul><p>第二种形式的底层调用是 <a href=https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L452>mapaccess2</a> ，过程和第一种类似，只是在最后的两个 return 处多返回了一个布尔值：</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go>				<span class=c1>// ...
</span><span class=c1></span>				<span class=k>return</span> <span class=nx>e</span><span class=p>,</span> <span class=kc>true</span>
			<span class=p>}</span>
		<span class=p>}</span>
	<span class=p>}</span>
	<span class=k>return</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>zeroVal</span><span class=p>[</span><span class=mi>0</span><span class=p>]),</span> <span class=kc>false</span>
</code></pre></div><p>还有一个函数 <a href=https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L511>mapaccessK</a> ，返回的是 map 的 key 和 value，用于 map 的 range 函数遍历，过程类似，不赘述了。</p><h4 id=写入>写入<a href=#写入 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><p>map 的写入操作对应底层 <a href=https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L571>runtime/map.go.mapassign</a> 函数。这个函数的签名如下：</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>mapassign</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>maptype</span><span class=p>,</span> <span class=nx>h</span> <span class=o>*</span><span class=nx>hmap</span><span class=p>,</span> <span class=nx>key</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span>
</code></pre></div><p>签名中并没有看到写入 key 所对应的 value 值表达式，唯一相关的返回值是一个指向任意类型的指针类型，可能有人就迷惑了，map 写入是依靠这个函数，我都没传 value 怎么写入呢？</p><p>答案是写入操作并没有写在标准库源码中，而是在汇编代码中。</p><pre><code class=language-assembly data-lang=assembly>...
0x008e 00142 (notify.go:5)      CALL    runtime.mapassign_fast64(SB)
0x0093 00147 (notify.go:5)      MOVQ    24(SP), AX
0x0098 00152 (notify.go:5)      MOVQ    $666, (AX)
...
</code></pre><blockquote><p>学习 Go 底层原理时，时常要借助汇编代码一起分析，Go 官方也为我们提供了完整的工具包，其中 <code>go tool compile -S</code> 就十分有用，上面这些信息就是通过这个工具得到的。</p></blockquote><p><code>mapassign_fast64</code> 是针对不同类型的 key 做出的编译时优化，为了增加效率。</p><p>下面看一下这个函数的源码：</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>mapassign</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>maptype</span><span class=p>,</span> <span class=nx>h</span> <span class=o>*</span><span class=nx>hmap</span><span class=p>,</span> <span class=nx>key</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=p>{</span>
    <span class=c1>// 向空map中写入会panic，比如仅仅通过
</span><span class=c1></span>    <span class=c1>// var mp map[int]int
</span><span class=c1></span>    <span class=c1>// mp[1] = 2 // panic!
</span><span class=c1></span>	<span class=k>if</span> <span class=nx>h</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=nb>panic</span><span class=p>(</span><span class=nf>plainError</span><span class=p>(</span><span class=s>&#34;assignment to entry in nil map&#34;</span><span class=p>))</span>
	<span class=p>}</span>
	<span class=o>...</span>
    <span class=c1>// 写map时会把flags标志位写位置1，写入时如果检测到已经置1，
</span><span class=c1></span>    <span class=c1>// 说明并发写入，语言不支持，会panic
</span><span class=c1></span>	<span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nx>flags</span><span class=o>&amp;</span><span class=nx>hashWriting</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;concurrent map writes&#34;</span><span class=p>)</span>
	<span class=p>}</span>
	<span class=nx>hash</span> <span class=o>:=</span> <span class=nx>t</span><span class=p>.</span><span class=nf>hasher</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>hash0</span><span class=p>))</span>

    <span class=c1>// 这个要在t.hasher之后，因为hasher调用可能panic，导致写入失败，没必要把写入位置1
</span><span class=c1></span>	<span class=nx>h</span><span class=p>.</span><span class=nx>flags</span> <span class=p>^=</span> <span class=nx>hashWriting</span>

    <span class=c1>// 如果还没有桶就new一个
</span><span class=c1></span>	<span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nx>buckets</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=nx>h</span><span class=p>.</span><span class=nx>buckets</span> <span class=p>=</span> <span class=nf>newobject</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>bucket</span><span class=p>)</span> <span class=c1>// newarray(t.bucket, 1)
</span><span class=c1></span>	<span class=p>}</span>

<span class=nx>again</span><span class=p>:</span>
	<span class=nx>bucket</span> <span class=o>:=</span> <span class=nx>hash</span> <span class=o>&amp;</span> <span class=nf>bucketMask</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span>	<span class=c1>// 与低B位确定在哪个桶
</span><span class=c1></span>	<span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nf>growing</span><span class=p>()</span> <span class=p>{</span>	<span class=c1>// 这个函数只有一行代码，h.oldbuckets != nil，判断是否迁移完毕
</span><span class=c1></span>		<span class=nf>growWork</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>h</span><span class=p>,</span> <span class=nx>bucket</span><span class=p>)</span>
	<span class=p>}</span>
	<span class=nx>b</span> <span class=o>:=</span> <span class=p>(</span><span class=o>*</span><span class=nx>bmap</span><span class=p>)(</span><span class=nf>add</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>buckets</span><span class=p>,</span> <span class=nx>bucket</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>bucketsize</span><span class=p>)))</span><span class=c1>// 用首地址+桶编号*单个桶大小定位到目标桶的地址
</span><span class=c1></span>	<span class=nx>top</span> <span class=o>:=</span> <span class=nf>tophash</span><span class=p>(</span><span class=nx>hash</span><span class=p>)</span> <span class=c1>// 计算tophash哈希值，用于找到key value
</span><span class=c1></span>
    <span class=c1>// 完成了上面的各种判断，才会进行下面双重循环的判断，按照所有桶，每个桶里的8个位，按顺序遍历
</span><span class=c1></span>	<span class=kd>var</span> <span class=nx>inserti</span> <span class=o>*</span><span class=kt>uint8</span>
	<span class=kd>var</span> <span class=nx>insertk</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span>
	<span class=kd>var</span> <span class=nx>elem</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span>
<span class=nx>bucketloop</span><span class=p>:</span>
	<span class=k>for</span> <span class=p>{</span>
		<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nb>uintptr</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>bucketCnt</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
			<span class=k>if</span> <span class=nx>b</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>!=</span> <span class=nx>top</span> <span class=p>{</span>
				<span class=k>if</span> <span class=nf>isEmpty</span><span class=p>(</span><span class=nx>b</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span> <span class=o>&amp;&amp;</span> <span class=nx>inserti</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
					<span class=nx>inserti</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>b</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
					<span class=nx>insertk</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>b</span><span class=p>),</span> <span class=nx>dataOffset</span><span class=o>+</span><span class=nx>i</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>keysize</span><span class=p>))</span>
					<span class=nx>elem</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>b</span><span class=p>),</span> <span class=nx>dataOffset</span><span class=o>+</span><span class=nx>bucketCnt</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>keysize</span><span class=p>)</span><span class=o>+</span><span class=nx>i</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>elemsize</span><span class=p>))</span>
				<span class=p>}</span>
				<span class=k>if</span> <span class=nx>b</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>==</span> <span class=nx>emptyRest</span> <span class=p>{</span>
					<span class=k>break</span> <span class=nx>bucketloop</span>
				<span class=p>}</span>
				<span class=k>continue</span>
			<span class=p>}</span>
			<span class=nx>k</span> <span class=o>:=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>b</span><span class=p>),</span> <span class=nx>dataOffset</span><span class=o>+</span><span class=nx>i</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>keysize</span><span class=p>))</span>
			<span class=k>if</span> <span class=nx>t</span><span class=p>.</span><span class=nf>indirectkey</span><span class=p>()</span> <span class=p>{</span>
				<span class=nx>k</span> <span class=p>=</span> <span class=o>*</span><span class=p>((</span><span class=o>*</span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)(</span><span class=nx>k</span><span class=p>))</span>
			<span class=p>}</span>
			<span class=k>if</span> <span class=p>!</span><span class=nx>t</span><span class=p>.</span><span class=nx>key</span><span class=p>.</span><span class=nf>equal</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>k</span><span class=p>)</span> <span class=p>{</span>
				<span class=k>continue</span>
			<span class=p>}</span>
			<span class=c1>// already have a mapping for key. Update it.
</span><span class=c1></span>			<span class=k>if</span> <span class=nx>t</span><span class=p>.</span><span class=nf>needkeyupdate</span><span class=p>()</span> <span class=p>{</span>
				<span class=nf>typedmemmove</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>key</span><span class=p>,</span> <span class=nx>k</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span>
			<span class=p>}</span>
			<span class=nx>elem</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>b</span><span class=p>),</span> <span class=nx>dataOffset</span><span class=o>+</span><span class=nx>bucketCnt</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>keysize</span><span class=p>)</span><span class=o>+</span><span class=nx>i</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>elemsize</span><span class=p>))</span>
			<span class=k>goto</span> <span class=nx>done</span>
		<span class=p>}</span>
		<span class=nx>ovf</span> <span class=o>:=</span> <span class=nx>b</span><span class=p>.</span><span class=nf>overflow</span><span class=p>(</span><span class=nx>t</span><span class=p>)</span>
		<span class=k>if</span> <span class=nx>ovf</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=k>break</span>
		<span class=p>}</span>
		<span class=nx>b</span> <span class=p>=</span> <span class=nx>ovf</span>
	<span class=p>}</span>

	<span class=c1>// Did not find mapping for key. Allocate new cell &amp; add entry.
</span><span class=c1></span>
	<span class=c1>// If we hit the max load factor or we have too many overflow buckets,
</span><span class=c1></span>	<span class=c1>// and we&#39;re not already in the middle of growing, start growing.
</span><span class=c1></span>	<span class=k>if</span> <span class=p>!</span><span class=nx>h</span><span class=p>.</span><span class=nf>growing</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=nf>overLoadFactor</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>count</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=nx>h</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span> <span class=o>||</span> <span class=nf>tooManyOverflowBuckets</span><span class=p>(</span><span class=nx>h</span><span class=p>.</span><span class=nx>noverflow</span><span class=p>,</span> <span class=nx>h</span><span class=p>.</span><span class=nx>B</span><span class=p>))</span> <span class=p>{</span>
		<span class=nf>hashGrow</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>h</span><span class=p>)</span>
		<span class=k>goto</span> <span class=nx>again</span> <span class=c1>// Growing the table invalidates everything, so try again
</span><span class=c1></span>	<span class=p>}</span>

	<span class=k>if</span> <span class=nx>inserti</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=c1>// The current bucket and all the overflow buckets connected to it are full, allocate a new one.
</span><span class=c1></span>		<span class=nx>newb</span> <span class=o>:=</span> <span class=nx>h</span><span class=p>.</span><span class=nf>newoverflow</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>b</span><span class=p>)</span>
		<span class=nx>inserti</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>newb</span><span class=p>.</span><span class=nx>tophash</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
		<span class=nx>insertk</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>newb</span><span class=p>),</span> <span class=nx>dataOffset</span><span class=p>)</span>
		<span class=nx>elem</span> <span class=p>=</span> <span class=nf>add</span><span class=p>(</span><span class=nx>insertk</span><span class=p>,</span> <span class=nx>bucketCnt</span><span class=o>*</span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>keysize</span><span class=p>))</span>
	<span class=p>}</span>

	<span class=c1>// store new key/elem at insert position
</span><span class=c1></span>	<span class=k>if</span> <span class=nx>t</span><span class=p>.</span><span class=nf>indirectkey</span><span class=p>()</span> <span class=p>{</span>
		<span class=nx>kmem</span> <span class=o>:=</span> <span class=nf>newobject</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>key</span><span class=p>)</span>
		<span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)(</span><span class=nx>insertk</span><span class=p>)</span> <span class=p>=</span> <span class=nx>kmem</span>
		<span class=nx>insertk</span> <span class=p>=</span> <span class=nx>kmem</span>
	<span class=p>}</span>
	<span class=k>if</span> <span class=nx>t</span><span class=p>.</span><span class=nf>indirectelem</span><span class=p>()</span> <span class=p>{</span>
		<span class=nx>vmem</span> <span class=o>:=</span> <span class=nf>newobject</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>elem</span><span class=p>)</span>
		<span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)(</span><span class=nx>elem</span><span class=p>)</span> <span class=p>=</span> <span class=nx>vmem</span>
	<span class=p>}</span>
	<span class=nf>typedmemmove</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>key</span><span class=p>,</span> <span class=nx>insertk</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span>
	<span class=o>*</span><span class=nx>inserti</span> <span class=p>=</span> <span class=nx>top</span>
	<span class=nx>h</span><span class=p>.</span><span class=nx>count</span><span class=o>++</span>

<span class=nx>done</span><span class=p>:</span>
	<span class=k>if</span> <span class=nx>h</span><span class=p>.</span><span class=nx>flags</span><span class=o>&amp;</span><span class=nx>hashWriting</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;concurrent map writes&#34;</span><span class=p>)</span>
	<span class=p>}</span>
	<span class=nx>h</span><span class=p>.</span><span class=nx>flags</span> <span class=o>&amp;^=</span> <span class=nx>hashWriting</span>
	<span class=k>if</span> <span class=nx>t</span><span class=p>.</span><span class=nf>indirectelem</span><span class=p>()</span> <span class=p>{</span>
		<span class=nx>elem</span> <span class=p>=</span> <span class=o>*</span><span class=p>((</span><span class=o>*</span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)(</span><span class=nx>elem</span><span class=p>))</span>
	<span class=p>}</span>
    
    <span class=c1>// 返回elem地址，由汇编代码负责执行真正的写入操作
</span><span class=c1></span>	<span class=k>return</span> <span class=nx>elem</span>
<span class=p>}</span>
</code></pre></div><h4 id=删除>删除<a href=#删除 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><p>删除对应的底层函数是 <a href=https://github.com/golang/go/blob/ac0ba6707c/src/runtime/map.go#L685>runtime/map.mapdelete</a> ，处理的思路非常相似，也是先判断各种情况，最后进行双重循环定位目标 cell，不再赘述了。</p><h4 id=扩容>扩容<a href=#扩容 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><p>扩容过程较为复杂，总的来说，扩容分为 增量扩容 与 等量扩容，前者有两种情况触发，一是在桶不够用时，即容量到达扩容因子时，二是在，后者是在桶空间较为稀疏时触发，作用不同。</p><p>需要注意的一点是，扩容并不是一次性完成的，而是渐进式的，在每次进行写入操作时搬运一部分元素，主要目的也是为了防止瞬时的性能抖动对整个应用造成影响。</p><h5 id=等量扩容>等量扩容<a href=#等量扩容 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h5><p>等量扩容的目的是使得桶的数据密度不至于过小，想象一种极端场景，一个哈希表有1个位置，拉链出了100个bucket，但只有一个元素，它在最后一个桶（正常桶+溢出桶）的最后一个位置上，我们每次访问这个元素，都需要从头到尾扫描这n个桶，直到找到这个元素，显而易见，这样效率非常低，所以go语言运行时会动态修改这个大小，进行数据的紧缩，使得数据密度增大增大，既增加了效率，也减少了所需空间。</p><p>等量扩容的代码在 xxxxx，</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go>
</code></pre></div><p>主要做了这些事：</p><ul><li></li><li></li><li></li><li></li></ul><h5 id=增量扩容>增量扩容<a href=#增量扩容 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h5><p>增量扩容的出现场景就是桶不够用，即容量到达了负载因子的限制大小，需要进行扩大，具体与hmap。b的大小有关：</p><ul><li>当b《=15时，如果桶大小一旦超过这个值扩容</li><li>当b》15，如果桶大小大于2…………15次方就扩容</li></ul><p>扩容时由于b的大小+1，所以掩码的低位位数会+1，最高位的0和1会把所有元素分到两个部分，在go中这两部分被命名为 evaluatex，evaluatey，</p><p>具体代码放在 xxxx，</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go>
</code></pre></div><h3 id=总结>总结<a href=#总结 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>Go 语言的 map 使用了数组+链表实现的哈希表，引入了溢出桶的概念以及触发扩容的条件机制来减少桶的扩容，实现了平均 O(1) 的时间复杂度内访问元素，基本不会出现最坏的情况。</p><p>访问元素的大致流程时：经过哈希计算后，用低 B 位确定桶位置，高 8 位比对 tophash 找到偏移，再通过偏移找到 key/value，或者执行插入或者新增溢出桶等等逻辑。</p><p>不管你使用字面量的方式还是 make 的方式声明 map，都是对应底层的 hmap 结构，获得了一个指向 hmap 的指针，并且 Go 语言针对不给出初始大小的 map 还进行了快速初始化的优化，针对 map 的大小过大（hmap.B 大于4），提前建立溢出桶的优化。</p><p>Go 提供了两种方式访问 map 中的元素，可以获得两个返回值，第二个返回值可以忽略，这用于空键值对的判断，类似于数据库中的 NULL，不和任何值冲突。并且 map 的遍历访问是随机的，这是因为每次遍历时会通过 fastrand 生成一个随机数，随机选择一个桶，再随机选择桶中的一个元素，先遍历完该桶，再顺次遍历后续的桶。map 是可以并发访问（指读）的，因为这并不会有任何冲突发生。</p></div><div class=content><br><img src=https://blogimagee.oss-cn-beijing.aliyuncs.com/images/gzh.webp width=80% height=60%></div><hr class=post-end><footer class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=tag><a href=https://kcode.icu/tags/go>Go</a></span><span class=tag><a href=https://kcode.icu/tags/%E6%BA%90%E7%A0%81>源码</a></span></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>1165 Words</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>2021-01-22 23:35 +0000</p></footer></article><div class="post-nav thin"><a class=next-post href=https://kcode.icu/posts/go/2021-01-25-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3go-defer%E7%89%88%E6%9C%AC%E5%B7%AE%E5%BC%82%E4%B8%8E%E5%BA%95%E5%B1%82%E7%89%B9%E6%80%A7/><span class=post-nav-label><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"/><polyline points="12 19 5 12 12 5"/></svg>&nbsp;Newer</span><br><span>深入理解 Go defer 版本差异与底层特性</span></a>
<a class=prev-post href=https://kcode.icu/posts/chore/blog_imgs/><span class=post-nav-label>Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></svg></span><br><span>在线博客的图床解决方案</span></a></div><div id=comments class=thin><script src=https://utteranc.es/client.js repo=sh1luo/sh1luo issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></main><footer id=site-footer class="section-inner thin animated fadeIn faster"><p>&copy; 2018 - 2022 <a href=https://kcode.icu/>wasabi</a></p><p>Made with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> &#183; Theme <a href=https://github.com/Track3/hermit target=_blank rel=noopener>Hermit</a> &#183; <a href=https://kcode.icu/post/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></p></footer><script src=https://kcode.icu/js/main.min.784417f5847151f848c339cf0acb13a06cbb648b1483435a28ed4556c4ead69b.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-193315904-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>