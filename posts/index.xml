<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on 失落</title>
		<link>https://kcode.icu/posts/</link>
		<description>Recent content in Posts on 失落</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>zh-hans</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Fri, 15 Jan 2021 23:10:22 +0000</lastBuildDate>
		<atom:link href="https://kcode.icu/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>聊聊你最常见的HTTP</title>
			<link>https://kcode.icu/posts/http/</link>
			<pubDate>Fri, 15 Jan 2021 23:10:22 +0000</pubDate>
			
			<guid>https://kcode.icu/posts/http/</guid>
			<description>标题的这句话我想应该没有什么争议，对大多数人来说日常生活中接触到最多的应用层协议就是 HTTP了，从聊天软件、浏览器页面再到各种游戏实现，它们无处不在。这篇文章我就带你来看一看这个处于 OSI 标准最上层、最常用也是最普通的 HTTP 它究竟有什么“东西”，一起作为一个不只是听说过的“大神”。
HTTP是什么 超文本传输协议（Hypertext Transfer Protocol，HTTP）。</description>
			<content type="html"><![CDATA[<p>标题的这句话我想应该没有什么争议，对大多数人来说日常生活中接触到最多的应用层协议就是 HTTP了，从聊天软件、浏览器页面再到各种游戏实现，它们无处不在。这篇文章我就带你来看一看这个处于 OSI 标准最上层、最常用也是最普通的 HTTP 它究竟有什么“东西”，一起作为一个不只是听说过的“大神”。</p>
<h2 id="http是什么">HTTP是什么</h2>
<p>超文本传输协议（Hypertext Transfer Protocol，HTTP）。</p>
]]></content>
		</item>
		
		<item>
			<title>几经周折的博客变迁史</title>
			<link>https://kcode.icu/posts/chore/blog_journey/</link>
			<pubDate>Wed, 06 Jan 2021 21:13:13 +0000</pubDate>
			
			<guid>https://kcode.icu/posts/chore/blog_journey/</guid>
			<description>仔细想起来我的博客旅程也有好多年了，兜兜转转地走了不少弯路，也确实在这个过程中学到了很多东西，大致有这些时间节点：
 尝试购买了国内域名和学生机服务器，看到自己写的内容能在公网上让全世界的人看到就高兴了好久，内容很随意，自己管理。 使用 hexo 框架系统化内容，并部署到 GitHub Page 上交给 GitHub 管理。 发现了国内访问速度更快的 Gitee Page。 再次购买域名，使用 CDN 加速国外空间，未果（下文说）&amp;hellip;&amp;hellip;  前前后后也折腾了好几年，技术上的提升我倒觉得不太大，因为折腾地挺多但是都是应用层面上的，对我来说更多的是动手能力的提高，有好多东西不经过自己亲手尝试是根本理解不了的，我前面很多东西就是别人远程或者一步一步告诉我让我去点这个点那个就可以了，但是回过头来问你，你根本不知道发生了什么，甚至隔天就忘，这是典型的不理解、死记硬背式学习方法。
当时配置那个 A 记录，CNAME 记录啥的根本不知道是什么东西，也不知道 DNS 是什么，就是配，成功了就行，不成功就猜，一个个试呗。现在想想，真的是走了不少弯路，如果能系统地学一下多好。不过这些问题也都在我后来的实践以及学习过程中逐一解决了，现在遇到问题也不用像没头苍蝇一样乱撞了，这种感觉很不错 :)
这件事也让我大致理解了一句老话，大致是这么说的：真正厉害的技术人员不是说他写程序一定要多么多么厉害，而是他有非常强悍的问题定位能力（trouble shooting），能解决别人解决不了的问题，而这一切都源自于无数经验的积累以及深度的思考。
下面说我的最后一次迁移：)
 之所以有两个部分是因为买了域名后才发现必须要国内域名并且备案，才能加速国内。我买的是国外域名所以没办法，最后就用 GitHub Page + 自定义域名了。
 GitHub Page+自定义域名 这种方案比较简单（因为GitHub 都帮我们做了），你首先需要创建一个名为 &amp;lt;YourGitHubName&amp;gt;.github.io 的仓库，比如 sh1luo.github.io，然后购买一个域名（国内国外都行，国内要备案），给他添加一条 CNAME 记录 ，就像这样
我是国外的域名，所以转为了国内的 DNSPod 进行解析，希望快一点，做法也非常简单。就是把原域名服务器商的 NameServers 改成 新解析服务器提供的就好了，如上图的 hickory.dnspod.net 那两条。
当然，如果你本来就是国内域名，就不用这么麻烦了，直接添加一条 CNAME 记录，然后在 GitHub Pages 那里设置上自定义域名就完事了，它会自动帮你部署 HTTPS 和一切的 :)
CDN加速 如果你是国内的域名但是是国外的空间，就可以使用 CDN 加速了，加速区域选国内。这里需要注意源站地址由于是 GitHub Pages ，而 GitHub Pages 有 4 个 IP。都写上一行一个，回源 HOST 写你自己地址就可以了。这个回源 HOST 实际上就是 HTTP 头里的 host 字段，如果同一台机器上有多个服务的话，用来标识是哪一个服务，比较常见就是一个 IP 地址上配置了多个域名，就是通过这种给 host 首部字段的方式区分的不同 Web 站点。</description>
			<content type="html"><![CDATA[<p>仔细想起来我的博客旅程也有好多年了，兜兜转转地走了不少弯路，也确实在这个过程中学到了很多东西，大致有这些时间节点：</p>
<ul>
<li>尝试购买了国内域名和学生机服务器，看到自己写的内容能在公网上让全世界的人看到就高兴了好久，内容很随意，自己管理。</li>
<li>使用 hexo 框架系统化内容，并部署到 GitHub Page 上交给 GitHub 管理。</li>
<li>发现了国内访问速度更快的 Gitee Page。</li>
<li>再次购买域名，使用 CDN 加速国外空间，未果（下文说）&hellip;&hellip;</li>
</ul>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/image-20210118174633253.png" alt="现在的博客"></p>
<p>前前后后也折腾了好几年，技术上的提升我倒觉得不太大，因为折腾地挺多但是都是应用层面上的，对我来说更多的是动手能力的提高，有好多东西不经过自己亲手尝试是根本理解不了的，我前面很多东西就是别人远程或者一步一步告诉我让我去点这个点那个就可以了，但是回过头来问你，你根本不知道发生了什么，甚至隔天就忘，这是典型的不理解、死记硬背式学习方法。</p>
<p>当时配置那个 A 记录，CNAME 记录啥的根本不知道是什么东西，也不知道 DNS 是什么，就是配，成功了就行，不成功就猜，一个个试呗。现在想想，真的是走了不少弯路，如果能系统地学一下多好。不过这些问题也都在我后来的实践以及学习过程中逐一解决了，现在遇到问题也不用像没头苍蝇一样乱撞了，这种感觉很不错 :)</p>
<p>这件事也让我大致理解了一句老话，大致是这么说的：真正厉害的技术人员不是说他写程序一定要多么多么厉害，而是他有非常强悍的问题定位能力（trouble shooting），能解决别人解决不了的问题，而这一切都源自于无数经验的积累以及深度的思考。</p>
<p>下面说我的最后一次迁移：)</p>
<blockquote>
<p>之所以有两个部分是因为买了域名后才发现必须要国内域名并且备案，才能加速国内。我买的是国外域名所以没办法，最后就用 GitHub Page + 自定义域名了。</p>
</blockquote>
<h2 id="github-page自定义域名">GitHub Page+自定义域名</h2>
<p><!-- raw HTML omitted --></p>
<p>这种方案比较简单（因为GitHub 都帮我们做了），你首先需要创建一个名为 <code>&lt;YourGitHubName&gt;.github.io</code> 的仓库，比如 <code>sh1luo.github.io</code>，然后购买一个域名（国内国外都行，国内要备案），给他添加一条 <a href="https://baike.baidu.com/item/CNAME/9845877?fr=aladdin">CNAME 记录</a> ，就像这样</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/image-20210119101326692.png" alt="DNS记录"></p>
<p>我是国外的域名，所以转为了国内的 <a href="https://www.dnspod.cn/">DNSPod</a> 进行解析，希望快一点，做法也非常简单。就是把原域名服务器商的 NameServers 改成 新解析服务器提供的就好了，如上图的 hickory.dnspod.net 那两条。</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/image-20210118183902580.png" alt="image-20210118183902580"></p>
<p>当然，如果你本来就是国内域名，就不用这么麻烦了，直接添加一条 CNAME 记录，然后在 GitHub Pages 那里设置上自定义域名就完事了，它会自动帮你部署 HTTPS 和一切的 :)</p>
<h2 id="cdn加速">CDN加速</h2>
<p>如果你是国内的域名但是是国外的空间，就可以使用 CDN 加速了，加速区域选国内。这里需要注意源站地址由于是 GitHub Pages ，而 GitHub Pages 有 4 个 IP。都写上一行一个，回源 HOST 写你自己地址就可以了。这个回源 HOST 实际上就是 HTTP 头里的 host 字段，如果同一台机器上有多个服务的话，用来标识是哪一个服务，比较常见就是一个 IP 地址上配置了多个域名，就是通过这种给 host 首部字段的方式区分的不同 Web 站点。</p>
<p><!-- raw HTML omitted --></p>
<p>配置完源站信息后，会生成一个 CDN 域名，比如我的是 <code>kcode.icu.cdn.dnsv1.com</code> ，然后再添加一条 CNAME 记录指向这个域名就搞定。参考上面的 <code>DNS记录</code> 这张图。这样配置过，你的网站经过缓存后国内访问速度能达到非常恐怖的速度，可以试着 ping 一下哦。</p>
<h2 id="actions自动化构建">Actions自动化构建</h2>
<h2 id="说在最后">说在最后</h2>
<p>之前是在阿里云买的是国内域名并在阿里云备案，到期之后续费价格是之前 10 倍。。在这个期间还不小心把备案号主体（直到现在我也不知道是个啥，貌似还需要写个书面申请到当地管局）不小心删了，再次备案怎么也申请不过，左右摇头+上下点头了几十分钟脖子都酸了还不通过，于是直接去 <a href="https://www.namesilo.com/">NameSilo</a> 上买的国外域名。这里没什么好说的就是付费就完事（手动狗头）。</p>
<p>因为这是国外域名服务器，如果你想用国内域名服务器解析的话（比如国内的），就把 NameServers 设置为目标域名服务器提供的记录值就可以了，其实就是一条 NS 记录。我用的还是它默认的域名服务器，因为我的是国外域名，CDN 国内加速不了，必须要备案，下面会说。</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/image-20210117164512937.png" alt="hickory这个位置字段的这两条就是"></p>
<p>如果你要修改域名服务器的话，在目标网站上里创建域名后，就会为你生成若干条 NS 记录，回到原网站修改了就好了。</p>
<blockquote>
<p>买域名可以选择国内也可以选择国外，国内必须备案，国外不用。</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>记人生中前几次面试及思考</title>
			<link>https://kcode.icu/posts/interview/2020-12-interview/</link>
			<pubDate>Sun, 03 Jan 2021 21:18:13 +0000</pubDate>
			
			<guid>https://kcode.icu/posts/interview/2020-12-interview/</guid>
			<description>写作背景 由于早早有了就业的想法，于是我在大三上学期快要结束的时候便早早地”物色“各大公司的实习了，也是希望能在就业前增加几段实习经历，丰富一下经验。这也是人生中我的第一次面试，感触颇多。特别记录下来自己的总结以及对于假期自己的学习规划。
面试总结 这次我面试的总共有三家公司，跟谁学、字节跳动和腾讯，对我印象最深也是帮助最大的就是”字节跳动“。关于面试的准备大致有三块，简历、技术口述和手撕代码，下面分开说。
简历 我个人使用的简历大致是这样的风格，简约并且色调一致。简历这块我倒没什么卡壳，简历没过的 我猜 都是因为学历等等硬性条件不合适，这也是没有办法的事情。这里需要确保这么几点：
 不要造假，实事求是 。虽然有的公司面试官根本不看你简历问（我的几次实习面试不看，校招社招应该是要看的），但是如果你写熟悉甚至精通，你躲过了 HR，但是人家面试官上来问了一个很简单的问题你答不上来，人家可能没兴趣继续问了。。在面试官心里你的这项技术等于没写，并且有了吹牛的成分，众所周知，搞技术的都不喜欢这种人。 拿出有说服力的证据。 这一条不单指技术也包括其他方面，举个例子，如果你写了你优化了这个项目，那么等于没写，谁知道你优化了多少？比如原来服务器 CPU 总是跑到 90+%，然后你通过 xxx 手段优化，优化到了稳定在 70% 左右，这就比较有说服里，面试官也比较好针对你的这个点去问。再举个例子，你在个人相关那栏里写英语能力强，学习能力不错，热爱新技术，咱就不说过没过四六级了，人家让你现场看个技术文，获取跟你聊两句，你蒙蔽了，尴尬不。问你平时咋学习的，你磕磕巴巴说不出个所以然，或者一点逻辑没有，东一头看书，西一头看视频，再来一手看野生技术文章，你说尴尬不。 注意行业基础。 我拿技术来说，搞技术的，你说你写了个热爱技术，结果写个 GitHub ，都能拼错，写成 Github 等等，写个 CSDN 写成 Csdn ，虽说这不是什么大事，但是这些书面东西，我们搞技术的不能犯错的，这给人的印象就是你很不专业，或者说你接触的很少以至于记不清楚。假如说你说热爱开源，整天 GitHub 排行榜逛个遍，你告诉我你不知道 GitHub 怎么拼，不合适吧？我曾经见过一个人说他懂这懂那，结果拿来简历一看，关于技术的名字错了好几个，还说自己热爱这些，实际水平也就可想而知了。  我个人关于简历这块总结就是这样，虽然说简历很重要，但是我认为还是不难写的，把握好这些点即可 :)
技术口述 这部分是面试重头戏，除去手撕代码部分其余就是这个了（还可能有项目环节），对于这部分我感触最多。大体是，以前我认为掌握一种技术就是会用来解决某个问题就完事了，不想探究怎么实现的。举个例子，现在需要有个从反序列化出来的 json 字节数组里拿某个字段的值，以前的我就是去找个库用用完事了，现在经过大厂面试洗礼的我是这样的：我能不能自己写一个，看他代码不多呀，这样写效率高不高？紧接着看了源代码之后就会惊叹：哇还能这么设计，哇这个还能这么用，厉害了。。。真实。。。
而实际面试里也是这样的，我们不能只考虑表现层面的东西，而要去探究其底层大致的实现原理，只有这样，当你遇到问题的时候才能有初步想法从而去解决，而不是只会去问别人。别人不告诉你或者怎样你就解决不了了，不是有那么一句话说得好嘛，好的工程师（注意不是程序员）并不是他写的代码多厉害，而是他遇到问题总是能快速定位问题，并以最优雅的方式去解决，这一点值得我们深思。学会用工程师的视角去解决问题也是我们每一个人的最终目标。
在面试过程中我也遇到了很多之前没考虑过的问题，举个例子，我写的 RPC 框架里，大的问题比如说 注册中心挂了怎么办？能不能自动通过 .proto 文件生成规范的并且与我们框架配合使用的 RPC 代码？小的问题比如说 底层用的 NIO，NIO是什么，为什么快等等。因为我这个框架说白了只在运输层以上工作，我只在运输层以上思考，也就是说只是应用层面理解了而已，只是更深一点点的应用层面罢了，所以当面试官问我一系列深层次的问题后，我的问题就暴露出来了：对这个框架没有进一步的思考和认识。所以这也是我接下来要去思考和改进的一个点。项目大致都是如此，比如你写了一个 Web 类型的项目，用到了某某框架、技术或者标准库，你就要思考为什么它很好？好在哪了？我个人对它有优化吗？我实际上做了什么事情呢？我能从哪些方面提高它的并发量或者说是功能技术创新呢？
总结来说就是项目要有一定规模，有一定自己的思考在里面，别人问你关于你项目的特色，你的工作点，你都有的说。
假期规划 </description>
			<content type="html"><![CDATA[<h2 id="写作背景">写作背景</h2>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/bytedance.jpg" alt=""></p>
<p>由于早早有了就业的想法，于是我在大三上学期快要结束的时候便早早地”物色“各大公司的实习了，也是希望能在就业前增加几段实习经历，丰富一下经验。这也是人生中我的第一次面试，感触颇多。特别记录下来自己的总结以及对于假期自己的学习规划。</p>
<h2 id="面试总结">面试总结</h2>
<p>这次我面试的总共有三家公司，跟谁学、字节跳动和腾讯，对我印象最深也是帮助最大的就是”字节跳动“。关于面试的准备大致有三块，简历、技术口述和手撕代码，下面分开说。</p>
<h3 id="简历">简历</h3>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/image-20210103221551405.png" alt=""></p>
<p>我个人使用的简历大致是这样的风格，简约并且色调一致。简历这块我倒没什么卡壳，简历没过的 <strong>我猜</strong> 都是因为学历等等硬性条件不合适，这也是没有办法的事情。这里需要确保这么几点：</p>
<ul>
<li><strong>不要造假，实事求是</strong> 。虽然有的公司面试官根本不看你简历问（我的几次实习面试不看，校招社招应该是要看的），但是如果你写熟悉甚至精通，你躲过了 HR，但是人家面试官上来问了一个很简单的问题你答不上来，人家可能没兴趣继续问了。。在面试官心里你的这项技术等于没写，并且有了吹牛的成分，众所周知，搞技术的都不喜欢这种人。</li>
<li><strong>拿出有说服力的证据。</strong> 这一条不单指技术也包括其他方面，举个例子，如果你写了你优化了这个项目，那么等于没写，谁知道你优化了多少？比如原来服务器 CPU 总是跑到 90+%，然后你通过 xxx 手段优化，优化到了稳定在 <strong>70%</strong> 左右，这就比较有说服里，面试官也比较好针对你的这个点去问。再举个例子，你在个人相关那栏里写英语能力强，学习能力不错，热爱新技术，咱就不说过没过四六级了，人家让你现场看个技术文，获取跟你聊两句，你蒙蔽了，尴尬不。问你平时咋学习的，你磕磕巴巴说不出个所以然，或者一点逻辑没有，东一头看书，西一头看视频，再来一手看野生技术文章，你说尴尬不。</li>
<li><strong>注意行业基础。</strong> 我拿技术来说，搞技术的，你说你写了个热爱技术，结果写个 <code>GitHub</code> ，都能拼错，写成 <code>Github</code> 等等，写个 <code>CSDN</code> 写成 <code>Csdn</code> ，虽说这不是什么大事，但是这些书面东西，我们搞技术的不能犯错的，这给人的印象就是你很不专业，或者说你<strong>接触的很少以至于记不清楚</strong>。假如说你说热爱开源，整天 <code>GitHub</code> 排行榜逛个遍，你告诉我你不知道 <code>GitHub</code> 怎么拼，不合适吧？我曾经见过一个人说他懂这懂那，结果拿来简历一看，关于技术的名字错了好几个，还说自己热爱这些，实际水平也就可想而知了。</li>
</ul>
<p>我个人关于简历这块总结就是这样，虽然说简历很重要，但是我认为还是不难写的，把握好这些点即可 :)</p>
<h3 id="技术口述">技术口述</h3>
<p>这部分是面试重头戏，除去手撕代码部分其余就是这个了（还可能有项目环节），对于这部分我感触最多。大体是，以前我认为掌握一种技术就是会用来解决某个问题就完事了，不想探究怎么实现的。举个例子，现在需要有个从反序列化出来的 <code>json</code> 字节数组里拿某个字段的值，以前的我就是去找个库用用完事了，现在经过大厂面试洗礼的我是这样的：我能不能自己写一个，看他代码不多呀，这样写效率高不高？紧接着看了源代码之后就会惊叹：哇还能这么设计，哇这个还能这么用，厉害了。。。真实。。。</p>
<p>而实际面试里也是这样的，<strong>我们不能只考虑表现层面的东西，而要去探究其底层大致的实现原理，只有这样，当你遇到问题的时候才能有初步想法从而去解决，而不是只会去问别人</strong>。别人不告诉你或者怎样你就解决不了了，不是有那么一句话说得好嘛，好的工程师（注意不是程序员）并不是他写的代码多厉害，而是他遇到问题总是能快速定位问题，并以最优雅的方式去解决，这一点值得我们深思。<strong>学会用工程师的视角去解决问题也</strong>是我们每一个人的最终目标。</p>
<p>在面试过程中我也遇到了很多之前没考虑过的问题，举个例子，我写的 RPC 框架里，大的问题比如说 注册中心挂了怎么办？能不能自动通过 .proto 文件生成规范的并且与我们框架配合使用的 RPC 代码？小的问题比如说 底层用的 NIO，NIO是什么，为什么快等等。因为我这个框架说白了只在运输层以上工作，我只在运输层以上思考，也就是说只是应用层面理解了而已，只是更深一点点的应用层面罢了，所以当面试官问我一系列深层次的问题后，我的问题就暴露出来了：对这个框架没有进一步的思考和认识。所以这也是我接下来要去思考和改进的一个点。项目大致都是如此，比如你写了一个 Web 类型的项目，用到了某某框架、技术或者标准库，你就要思考为什么它很好？好在哪了？我个人对它有优化吗？我实际上做了什么事情呢？我能从哪些方面提高它的并发量或者说是功能技术创新呢？</p>
<p>总结来说就是项目<strong>要有一定规模</strong>，<strong>有一定自己的思考</strong>在里面，别人问你关于你项目的特色，你的工作点，你<strong>都有的说</strong>。</p>
<h2 id="假期规划">假期规划</h2>
]]></content>
		</item>
		
		<item>
			<title>手写一个RPCg（上）</title>
			<link>https://kcode.icu/posts/rpc/rpcg/</link>
			<pubDate>Sat, 28 Nov 2020 15:45:13 +0000</pubDate>
			
			<guid>https://kcode.icu/posts/rpc/rpcg/</guid>
			<description>须知 可能看到这里的一部分人还不知道什么是 RPC，也不知道为什么要用 RPC，内心：HTTP不香吗？那么你需要首先看一下这篇文章：
 你觉得HTTP哪都好用是因为你不知道RPC
 已经实现的 这篇文章我会带你手写一个简易版本的 RPC 框架，这个框架会支持如下这些功能：
 多种网络传输方式 服务端自动注册可导出服务 可以心跳保活的注册中心 服务注册与服务发现 多种序列化方式 超时控制 一些负载均衡策略，一致性哈希、平滑带权轮询等  未来需要做的   自定义的代码生成插件
  一种压缩方式
  基于服务器时延的负载均衡策略？
  心里有数 ”切忌重复造轮子“这句话你应该听过，不过这个”框架“的目的是带领我们大致了解 RPC 框架的工作过程，目标并不是工业级应用，我想你也一定清楚用框架和自己写框架对框架的理解程度有什么区别。也不必把 RPC 想成多么”高端“的技术，RPC 也只是一个调用，微服务的一个组件，从小的地方出发更容易让人接受罢了。好了，话不多说，让我们正式开始。
俯瞰RPCg 这个图向我们展示了最基本的 RPC 调用关系：服务端将自己的服务注册到注册中心，客户端从注册中心获取所有服务端的所有信息，在拿到这些信息之后带着自己的请求去访问某个服务端的服务。你可能会问为什么要多个”第三者“注册中心出来呢，我直接就只有客户端和服务端多方便，那你需要思考以下问题：
 直接通信是不是需要将通信的地址等服务端信息硬编码到客户端的代码中？如果服务端节点数改变了怎么办，难道手动删改代码？ 客户端怎么知道服务端可不可用？难道需要服务端开个服务专门去处理这类信息吗？这属于服务端的业务吗？ &amp;hellip;&amp;hellip;  我想你应该大致能明白为什么需要这个注册中心了，就是屏蔽对方对己方的感知，通过一个第三方中介来提供/提出自己的服务/需求，这就够了，你可以类比 房产中介，婚介所等等机构，当然，注册中心还有很多功能，我们这里为了学习，就只提供这部分功能了，更多的需要留给你去探索 :)
我们再想想，我们现在有了三个主体，之前有不同的需求，怎么提供通信。业界有非常多的解决方法，比如 gRPC 的 HTTP/2.0，它的优势也是显而易见的：多路复用，pipelining 的通信方式，效率大幅提高，不必在等待对方的回复；首部压缩，这里我需要说明一下，RPC 调用大部分是服务端内部的互相调用，比如公司机房里 50 台机器之间相互调用，需要保证传输的效率，也就是说传送的数据要尽可能地小，这才有了 Protocol Buffers 的数据格式，所以经过压缩的首部数据量更小，效率更高。还有 tcp 连接，优势是简单等等。
等待更新&amp;hellip;&amp;hellip;.</description>
			<content type="html"><![CDATA[<h1 id="须知">须知</h1>
<p>可能看到这里的一部分人还不知道什么是 RPC，也不知道为什么要用 RPC，内心：HTTP不香吗？那么你需要首先看一下这篇文章：</p>
<blockquote>
<p><a href="">你觉得HTTP哪都好用是因为你不知道RPC</a></p>
</blockquote>
<h2 id="已经实现的">已经实现的</h2>
<p>这篇文章我会带你手写一个简易版本的 RPC 框架，这个框架会支持如下这些功能：</p>
<ul>
<li>多种网络传输方式</li>
<li>服务端自动注册可导出服务</li>
<li>可以心跳保活的注册中心</li>
<li>服务注册与服务发现</li>
<li>多种序列化方式</li>
<li>超时控制</li>
<li>一些负载均衡策略，一致性哈希、平滑带权轮询等</li>
</ul>
<h2 id="未来需要做的">未来需要做的</h2>
<ul>
<li>
<p>自定义的代码生成插件</p>
</li>
<li>
<p>一种压缩方式</p>
</li>
<li>
<p>基于服务器时延的负载均衡策略？</p>
</li>
</ul>
<h2 id="心里有数">心里有数</h2>
<p>”切忌重复造轮子“这句话你应该听过，不过这个”框架“的目的是带领我们大致了解 RPC 框架的工作过程，目标并不是工业级应用，我想你也一定清楚用框架和自己写框架对框架的理解程度有什么区别。也不必把 RPC 想成多么”高端“的技术，RPC 也只是一个调用，微服务的一个组件，从小的地方出发更容易让人接受罢了。好了，话不多说，让我们正式开始。</p>
<h1 id="俯瞰rpcg">俯瞰RPCg</h1>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/2C28140D4115AF68D708DAB4515B012C.jpg" alt="img"></p>
<p>这个图向我们展示了最基本的 RPC 调用关系：服务端将自己的服务注册到注册中心，客户端从注册中心获取所有服务端的所有信息，在拿到这些信息之后带着自己的请求去访问某个服务端的服务。你可能会问为什么要多个”第三者“注册中心出来呢，我直接就只有客户端和服务端多方便，那你需要思考以下问题：</p>
<ul>
<li>直接通信是不是需要将通信的地址等服务端信息硬编码到客户端的代码中？如果服务端节点数改变了怎么办，难道手动删改代码？</li>
<li>客户端怎么知道服务端可不可用？难道需要服务端开个服务专门去处理这类信息吗？这属于服务端的业务吗？</li>
<li>&hellip;&hellip;</li>
</ul>
<p>我想你应该大致能明白为什么需要这个注册中心了，就是屏蔽对方对己方的感知，通过一个第三方中介来提供/提出自己的服务/需求，这就够了，你可以类比 房产中介，婚介所等等机构，当然，注册中心还有很多功能，我们这里为了学习，就只提供这部分功能了，更多的需要留给你去探索 :)</p>
<p>我们再想想，我们现在有了三个主体，之前有不同的需求，怎么提供通信。业界有非常多的解决方法，比如 gRPC 的 HTTP/2.0，它的优势也是显而易见的：多路复用，pipelining 的通信方式，效率大幅提高，不必在等待对方的回复；首部压缩，这里我需要说明一下，RPC 调用大部分是服务端内部的互相调用，比如公司机房里 50 台机器之间相互调用，需要保证传输的效率，也就是说传送的数据要尽可能地小，这才有了 Protocol Buffers 的数据格式，所以经过压缩的首部数据量更小，效率更高。还有 tcp 连接，优势是简单等等。</p>
<p>等待更新&hellip;&hellip;.</p>
]]></content>
		</item>
		
		<item>
			<title>你觉得HTTP最香是因为你还不知道RPC</title>
			<link>https://kcode.icu/posts/rpc/rpcvshttp/</link>
			<pubDate>Tue, 10 Nov 2020 21:30:13 +0000</pubDate>
			
			<guid>https://kcode.icu/posts/rpc/rpcvshttp/</guid>
			<description>我在动手写 RPCg 这个”框架“之前看了大量的文章阐述 RPC 与 HTTP，这篇文章是比较不错的一篇，我翻译过来和你分享一下 :)
REST vs. RPC你要使用API去解决什么问题？ 有一则关于这个农民的笑话，他被问到”为什么他要尽量避免耕种出‘童话环’的形状“，他回答道，”因为如果我不那么做，我就会变成傻子“。（第一段的引用故事可暂时不关注）。
许多人关于他们自己构建的 APIs 会说同样的话，事实上，去思考一下你要用你的 APIs 去解决什么问题这非常重要，因为你所创建的 API 的风格和你所使用的技术都依赖于你上面的回答。
根据调用 自从 FORTRAN Ⅱ 在1958 年提出调用（也叫函数）这个概念，函数（调用）就一直是组织计算机代码的主要结构。所有现在主流被用来构建和使用 API 的编程语言例如 Java,Javascript, Python, Golang, C/C++ 和 PHP 都使用调用（也就是函数）来作为他们的主要组织结构。因此这数十年来”函数调用“以远程过程调用（RPC） 的形式称为设计和实现分布式 API 的主要模型也就不足为奇了。
如果你要问大多数软件开发者为什么要定义和构建 API，他们可能会解释说他们有个应用，它需要实现多个分布式组件，并且这些组件之间可以互相调用，来使整个应用程序正常运行。他们也可能说需要实现由多个应用程序使用的服务 API。</description>
			<content type="html"><![CDATA[<p>我在动手写 RPCg 这个”框架“之前看了大量的文章阐述 RPC 与 HTTP，这篇文章是比较不错的一篇，我翻译过来和你分享一下 :)</p>
<h1 id="rest-vs-rpc你要使用api去解决什么问题">REST vs. RPC你要使用API去解决什么问题？</h1>
<p>有一则关于这个农民的笑话，他被问到”为什么他要尽量避免耕种出‘童话环’的形状“，他回答道，”因为如果我不那么做，我就会变成傻子“。（第一段的引用故事可暂时不关注）。</p>
<p>许多人关于他们自己构建的 APIs 会说同样的话，事实上，去思考一下你要用你的 APIs 去解决什么问题这非常重要，因为你所创建的 API 的风格和你所使用的技术都依赖于你上面的回答。</p>
<h2 id="根据调用">根据调用</h2>
<p>自从 FORTRAN Ⅱ 在1958 年提出调用（也叫函数）这个概念，函数（调用）就一直是组织计算机代码的主要结构。所有现在主流被用来构建和使用 API 的编程语言例如 Java,Javascript, Python, Golang, C/C++ 和 PHP 都使用调用（也就是函数）来作为他们的主要组织结构。因此这数十年来”函数调用“以远程过程调用（RPC） 的形式称为设计和实现分布式 API 的主要模型也就不足为奇了。</p>
<p>如果你要问大多数软件开发者为什么要定义和构建 API，他们可能会解释说他们有个应用，它需要实现多个分布式组件，并且这些组件之间可以互相调用，来使整个应用程序正常运行。他们也可能说需要实现由多个应用程序使用的服务 API。</p>
]]></content>
		</item>
		
		<item>
			<title>一文搞懂ASCII、Unicode和UTF</title>
			<link>https://kcode.icu/posts/ascii-unicode-utf/</link>
			<pubDate>Fri, 18 Sep 2020 09:27:13 +0000</pubDate>
			
			<guid>https://kcode.icu/posts/ascii-unicode-utf/</guid>
			<description>起因 最初在学习 Go 语言的各种类型时发现内置字符类型有两种类型，一种是 byte（1 字节表示一个 ASCII 字符），还有一个就是 rune 类型，可能从其他语言转过来的开发者都会对 rune 觉得非常陌生，我自己也是仅仅停留在会用的阶段上，久而久之就会特别乱，所以写一篇博客介绍一下各种字符以及编码方便彼此学习，彻底解决这类问题。
什么是ASCII，为什么又要引入Unicode 都应该了解过 ASCII、Unicode、Unicode 码点、UTF-8等一系列名词。先说 ASCII（American Standard Code for Information Interchange: 美国信息交换标准代码），它是一种字符集，说白了就是一个字符和数字的一一对应关系，你想找这个字符怎么办，计算机又不认识字符？给出他的对应的数字就行了。最初只有美国等一些使用英文的国家使用，所以 128 个字符完全够用，它包含了标点符号、数字和字母等。但是随着世界上使用计算机的国家越来越多，这 128 个字符是完全不够用的。所以 Unicode 字符集 就出现了。Unicode 包含了世界上绝大多数的字符，给他们提供了一一对应关系，比如“知”字对应 30693，即 U+77e5（16 进制形式）。所以说白了 ASCII 和 Unicode 就是一种字符集，一种字符对应关系，Unicode 中每个字符被称为一个 Code Point（码点），而 Go 语言中的 rune 类型正是代表了这样一个单位，即一个 rune 代表了一个 unicode 字符。
那么大家肯定都听说过 UTF-8，UTF-16 吧，那问题来了， UTF 又是什么呢，UTF-8 和 UTF-16 到底又有什么关系呢？
UTF（Unicode Transformation Format） 从字面上你就应该能看出来，这就是一个 Unicode 转换格式。什么是转换格式，为什么需要转换格式？上文说了 Unicode 就是提供了字符间的一一对应关系，比如“知”对应了 30693，那计算机怎么表示这个数（计算机只认识二进制）？它要做到：
在很长的文本中准确获取到每个字符，不能找错 **Unicode 表示一个字符可以使用 1 - 4 个字节。**它的转换规则如下：</description>
			<content type="html"><![CDATA[<h2 id="起因">起因</h2>
<p>最初在学习 Go 语言的各种类型时发现内置字符类型有两种类型，一种是 byte（1 字节表示一个 ASCII 字符），还有一个就是 rune 类型，可能从其他语言转过来的开发者都会对 rune 觉得非常陌生，我自己也是仅仅停留在<strong>会用</strong>的阶段上，久而久之就会特别乱，所以写一篇博客介绍一下各种字符以及编码方便彼此学习，彻底解决这类问题。</p>
<h2 id="什么是ascii为什么又要引入unicode">什么是ASCII，为什么又要引入Unicode</h2>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/ascii.png" alt="image"></p>
<p>都应该了解过 ASCII、Unicode、Unicode 码点、UTF-8等一系列名词。先说 ASCII（American Standard Code for Information Interchange: 美国信息交换标准代码），它是一种<strong>字符集</strong>，说白了就是一个字符和数字的<strong>一一对应关系</strong>，你想找这个字符怎么办，计算机又不认识字符？给出他的对应的数字就行了。最初只有美国等一些使用英文的国家使用，所以 128 个字符完全够用，它包含了标点符号、数字和字母等。但是随着世界上使用计算机的国家越来越多，这 128 个字符是完全不够用的。所以 <strong>Unicode 字符集</strong> 就出现了。Unicode 包含了世界上绝大多数的字符，给他们提供了一一对应关系，比如“知”字对应 30693，即 U+77e5（16 进制形式）。所以说白了 ASCII 和 Unicode 就是<strong>一种字符集</strong>，<strong>一种字符对应关系</strong>，Unicode 中每个字符被称为一个 <strong>Code Point</strong>（码点），而 Go 语言中的 rune 类型正是代表了这样一个单位，即一个 rune 代表了一个 unicode 字符。</p>
<p>那么大家肯定都听说过 UTF-8，UTF-16 吧，那问题来了， UTF 又是什么呢，UTF-8 和 UTF-16 到底又有什么关系呢？</p>
<h2 id="utfunicode-transformation-format">UTF（Unicode Transformation Format）</h2>
<p>从字面上你就应该能看出来，这就是一个 Unicode 转换格式。什么是转换格式，为什么需要转换格式？上文说了 Unicode 就是提供了字符间的一一对应关系，比如“知”对应了 30693，那计算机怎么表示这个数（计算机只认识二进制）？它要做到：</p>
<pre><code>在很长的文本中准确获取到每个字符，不能找错
</code></pre><p>**Unicode 表示一个字符可以使用 1 - 4 个字节。**它的转换规则如下：</p>
<table>
<thead>
<tr>
<th>1 字节</th>
<th>0xxxxxxx</th>
</tr>
</thead>
<tbody>
<tr>
<td>2 字节</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>3 字节</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>4 字节</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody>
</table>
<p>解释：如果它表示一个字符只需要 1 个字节，那么表示的就是 ASCII 字符集，从0 -&gt; 127。如果需要 2 个及以上字节表示，那么<strong>第一个字节的前 n 位是 1 ，第 n+1 位是 0，后面每个字节的前两位均为 10（n 是所需字节数）。</strong></p>
<p>所以按照上述规则，“知”字的二进制为：</p>
<pre><code>30693（十进制） -&gt; U+77E5(十六进制) -&gt; 0111 0111 1110 0101（二进制）
</code></pre><p>所以对应的 UTF-8 编码为：<strong>1110</strong>0111 <strong>10</strong>011111 <strong>10</strong>100101，你只需要从低位到高位依次按规则填充即可。</p>
<p>看到这里，我想有思考的读者应该有疑问，为什么原本只需要两字节就能表示的字经过 UTF-8 转换后需要三个字节了，这不是白白地增加内存消耗吗？你可以回忆一下哈夫曼编码的构建结果：将长短不同的<strong>二进制位段</strong>直接放在一起却不会读错，是因为他们没有共同前缀。这里的原理类似，要解决地问题是 <strong>怎么确保长短不同的字符不会重合</strong>。由于有的字符只需要一个字节，而有的需要两个，三个，n 个。当他们堆放在一起时，怎么保证不会出现读少，读多？</p>
<p>解释这个问题，我举个例子，“你”字<strong>假设</strong>表示的十六进制是 A，“我”是 B，“你我”是 AA，“好”是 AB，那我将“你好”放一起时表示就是 AAB，它为什么不是“你你我”，或者“你我我”？</p>
<p>我相信如果你看懂了这个例子，应该就能明白为什么 UTF-8 被称为变长编码了。</p>
<p>这段的标题是 UTF，上面只说了 UTF-8，其实常用的还有 UTF-16，UTF-8 是将一个字节作为一个单位，随着所需字节数量的不同给他们不同的前缀，当计算机读到第一个字节时，通过判断前面连续 1 的个数就能判断未来多少位属于这个字符的范围,，从而解决了不会读错的问题。而 UTF-16 是<strong>将两个字节作为了一个单位</strong>。原理类似，有兴趣的读者可以自己再去探索，我相信你会有更多的发现 :)</p>
<h2 id="验证结果梳理思路">验证结果，梳理思路</h2>
<p>我们可以写一个简单的 Go 语言程序来验证这个结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
 <span class="nx">str</span> <span class="o">:=</span> <span class="s">&#34;hello,狗狼&#34;</span>
 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">str</span><span class="p">))</span>
 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">([]</span><span class="nb">rune</span><span class="p">(</span><span class="nx">str</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre></div><p>输出结果为：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="m">12</span>
<span class="m">8</span>

Process finished with <span class="nb">exit</span> code <span class="m">0</span>
</code></pre></div><p>这里需要说明的是，str 字符串的底层实现就是一个字节数组，根据上面所说的汉字占用 3 个字节，总字节长度为 6+3+3=12，而转换为 rune 类型后，所有字符都占用一个 Unicode <strong>Code Point</strong>（码点），所以占用了共 8 个字符，共 8 个码点。</p>
<p>综上所述，ASCII 和 Unicode 都是一种字符集，代表了字符与数字间的一一对应关系。而 UTF 是一种变长的字符编码规范。而 rune 是 Go 语言中的一个变量类型，一个 rune 代表了一个 Unicode 码点单位。以上。</p>
<p>因个人能力有限，有疏漏之处欢迎和我交流 :)</p>
]]></content>
		</item>
		
		<item>
			<title>OBS显示器捕获黑屏解决方案</title>
			<link>https://kcode.icu/posts/chore/obs/</link>
			<pubDate>Sun, 26 Apr 2020 11:34:13 +0000</pubDate>
			
			<guid>https://kcode.icu/posts/chore/obs/</guid>
			<description>问题起因 由于我最近重新安装了系统，在重新下载 OBS 后发现捕获不到桌面。我之前解决方法就是直接在显卡控制面板里将 OBS 设置为集显就行了。但是这次设置了也不行，有可能是我下载的显卡驱动版本不对。。于是就找到了这个终极解决方案，基本电脑上有这个功能的都能解决。
问题环境 操作系统：Win10 64位 专业版 - 1909
CPU 集成显卡型号：Inter(R) UHD Graphics 630
独立显卡型号：NVIDIA GeForce GTX 1050
OBS 版本：25.0.4(64 bit)
 注：配置和我不一样也有可能解决，不用纠结
 问题描述 在来源中添加显示器捕获后 ，是黑屏，无法捕获到显示器。
问题分析 目前网上能搜集到的解决方案大部分是以下几种：
 右键 OBS 属性 - 兼容性 - 兼容模式 - 以兼容模式运行这个程序（win7）设置 - 以管理员方式运行 桌面上右键打开 NVIDIA 控制面板，管理 3D 设置 - 程序设置，找到 OBS，设置为集成图形。  但是我都试了都解决不了，我就去搜了一下问题的原因，最终发现 OBS 只能捕捉到和自己跟自己使用相同显卡的应用，然后我右键打开任务管理器，发现笔记本桌面使用的是我的集显。所以就需要把 OBS 设置为应用集显。
解决方法 左下角开始按钮 - 设置 - 系统 - 显示 - 图形设置 - 经典应用里浏览添加 OBS ，点击选项，设置为节能，节能就是使用集显。然后你再打开 OBS&amp;hellip;&amp;hellip;</description>
			<content type="html"><![CDATA[<h2 id="问题起因">问题起因</h2>
<p>由于我最近重新安装了系统，在重新下载 OBS 后发现捕获不到桌面。我之前解决方法就是直接在<strong>显卡控制面板</strong>里将 OBS 设置为集显就行了。但是这次设置了也不行，有可能是我下载的显卡驱动版本不对。。于是就找到了这个终极解决方案，基本电脑上有这个功能的都能解决。</p>
<h2 id="问题环境">问题环境</h2>
<p>操作系统：Win10 64位 专业版 - 1909</p>
<p>CPU 集成显卡型号：Inter(R) UHD Graphics 630</p>
<p>独立显卡型号：NVIDIA GeForce GTX 1050</p>
<p>OBS 版本：25.0.4(64 bit)</p>
<blockquote>
<p>注：配置和我不一样也有可能解决，不用纠结</p>
</blockquote>
<h2 id="问题描述">问题描述</h2>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/obs-noscreen.png" alt=""></p>
<p>在来源中添加<strong>显示器捕获后</strong> ，是黑屏，<strong>无法捕获到显示器</strong>。</p>
<h2 id="问题分析">问题分析</h2>
<p>目前网上能搜集到的解决方案大部分是以下几种：</p>
<ul>
<li>右键 OBS 属性 - 兼容性 - 兼容模式 - 以兼容模式运行这个程序（win7）设置 -  以管理员方式运行</li>
<li>桌面上右键打开 NVIDIA 控制面板，管理 3D 设置 - 程序设置，找到 OBS，设置为集成图形。</li>
</ul>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/obs-gpu.png" alt="任务管理器最下面"></p>
<p>但是我都试了都解决不了，我就去搜了一下问题的原因，<strong>最终</strong>发现 OBS <strong>只能捕捉到和自己跟自己使用相同显卡的应用</strong>，然后我右键打开任务管理器，发现笔记本桌面使用的是我的集显。所以就需要把 OBS 设置为应用集显。</p>
<h2 id="解决方法">解决方法</h2>
<p><!-- raw HTML omitted --></p>
<p>左下角开始按钮 - 设置 - 系统 - 显示 - 图形设置 - 经典应用里浏览添加 OBS ，点击选项，设置为节能，节能就是使用集显。然后你再打开 OBS&hellip;&hellip;</p>
<p>这时候你就会发现你成功了。</p>
<p>其他的推流软件也一样，比如什么 B 站直播姬等同理。</p>
<p>以上。</p>
]]></content>
		</item>
		
	</channel>
</rss>
