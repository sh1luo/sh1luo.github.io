<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on 失落</title>
		<link>https://www.kcode.icu/posts/</link>
		<description>Recent content in Posts on 失落</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>zh-hans</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Wed, 27 Jan 2021 15:57:50 +0000</lastBuildDate>
		<atom:link href="https://www.kcode.icu/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>https为什么安全，绝对安全吗</title>
			<link>https://www.kcode.icu/posts/secure/</link>
			<pubDate>Wed, 27 Jan 2021 15:57:50 +0000</pubDate>
			
			<guid>https://www.kcode.icu/posts/secure/</guid>
			<description>截图均使用了 Wireshark 工具进行抓包分析。
 简介 HTTP 是无状态协议，这一特性极大地增强了 HTTP 协议的灵活性，设计的高度自由随着发展也带来了各种问题。比如明文传输且无法验证通信方身份，不适合在安全场景下使用等等。
所以提出了 HTTPS 的概念。HTTPS 并不是新的协议，而是 HTTP over SSL/TLS，也就是使用了 SSL/TLS 加密的 HTTP，解决了 HTTP 不安全的问题。SSL（Secure Sockets Layer） 是 TLS（Transport Layer Security） 的前身，SSL 经历了三个版本的变迁，后来升级为了 TLS，TLS 主要有 1.0、1.1、1.2 和 1.3，版本越高兼容性越不好，现在大部分正在从 1.1 到 1.2 的迁移，部分使用 1.3，我们可以使用 Wireshark 过滤一下进行简单查看。
需要注意的是，应用了 HTTPS 后通信效率会变低，毕竟需要进行额外的握手，加解密步骤。
证书 不管什么版本的 SSL/TLS，只使用对称加密和非对称加密也是不够的，因为无法解决中间人攻击，都需要配合证书来完成整个验证过程。所以在说明 TLS/1.2 与 TLS/1.3 之前有必要介绍一下证书的几个概念。
证书的作用有两个：
 确保通信目标的身份。 确认你的身份。  其实就是确认通信双方的身份，而不是中间某个第三者。再结合非对称加密与对称加密，就可以解决 HTTP 的三大问题，明文传输，消息篡改，窃听。证书的整个流程如下图：
加密与签名 这里有一点需要注意，非对称加密中的公私钥有两种用法，被称为 加密 和 签名 ，很多人容易搞混。不过需要记住不变的是 私钥永远需要保密，不能公布。
 前者是使用公钥加密，私钥解密。将公钥发布出去，只有自己才能获得加密信息，用于 保护信息。 后者是私钥加密，公钥解密。用于 判断信息是否被篡改。  加密很好理解，签名可以这样理解：私钥加密的签名其他人无法伪造（其他人没有私钥），而你将经过私钥加密的信息和未加密明文还有公钥一起交付，对方就可以用公钥去解密（公钥是公开的），然后比对，如果一致了就说明信息没有被篡改，否则已经被改过了，抛弃。</description>
			<content type="html"><![CDATA[<blockquote>
<p>截图均使用了 <a href="https://www.wireshark.org/">Wireshark</a> 工具进行抓包分析。</p>
</blockquote>
<h2 id="简介">简介</h2>
<p>HTTP 是无状态协议，这一特性极大地增强了 HTTP 协议的灵活性，设计的高度自由随着发展也带来了各种问题。比如明文传输且无法验证通信方身份，不适合在安全场景下使用等等。</p>
<p>所以提出了 HTTPS 的概念。HTTPS  并不是新的协议，而是 <code>HTTP over SSL/TLS</code>，也就是使用了 SSL/TLS 加密的 HTTP，解决了 HTTP 不安全的问题。SSL（Secure Sockets Layer） 是 TLS（Transport Layer Security） 的前身，SSL 经历了三个版本的变迁，后来升级为了 TLS，TLS 主要有 1.0、1.1、1.2 和 1.3，版本越高兼容性越不好，现在大部分正在从 1.1 到 1.2 的迁移，部分使用 1.3，我们可以使用 Wireshark 过滤一下进行简单查看。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/640.png" alt="Wireshark截图"></p>
<p>需要注意的是，应用了 HTTPS 后通信效率会变低，毕竟需要进行额外的握手，加解密步骤。</p>
<h2 id="证书">证书</h2>
<p>不管什么版本的 SSL/TLS，只使用对称加密和非对称加密也是不够的，因为无法解决中间人攻击，都需要配合证书来完成整个验证过程。所以在说明 TLS/1.2 与 TLS/1.3 之前有必要介绍一下证书的几个概念。</p>
<p>证书的作用有两个：</p>
<ul>
<li>确保通信目标的身份。</li>
<li>确认你的身份。</li>
</ul>
<p>其实就是确认通信双方的身份，而不是中间某个第三者。再结合非对称加密与对称加密，就可以解决 HTTP 的三大问题，明文传输，消息篡改，窃听。证书的整个流程如下图：</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/ca.png" alt="ca"></p>
<h3 id="加密与签名">加密与签名</h3>
<p>这里有一点需要注意，非对称加密中的公私钥有两种用法，被称为 <strong>加密</strong> 和 <strong>签名</strong> ，很多人容易搞混。不过需要记住不变的是 <strong>私钥永远需要保密</strong>，不能公布。</p>
<ul>
<li>前者是使用公钥加密，私钥解密。将公钥发布出去，只有自己才能获得加密信息，用于 <strong>保护信息</strong>。</li>
<li>后者是私钥加密，公钥解密。用于 <strong>判断信息是否被篡改</strong>。</li>
</ul>
<p>加密很好理解，签名可以这样理解：私钥加密的签名其他人无法伪造（其他人没有私钥），而你将经过私钥加密的信息和未加密明文还有公钥一起交付，对方就可以用公钥去解密（公钥是公开的），然后比对，如果一致了就说明信息没有被篡改，否则已经被改过了，抛弃。</p>
<p>整个过程可以参考上图，证书的过程就是使用了加密和签名两种手段。</p>
<h3 id="信任链">信任链</h3>
<p>在你申请到 CA 的证书并部署，在客户端请求时返回后，客户端的验证过程是有信任链验证的。你可以随便打开一个部署了 HTTPS 的站点，点击锁图标查看证书路径。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/image-20210129114612091.png" alt=""></p>
<p>可以看到你的证书是处于最下级，也就是三级证书，这个证书是由上一级证书机构 Secure Site CA G2 签发的，由于它不是根证书，无法认为它可靠，所以要再向上级寻找直到根证书。然后使用根证书公钥验证二级证书，依次向下，直到目标服务器的证书。</p>
<p>为什么要这样一步一步验证好多次呢？</p>
<p>因为我们只相信根证书，而根证书是部署在操作系统上的，是被我们信任的。Windows 10 系统可以通过</p>
<pre><code>控制面板 -&gt; 搜索证书 -&gt; 管理计算机证书 
</code></pre><p>方式之一来查看本地根证书。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/Snipaste_2021-01-28_21-32-27.png" alt=""></p>
<p>好了，你现在应该大致明白了证书的验证过程，再来一张图看总结一下。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/640%20(1).png" alt="640 (1)"></p>
<p>到现在，我们已经利用证书机制确保了通信双方的身份，解决了不安全的问题之一。</p>
<h2 id="tls12">TLS1.2</h2>
<p>RSA 是一种非对称加密算法，也是可以用来加密和签名的算法之一。先来看一下 TLS1.2 版本握手步骤：</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/tls-hs-ecdhe.png" alt="tls-hs-ecdhe"></p>
<p>TLS/1.2 的共需要 4 次握手，花费两个 RTT（Round-Trip Time，RTT），加上 TCP 握手就是一共 7 次握手，再加上 HTTP 的一次报文交换，一共需要 4.5 个 RTT。</p>
<p>握手过程较为麻烦，大致过程如下：</p>
<ol>
<li>
<p>客户端向服务端发送 <strong>Client Hello</strong> 消息，其中携带客户端支持的<strong>协议版本</strong>，<strong>加密套件</strong>，压缩算法、<strong>客户端生成的随机数</strong> 以及扩展列表，不过安全的客户端一般不允许压缩，会传递一个 null 作为唯一的压缩算法，来避免 <a href="https://en.wikipedia.org/wiki/CRIME">CRIME attack</a> 。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/client-hello.png" alt="client-hello"></p>
</li>
<li>
<p>服务端收到客户端发来的协议版本、加密算法等信息后：</p>
<ol>
<li>
<p>向客户端发送 <strong>Server Hello</strong> 消息，并选择其中一个协议版本、加密方法、会话 ID 以及 <strong>服务端生成的随机数</strong>；这里的加密方法格式非常规范：</p>
<pre><code>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
</code></pre><p>上面的加密套件的意思是：生成密钥所使用的算法为 ECDHE_RSA，后续通信使用的对称加密算法 128位的AES，分组模式是 GCM（对称加密的关键），哈希摘要算法 SHA256。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/server-hello.png" alt="server-hello"></p>
</li>
<li>
<p>向客户端发送 Certificate 消息，即服务端的证书链，其中包含证书支持的域名、发行方和有效期等信息；</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/server-certificate.png" alt=""></p>
</li>
<li>
<p>向客户端发送 Server Key Exchange 消息，传递 ECDHE 算法的参数，也被称为 server_params，还有签名等信息。这个过程还会被签名，即签名这个摘要值：</p>
<pre><code>SHA256(client_random + server_random + server_params)
</code></pre><p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/dhe-params.png" alt="dhe-params"></p>
</li>
<li>
<p>向客户端发送可选的消息 CertificateRequest，验证客户端的证书。因为 TLS 握手是一个双向认证的过程，所以服务端可以向客户端发送请求来验证客户端身份。这个验证的回复再第三次握手阶段发出。</p>
</li>
<li>
<p>向客户端发送 Server Hello Done 消息，通知服务端已经发送了全部的相关信息；</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/server-hello-done.png" alt="server-hello-done"></p>
</li>
</ol>
</li>
<li>
<p>客户端收到服务端的协议版本、加密方法、会话 ID 以及证书等信息后，验证服务端的证书；</p>
<ol>
<li>
<p>向服务端发送 Client Key Exchange 消息，包含客户端生成的公钥字符串，然后计算得到预主密钥（Pre Master Secret），再利用之前在客户端和服务端分别产生的两个随机数，还有伪随机数函数也就是 SHA256 哈希摘要函数，最终计算得到最终的主密钥（Master Key）；</p>
<pre><code>master_secret = PRF(pre_master_secret, &quot;master secret&quot;, client_random + server_random)[0..47]
</code></pre><p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/client-dhe-key%20(1).png" alt="client-dhe-key (1)"></p>
</li>
<li>
<p>向服务端发送 Change Cipher Spec 消息，通知服务端后面的数据段会加密传输。</p>
</li>
<li>
<p>向服务端发送 Finished 消息，其中包含加密后的握手信息。这个消息包含之前通信的所有信息以及之前的两个随机字符串，求哈希值后再加密，确保服务端能正常解密并且确认无误，还能避免重放攻击。</p>
</li>
</ol>
</li>
<li>
<p>服务端收到 Change Cipher Spec 和 Finished 消息后计算得到预主密钥（Pre Master Secret），然后同样流程计算得到最终的主密钥；</p>
<ol>
<li>向客户端发送 Change Cipher Spec 消息，通知客户端后面的数据段会加密传输；</li>
<li>向客户端发送 Finished 消息，验证客户端的 Finished 消息并完成 TLS 握手；</li>
</ol>
</li>
</ol>
<p>TLS 握手的关键在于利用通信双方生成的随机字符串和服务端的公钥生成一个双方经过协商后的密钥，通信的双方可以使用这个对称的密钥加密消息防止中间人的监听和攻击，保证通信的安全。</p>
<p>这么多繁琐的步骤就是为了验证两方身份的情况下协商出一个对称加密的密钥。</p>
<p>你可能会问，为什么 非对称加密这么强什么都能干为啥还要再使用对称加密呢？</p>
<p>原因是<strong>对称加密效率高</strong>，大致是非对称加密的几十上百倍。</p>
<h2 id="tls13">TLS1.3</h2>
<p>TLS/1.2 握手过程繁琐，验证复杂，所以花费时间也是非常长，TLS/1.3 版本就对此做出了优化。主要优化有两个方面。</p>
<h3 id="安全">安全</h3>
<p>TLS/1.3 精简了加密套件，</p>
<h3 id="性能">性能</h3>
<h2 id="总结">总结</h2>
]]></content>
		</item>
		
		<item>
			<title>深入理解 Go map</title>
			<link>https://www.kcode.icu/posts/go/map/</link>
			<pubDate>Fri, 22 Jan 2021 23:35:20 +0000</pubDate>
			
			<guid>https://www.kcode.icu/posts/go/map/</guid>
			<description>哈希表 几乎所有语言都有 哈希表 这个数据结构，能够在平均 O(1)，最差 O(n) 的时间复杂度增删改查元素，Go 语言哈希表的精妙设计使得它几乎不会出现 O(n) 的糟糕情况。这篇文章我就带你从使用到底层由浅入深地探究 Go map 的奥秘，一起作一个不只是会用的”大神“。
问题来源于实际，我们先看看这些问题 ：
 声明。当我使用 :=，var，make，甚至 new 声明 map 的时候，编译器帮我们做了什么事情，它们有什么区别？ 增删改查。使用 数组+链表 的情况下如何设计才能避免 O(n) 的最差情况？ 注意事项。map 的键有什么要求？map 是值类型还是引用类型，函数传参时会有上层影响吗？是并发安全的吗？  还有一个常识是 Go map 的遍历是随机的，即多次遍历输出的结果集不同。
设计方式/数据结构 Go map 实现哈希表使用的是 数组+链表 的形式，也就是使用链地址法解决的哈希冲突。这种方式桶的大小和元素个数之间没有关系，另外还有开放定址法，这是个宽泛的名字，具体包含线性探测法，再哈希法，平方探测法等等。
为了降低 map 操作的时间复杂度，引入了一个 负载因子 的概念，这个概念在其他实现哈希表这个数据结构的语言里也都有，比如 python 中这个值被定义为 2/3，Java 中是 0.75，这个值评估了哈希表里 实际上最好只存 多少比例的元素，而不是一直等到满载再处理，因为多到一定程度效率 可能 就低了。在 Go 语言里这个值被定义为 6.5，即每个桶里最多存 6.5 个，包括溢出桶。
当我们在 Go 语言中声明一个 map 的时候，实际上就是创建了一个 hmap 的结构体，它定义在 runtime/map.go 文件下，这个结构体包含了许多信息：map 的大小，桶数量、地址，溢出桶数量、地址等等。 哈希表就是实现一个映射关系，给出自变量 x，能够通过平均 O(1) 的时间复杂度方法找到这个元素所对应的因变量 y=f(x) 来对它进行操作。</description>
			<content type="html"><![CDATA[<h2 id="哈希表">哈希表</h2>
<p>几乎所有语言都有 <a href="https://en.wikipedia.org/wiki/Hash_table">哈希表</a> 这个数据结构，能够在平均 O(1)，最差 O(n) 的时间复杂度增删改查元素，Go 语言哈希表的精妙设计使得它几乎不会出现 O(n) 的糟糕情况。这篇文章我就带你从使用到底层由浅入深地探究 Go map 的奥秘，一起作一个不只是会用的”大神“。</p>
<p>问题来源于实际，我们先看看这些问题 ：</p>
<ul>
<li><strong>声明</strong>。当我使用 <code>:=</code>，<code>var</code>，<code>make</code>，甚至 <code>new</code> 声明 map 的时候，编译器帮我们做了什么事情，它们有什么区别？</li>
<li><strong>增删改查</strong>。使用 数组+链表 的情况下如何设计才能避免 O(n) 的最差情况？</li>
<li><strong>注意事项</strong>。map 的键有什么要求？map 是值类型还是引用类型，函数传参时会有上层影响吗？是并发安全的吗？</li>
</ul>
<p>还有一个常识是 Go map 的<strong>遍历是随机的</strong>，即多次遍历输出的结果集不同。</p>
<h3 id="设计方式数据结构">设计方式/数据结构</h3>
<p>Go map 实现哈希表使用的是 <strong>数组+链表</strong> 的形式，也就是使用链地址法解决的哈希冲突。这种方式桶的大小和元素个数之间没有关系，另外还有开放定址法，这是个宽泛的名字，具体包含线性探测法，再哈希法，平方探测法等等。</p>
<p>为了降低 map 操作的时间复杂度，引入了一个 <a href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/map.go#L70">负载因子</a> 的概念，这个概念在其他实现哈希表这个数据结构的语言里也都有，比如 python 中这个值被定义为 2/3，Java 中是 0.75，这个值评估了哈希表里 <strong>实际上最好只存</strong> 多少比例的元素，而不是一直等到满载再处理，因为多到一定程度效率 <strong>可能</strong> 就低了。在 Go 语言里这个值被定义为 6.5，即每个桶里最多存 6.5 个，包括溢出桶。</p>
<p>当我们在 Go 语言中声明一个 map 的时候，实际上就是创建了一个 <a href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/map.go#L115">hmap</a> 的结构体，它定义在 <code>runtime/map.go</code> 文件下，这个结构体包含了许多信息：map 的大小，桶数量、地址，溢出桶数量、地址等等。 哈希表就是实现一个映射关系，给出自变量 x，能够通过平均 O(1) 的时间复杂度方法找到这个元素所对应的因变量 y=f(x) 来对它进行操作。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">hmap</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">count</span>     <span class="kt">int</span> 		<span class="c1">// map的大小，len()的结果就是这个字段值
</span><span class="c1"></span>	<span class="nx">flags</span>     <span class="kt">uint8</span>		<span class="c1">// map的状态，有四个
</span><span class="c1"></span>	<span class="nx">B</span>         <span class="kt">uint8</span>  	<span class="c1">// 桶数量的log_2对数，如B=5，桶数量就是2^5=32
</span><span class="c1"></span>	<span class="nx">noverflow</span> <span class="kt">uint16</span> 	<span class="c1">// approximate number of overflow buckets; see incrnoverflow for details
</span><span class="c1"></span>	<span class="nx">hash0</span>     <span class="kt">uint32</span> 	<span class="c1">// 哈希种子
</span><span class="c1"></span>
	<span class="nx">buckets</span>    <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 桶数组的底层地址
</span><span class="c1"></span>	<span class="nx">oldbuckets</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 旧桶数组的底层地址
</span><span class="c1"></span>	<span class="nx">nevacuate</span>  <span class="kt">uintptr</span>        <span class="c1">// progress counter for evacuation (buckets less than this have been evacuated)
</span><span class="c1"></span>
	<span class="nx">extra</span> <span class="o">*</span><span class="nx">mapextra</span> <span class="c1">// optional fields
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// mapextra holds fields that are not present on all maps.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">mapextra</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// If both key and elem do not contain pointers and are inline, then we mark bucket
</span><span class="c1"></span>	<span class="c1">// type as containing no pointers. This avoids scanning such maps.
</span><span class="c1"></span>	<span class="c1">// However, bmap.overflow is a pointer. In order to keep overflow buckets
</span><span class="c1"></span>	<span class="c1">// alive, we store pointers to all overflow buckets in hmap.extra.overflow and hmap.extra.oldoverflow.
</span><span class="c1"></span>	<span class="c1">// overflow and oldoverflow are only used if key and elem do not contain pointers.
</span><span class="c1"></span>	<span class="c1">// overflow contains overflow buckets for hmap.buckets.
</span><span class="c1"></span>	<span class="c1">// oldoverflow contains overflow buckets for hmap.oldbuckets.
</span><span class="c1"></span>	<span class="c1">// The indirection allows to store a pointer to the slice in hiter.
</span><span class="c1"></span>	<span class="nx">overflow</span>    <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>
	<span class="nx">oldoverflow</span> <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>

	<span class="c1">// nextOverflow holds a pointer to a free overflow bucket.
</span><span class="c1"></span>	<span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span>
<span class="p">}</span>
</code></pre></div><p>真正存储数据的地方被称为桶，map 可以有许多桶，但是每个桶只能存储 8 个键值对，多出来的就要找到一个溢出桶放进去，每个桶的数据结构都是一样的，tophash 是键值经过哈希函数后的值高八位。</p>
<p>这里需要注意一点是，key 和 value 并没有按照 key1/key2/keyN，value1/value2/valueN 的方式存储，而是如图形式，是为了因为字节对齐造成的内存浪费，这一点在官方源代码里有说明。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/map_zipper.svg" alt=""></p>
<h3 id="初始化">初始化</h3>
<h3 id="读写操作">读写操作</h3>
<h4 id="访问">访问</h4>
<h4 id="写入">写入</h4>
<h4 id="删除">删除</h4>
<h4 id="扩容">扩容</h4>
<h3 id="总结">总结</h3>
]]></content>
		</item>
		
		<item>
			<title>在线博客的图床解决方案</title>
			<link>https://www.kcode.icu/posts/chore/blog_imgs/</link>
			<pubDate>Wed, 20 Jan 2021 15:45:13 +0000</pubDate>
			
			<guid>https://www.kcode.icu/posts/chore/blog_imgs/</guid>
			<description>很多人应该都听说过来人说过要写博客进行总结记录，一是说自己学习过程的复盘，二是在某些时候向不认识自己的人间接显示自己的大致水平。不过如果没有人“手把手”教的话我相信还会遇到各种各样的问题的，这篇文章就介绍一下在博客中必不可少的图片网络地址解决方法，也就是图床。它的目标是在你写文章的过程中可以一键插入目标图片并自动上传到网络，就像你使用本地图片一样快捷。
图床的目的就是把你的本地图片上传上去，从而能获得它的网络地址。当然了，只使用图床也是可以的，但是需要配合对应的工具上传拿 URL（比如 OSS）或者纯手动（GitHub/Gitee），非常不方便 一点也不极客，所以需要配合其他工具一键快速拿到它对应的网络地址（URL），所以我在下面介绍了我使用到的工具，仅供参考。
 评估用的稳定性指你上传的图片会不会在某个不确定的时间突然挂掉，让你的文章出现大量图片 404 丢失的情况。
 图床 这里我介绍三种图床，列出优缺点。可以根据需要进行选择。
GitHub/Gitee GitHub 和 Gitee 是干什么的我就不多说了，它们也是可以作为图床使用的，前者境内访问较慢，后者较快。没有账号可以免费注册一个，然后随便创建一个公开仓库，把图片上传上去就可以获取它的 URL 了，比较简单粗暴。
优点：稳定性较好，空间无限，上手难度较简单
缺点：无法阻止盗链，无法管理（原本目的就不是作为图床，没有统计流量等功能）。
总结，如果你是新手，不担心自己的图片被别人轻易获取 ，随缘使用图床，这个是首选。
OSS OSS （Object Storage Service）即对象存储服务，用来做个人博客的图床有点小题大做，腾讯云、阿里云等等提供 OSS 的平台都可以，一般需要续费，一年 50G 左右话 10 块钱左右。
优点：可控性比较强，提供了专业的平台，你能想到的各种需求基本都有，包括防盗链，流量统计与分析等。
缺点：对新手不友好，根据流量付费。
总结，如果你未来博客流量会不断增大，出于可控考虑选这个，流量较小的新人不考虑。
不稳定第三方 也可以使用这种第三方的图床，没有任何操作步骤，上传完就拿到 URL，当然事物都有两面性，这种极致快捷带来的就是不稳定，就跟当年的新浪图床一样，你不知道什么时候它就没了。。
优点：简单快捷打开一键就用，免费
缺点：不知道什么时候你的图片就被人家清了。。然后你的文章里的图片就全部 404 了。。
总结，随缘党首选不解释，懂得都懂。
工具 这里就介绍我使用的两个配合工具，其他的可以自行搜索。
typora typora 是一款 Markdown 文本编辑软件，我相信写过 Markdown 的都听说过，它的特点是真正的实时显示，不左右分栏，扩展性强，灵活可配置。我个人平时写 Markdown 文本都是使用这个软件，具体可以去它的官网首页看，十分推荐。
PicGo PicGo 是一款使用 Node + Electron 开发的跨平台可视化图片上传开源软件，支持 N 种图床平台，配置灵活简单，最重要的是它支持插件功能，理论上支持任意图床平台的使用（需要提供相应上传下载的 API），可以自行开发插件。操作也比较简单，把图片拖到框里就可以拿到 URL。这张图是 gitee 相关配置，其他平台类似，只需若干个必要参数即可：
配合使用 前面说的这两种工具可以结合使用快速进行写作，在 typora 主界面上方，文件-&amp;gt;偏好设置-&amp;gt;图像，修改 PicGo 路径为你安装的路径下的 exe 地址。这样就可以做到你在 typora 里编辑时直接粘贴图片到文档里一键点击上传，非常方便。当然了，如果你不需要 typora，或者使用的是别的 Markdown 编辑器，也可以只使用 PicGo。</description>
			<content type="html"><![CDATA[<p>很多人应该都听说过来人说过要写博客进行总结记录，一是说自己学习过程的复盘，二是在某些时候向不认识自己的人间接显示自己的大致水平。不过如果没有人“手把手”教的话我相信还会遇到各种各样的问题的，这篇文章就介绍一下在博客中必不可少的图片网络地址解决方法，也就是图床。它的目标是<strong>在你写文章的过程中可以一键插入目标图片并自动上传到网络，就像你使用本地图片一样快捷。</strong></p>
<p>图床的目的就是把你的本地图片上传上去，从而能获得它的网络地址。当然了，只使用图床也是可以的，但是需要配合对应的工具上传拿 URL（比如 OSS）或者纯手动（GitHub/Gitee），<del>非常不方便</del> 一点也不极客，所以需要配合其他工具一键快速拿到它对应的网络地址（URL），所以我在下面介绍了我使用到的工具，仅供参考。</p>
<blockquote>
<p>评估用的稳定性指你上传的图片会不会在某个不确定的时间突然挂掉，让你的文章出现大量图片 404 丢失的情况。</p>
</blockquote>
<h1 id="图床">图床</h1>
<p>这里我介绍三种图床，列出优缺点。可以根据需要进行选择。</p>
<h2 id="githubgitee">GitHub/Gitee</h2>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/123.png" alt="Gitee"></p>
<p><a href="https://github.com/">GitHub</a> 和 <a href="https://gitee.com/">Gitee</a> 是干什么的我就不多说了，它们也是可以作为图床使用的，前者境内访问较慢，后者较快。没有账号可以免费注册一个，然后随便创建一个公开仓库，把图片上传上去就可以获取它的 URL 了，比较简单粗暴。</p>
<p>优点：稳定性较好，空间无限，上手难度较简单</p>
<p>缺点：无法阻止盗链，无法管理（原本目的就不是作为图床，没有统计流量等功能）。</p>
<p>总结，如果你是新手，不担心自己的图片被别人<strong>轻易获取</strong> ，随缘使用图床，这个是首选。</p>
<h2 id="oss">OSS</h2>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/image-20210120131946016.png" alt="aliyun OSS"></p>
<p>OSS （Object Storage Service）即对象存储服务，用来做个人博客的图床有点小题大做，腾讯云、阿里云等等提供 OSS 的平台都可以，一般需要续费，一年 50G 左右话 10 块钱左右。</p>
<p>优点：可控性比较强，提供了专业的平台，你能想到的各种需求基本都有，包括防盗链，流量统计与分析等。</p>
<p>缺点：对新手不友好，根据流量付费。</p>
<p>总结，如果你未来博客流量会不断增大，出于可控考虑选这个，流量较小的新人不考虑。</p>
<h2 id="不稳定第三方">不稳定第三方</h2>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/image-20210120132728890.png" alt="SM.MS"></p>
<p>也可以使用这种第三方的图床，没有任何操作步骤，上传完就拿到 URL，当然事物都有两面性，这种极致快捷带来的就是不稳定，就跟当年的新浪图床一样，你不知道什么时候它就没了。。</p>
<p>优点：简单快捷打开一键就用，免费</p>
<p>缺点：不知道什么时候你的图片就被人家清了。。然后你的文章里的图片就全部 404 了。。</p>
<p>总结，随缘党首选不解释，懂得都懂。</p>
<h1 id="工具">工具</h1>
<p>这里就介绍我使用的两个配合工具，其他的可以自行搜索。</p>
<h2 id="typora">typora</h2>
<p><a href="https://typora.io/">typora</a> 是一款 Markdown 文本编辑软件，我相信写过 Markdown 的都听说过，它的特点是真正的实时显示，不左右分栏，扩展性强，灵活可配置。我个人平时写 Markdown 文本都是使用这个软件，具体可以去它的官网首页看，十分推荐。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/GIF%202021-1-20%2018-44-01.gif" alt="实时转换"></p>
<h2 id="picgo">PicGo</h2>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/image-20210120134735352.png" alt=""></p>
<p><a href="https://github.com/Molunerfinn/PicGo">PicGo</a> 是一款使用 Node + Electron 开发的跨平台可视化图片上传开源软件，支持 N 种图床平台，配置灵活简单，最重要的是它支持插件功能，理论上支持任意图床平台的使用（需要提供相应上传下载的 API），可以自行开发插件。操作也比较简单，把图片拖到框里就可以拿到 URL。这张图是 gitee 相关配置，其他平台类似，只需若干个必要参数即可：</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/image-20210120135009612.png" alt="配置"></p>
<h2 id="配合使用">配合使用</h2>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/test.png" alt="PicGo配置"></p>
<p>前面说的这两种工具可以结合使用快速进行写作，在 typora 主界面上方，文件-&gt;偏好设置-&gt;图像，修改 PicGo 路径为你安装的路径下的 exe 地址。这样就可以做到你在 typora 里编辑时直接粘贴图片到文档里一键点击上传，非常方便。当然了，如果你不需要 typora，或者使用的是别的 Markdown 编辑器，也可以只使用 PicGo。</p>
<p>而且它是开源的，如果你有任何建议可以提 Issue 或者自己为它增加特性 :)</p>
<p>我这里就有一个相关需求，自定义重命名上传文件，我想将所有图片按照我自己的规则自动重命名后再上传，比如统一按照格式 <code>year-month-day-imgID</code> 这种格式，方便后续整理图片。当然了，这里只是抛砖引玉，更多的留给大家去探索 :)</p>
<p>最后配一个最终的成品 GIF 图给大家看一下效果：</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/dddd.gif" alt="dddd"></p>
<p>如果你有什么问题欢迎来找我玩，一起交流。</p>
]]></content>
		</item>
		
		<item>
			<title>谈谈最常见的 HTTP</title>
			<link>https://www.kcode.icu/posts/http/</link>
			<pubDate>Fri, 15 Jan 2021 23:10:22 +0000</pubDate>
			
			<guid>https://www.kcode.icu/posts/http/</guid>
			<description>标题的”最常见“我想应该没有什么争议，对大多数人来说日常生活中接触到最多的应用层协议就是 HTTP了，从聊天软件、浏览器页面再到各种游戏实现，它们无处不在。这篇文章我就带你来看一看这个处于 OSI 标准最上层、最常用也是最普通的 HTTP 它究竟有什么“东西”，一起作为一个不只是听说过的“大神”。
这篇博客我想阐述除书本概念之外的一些可能你 理解不深刻 的问题的 个人理解，希望对你有所帮助。
HTTP是什么 超文本传输协议（Hypertext Transfer Protocol，HTTP），是一个应用层面上的，也就是软件双方通信的数据规则，是通信的基石。不然你发给我一串 @#$%$%^$%^，只有你能看懂，我怎么知道你说的是什么玩意？双方按照这个规则去通信，有什么需求都在这个规范里写好了发给对方，对方就知道你想干什么，就可以也按照这个规范给你回过去，就是这么简单。只是因为随着技术的发展，所遇到的问题越来越多，从功能需求，再到安全、效率、可读性等等，不得不提出一系列的解决方案去完善，最终变得很 ”臃肿“ 罢了。但是你应该明白，这就是一个为应用程序通信所提出来的一个基础通信协议。
HTTP方法有什么“实际区别” 你可能听说过类似 “GET 和 POST 有什么区别” 这种问题，其实说到底从底层上来说，它们之间 没有任何区别，仅仅是约定、规范。 也就是说 按照约定，GET 方法的请求 不应该 携带请求体，并且在以前 Postman 这类客户端模拟软件也是不允许构造这类请求的，但是后来也是支持了。
但是，如果你强行带了请求体，是没有任何问题的。你甚至可以把 GET 方法携带上请求体用来登录，使用 POST 请求用来获取 HTML 等静态资源，用 DELETE 方法来为数据库增加一条记录，只要你后端程序员老哥不把你捶死（手动狗头） 🤣🤣🤣
各个版本之间的发展史 HTTP 比较重要的几个发展时间节点是 0.9、1.0、1.1、2.0 和 3.0，每一次的版本变迁都是为了解决前一个版本的性能不足或者功能不完善，我不推荐死记硬背，即使它被称为计算机八股文。
http 0.9和1.1 在 HTTP 0.9 的时候只有 GET 方法，1.0 补充了 POST，DEL 方法完善语义，还添加了几个首部，这个阶段的 HTTP 主要就是完善功能。
1.0 和 1.1 的最大区别就是长短连接了。在 HTTP 1.1 将长连接设置为了默认，也就是：
Connection: keep-alive 在这之前这个字段的默认是 close，长连接的好处是显而易见的，由于 HTTP 是基于 tcp，如果总共传输三个文件，1.</description>
			<content type="html"><![CDATA[<p>标题的”最常见“我想应该没有什么争议，对大多数人来说日常生活中接触到最多的应用层协议就是 HTTP了，从聊天软件、浏览器页面再到各种游戏实现，它们无处不在。这篇文章我就带你来看一看这个处于 OSI 标准最上层、最常用也是最普通的 HTTP 它究竟有什么“东西”，一起作为一个不只是听说过的“大神”。</p>
<p>这篇博客我想阐述除书本概念之外的一些可能你 <strong>理解不深刻</strong> 的问题的 <strong>个人理解</strong>，希望对你有所帮助。</p>
<h2 id="http是什么">HTTP是什么</h2>
<p>超文本传输协议（Hypertext Transfer Protocol，HTTP），是一个应用层面上的，也就是软件双方通信的数据规则，是通信的基石。不然你发给我一串 @#$%$%^$%^，只有你能看懂，我怎么知道你说的是什么玩意？双方按照这个规则去通信，有什么需求都在这个规范里写好了发给对方，对方就知道你想干什么，就可以也按照这个规范给你回过去，就是这么简单。只是因为随着技术的发展，所遇到的问题越来越多，从功能需求，再到安全、效率、可读性等等，不得不提出一系列的解决方案去完善，最终变得很 ”臃肿“ 罢了。但是你应该明白，这就是一个为应用程序通信所提出来的一个基础通信协议。</p>
<h2 id="http方法有什么实际区别">HTTP方法有什么“实际区别”</h2>
<p>你可能听说过类似 “GET 和 POST 有什么区别” 这种问题，其实说到底从底层上来说，它们之间 <strong>没有任何区别，仅仅是约定、规范。</strong> 也就是说 <strong>按照约定</strong>，GET 方法的请求 <strong>不应该</strong> 携带请求体，并且在以前 <a href="https://www.postman.com/">Postman</a> 这类客户端模拟软件也是不允许构造这类请求的，但是后来也是支持了。</p>
<p>但是，如果你强行带了请求体，是没有任何问题的。你甚至可以把 GET 方法携带上请求体用来登录，使用 POST 请求用来获取 HTML 等静态资源，用 DELETE 方法来为数据库增加一条记录，只要你后端程序员老哥不把你捶死（手动狗头） 🤣🤣🤣</p>
<h2 id="各个版本之间的发展史">各个版本之间的发展史</h2>
<p>HTTP 比较重要的几个发展时间节点是 0.9、1.0、1.1、2.0 和 3.0，每一次的版本变迁都是为了解决前一个版本的性能不足或者功能不完善，我不推荐死记硬背，即使它被称为计算机八股文。</p>
<h3 id="http-09和11">http 0.9和1.1</h3>
<p>在 HTTP 0.9 的时候只有 GET 方法，1.0 补充了 POST，DEL 方法完善语义，还添加了几个首部，这个阶段的 HTTP 主要就是完善功能。</p>
<p>1.0 和 1.1 的最大区别就是长短连接了。在 HTTP 1.1 将长连接设置为了默认，也就是：</p>
<pre><code>Connection: keep-alive
</code></pre><p>在这之前这个字段的默认是 <code>close</code>，长连接的好处是显而易见的，由于 HTTP 是基于 tcp，如果总共传输三个文件，1.0 的时候需要建立和断开三次连接，1.1 的时候就只需要一次了。但是现在的问题还很明显，客户端想拿这三个文件，还是要三次请求，显然不合理。而且如果你打开开发者工具查看过 HTTP 的报文不难发现，即使你就需要几十个字节的 json 返回数据，服务端也要给你回那么长的 HTTP 报文，冗余信息的大小都超过了你的需要信息大小，这显然也不河里。所以这些问题就在 HTTP 2.0 版本里解决了。</p>
<h3 id="http-2">http 2</h3>
<p>HTTP 2.0 主要有这些特色：</p>
<ul>
<li>协议协商机制，可以选择使用 HTTP/1.1 还是 HTTP/2 或者其他。</li>
<li>高度向下兼容，原来 HTTP/1.1 的方法，状态码，URI和首部都不用改变。</li>
<li>首部压缩，通过双方都保存一份静态和动态表，通过发送双方都知道的 Index 来表明使用的是哪个首部字段。</li>
<li>服务端推送，解决只能客户端请求，无法服务端主动返回的问题。</li>
<li>二进制分帧，请求的流水线形式等等。</li>
</ul>
<h4 id="多路复用">多路复用</h4>
<p>如果你想请求 100 个文件，在之前你可能想要建立 100 个 TCP 连接同时请求，但是实际上浏览器会限制数量为 2~6 个，总之还是需要至少 2 个 TCP 连接。但是 HTTP/2 可以复用一个连接，这就减少了建立连接所需的时间。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/multiplexing.png" alt="multiplexing"></p>
<h4 id="首部压缩">首部压缩</h4>
<h3 id="在线体验">在线体验</h3>
<h4 id="demo1">demo1</h4>
<p>看到这里，你应该对 HTTP 2 的优势有了一个理性的认知了，你可以点一下这个 <a href="https://http2.akamai.com/demo">在线链接</a> 来<strong>直观地感受</strong>它们的速度差异。</p>
<h4 id="demo2">demo2</h4>
<h2 id="小结">小结</h2>
]]></content>
		</item>
		
		<item>
			<title>一些常见Go语言及面试问题的整理</title>
			<link>https://www.kcode.icu/posts/interview/somequestions/</link>
			<pubDate>Fri, 15 Jan 2021 21:10:55 +0000</pubDate>
			
			<guid>https://www.kcode.icu/posts/interview/somequestions/</guid>
			<description>这篇博客记录一些关于面试常见的 Go 语言方面的问题，希望能帮到大家，等待更新中。
Go make和new的区别，使用和底层？ Go内存管理 goroutine 什么时候会阻塞？ goroutine有几种状态？ m操作g的时候有自旋与非自旋状态？
线程有哪些状态 注册中心挂了怎么办？ N节点，raft一致性？
反射底层原理？ 通过反射执行函数，拿结构体tag？ 锁机制？饥饿模式正常模式？锁底层原理？ channel使用，坑，底层原理？ </description>
			<content type="html"><![CDATA[<p>这篇博客记录一些关于面试常见的 Go 语言方面的问题，希望能帮到大家，等待更新中。</p>
<h2 id="go-make和new的区别使用和底层">Go make和new的区别，使用和底层？</h2>
<h2 id="go内存管理">Go内存管理</h2>
<h2 id="goroutine-什么时候会阻塞">goroutine 什么时候会阻塞？</h2>
<h2 id="goroutine有几种状态">goroutine有几种状态？</h2>
<p>m操作g的时候有自旋与非自旋状态？</p>
<h2 id="线程有哪些状态">线程有哪些状态</h2>
<h2 id="注册中心挂了怎么办">注册中心挂了怎么办？</h2>
<p>N节点，raft一致性？</p>
<h2 id="反射底层原理">反射底层原理？</h2>
<h2 id="通过反射执行函数拿结构体tag">通过反射执行函数，拿结构体tag？</h2>
<h2 id="锁机制饥饿模式正常模式锁底层原理">锁机制？饥饿模式正常模式？锁底层原理？</h2>
<h2 id="channel使用坑底层原理">channel使用，坑，底层原理？</h2>
]]></content>
		</item>
		
		<item>
			<title>几经周折的博客变迁史</title>
			<link>https://www.kcode.icu/posts/chore/blog_journey/</link>
			<pubDate>Wed, 06 Jan 2021 21:13:13 +0000</pubDate>
			
			<guid>https://www.kcode.icu/posts/chore/blog_journey/</guid>
			<description>仔细想起来我的博客旅程也有好多年了，兜兜转转地走了不少弯路，也确实在这个过程中学到了很多东西，大致有这些时间节点：
 尝试购买了国内域名和学生机服务器，看到自己写的内容能在公网上让全世界的人看到就高兴了好久，内容很随意，自己管理。 使用 hexo 框架系统化内容，并部署到 GitHub Page 上交给 GitHub 管理。 发现了国内访问速度更快的 Gitee Page。 再次购买域名，使用 CDN 加速国外空间，未果（下文说）&amp;hellip;&amp;hellip;  前前后后也折腾了好几年，技术上的提升我倒觉得不太大，因为折腾地挺多但是都是应用层面上的，对我来说更多的是动手能力的提高，有好多东西不经过自己亲手尝试是根本理解不了的，我前面很多东西就是别人远程或者一步一步告诉我让我去点这个点那个就可以了，但是回过头来问你，你根本不知道发生了什么，甚至隔天就忘，这是典型的不理解、死记硬背式学习方法。
当时配置那个 A 记录，CNAME 记录啥的根本不知道是什么东西，也不知道 DNS 是什么，就是配，成功了就行，不成功就猜，一个个试呗。现在想想，真的是走了不少弯路，如果能系统地学一下多好。不过这些问题也都在我后来的实践以及学习过程中逐一解决了，现在遇到问题也不用像没头苍蝇一样乱撞了，这种感觉很不错 :)
这件事也让我大致理解了一句老话，大致是这么说的：真正厉害的技术人员不是说他写程序一定要多么多么厉害，而是他有非常强悍的问题定位能力（trouble shooting），能解决别人解决不了的问题，而这一切都源自于无数经验的积累以及深度的思考。
下面说我的最后一次迁移：)
 之所以有两个部分是因为买了域名后才发现必须要国内域名并且备案，才能加速国内。我买的是国外域名所以没办法，最后就用 GitHub Page + 自定义域名了。
 GitHub Page+自定义域名 这种方案比较简单（因为GitHub 都帮我们做了），这也是我现在的方式，只不过我的域名是国外的，所以没办法使用 CDN 加速。
你首先需要创建一个名为 &amp;lt;YourGitHubName&amp;gt;.github.io 的仓库，比如 sh1luo.github.io，然后购买一个域名（国内国外都行，国内要备案），因为我们是要使用 GitHub 的自定义域名，所以需要使用 CNAME 记录，在域名服务器处添加两条CNAME 记录 ，就像这样
我是国外的域名，不能使用国内 CDN 加速，正好 CloudFlare 提供免费全球 CDN，虽然效果一般，但是它提供的免费功能也是非常的多，包括各种流量统计分析，也是很良心了。想使用 CloudFlare 当 DNS 服务器做法也非常简单。注册一个账号填上域名信息，然后会提供给我们两个 DNS 服务器域名，我们把原域名服务器商的 NameServers 改成新解析服务器提供的就好了。
当然，如果你本来就是国内域名，就不用这么麻烦了，直接添加两条 CNAME 记录，然后在 GitHub Pages 仓库的发布分支放一个 CNAME 文件，文件内容就是你的 CNAME 地址就可以了，它会自动帮你设置为这个域名并搞定一切的:)</description>
			<content type="html"><![CDATA[<p>仔细想起来我的博客旅程也有好多年了，兜兜转转地走了不少弯路，也确实在这个过程中学到了很多东西，大致有这些时间节点：</p>
<ul>
<li>尝试购买了国内域名和学生机服务器，看到自己写的内容能在公网上让全世界的人看到就高兴了好久，内容很随意，自己管理。</li>
<li>使用 hexo 框架系统化内容，并部署到 GitHub Page 上交给 GitHub 管理。</li>
<li>发现了国内访问速度更快的 Gitee Page。</li>
<li>再次购买域名，使用 CDN 加速国外空间，未果（下文说）&hellip;&hellip;</li>
</ul>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/image-20210118174633253.png" alt="现在的博客"></p>
<p>前前后后也折腾了好几年，技术上的提升我倒觉得不太大，因为折腾地挺多但是都是应用层面上的，对我来说更多的是动手能力的提高，有好多东西不经过自己亲手尝试是根本理解不了的，我前面很多东西就是别人远程或者一步一步告诉我让我去点这个点那个就可以了，但是回过头来问你，你根本不知道发生了什么，甚至隔天就忘，这是典型的不理解、死记硬背式学习方法。</p>
<p>当时配置那个 A 记录，CNAME 记录啥的根本不知道是什么东西，也不知道 DNS 是什么，就是配，成功了就行，不成功就猜，一个个试呗。现在想想，真的是走了不少弯路，如果能系统地学一下多好。不过这些问题也都在我后来的实践以及学习过程中逐一解决了，现在遇到问题也不用像没头苍蝇一样乱撞了，这种感觉很不错 :)</p>
<p>这件事也让我大致理解了一句老话，大致是这么说的：真正厉害的技术人员不是说他写程序一定要多么多么厉害，而是他有非常强悍的问题定位能力（trouble shooting），能解决别人解决不了的问题，而这一切都源自于无数经验的积累以及深度的思考。</p>
<p>下面说我的最后一次迁移：)</p>
<blockquote>
<p>之所以有两个部分是因为买了域名后才发现必须要国内域名并且备案，才能加速国内。我买的是国外域名所以没办法，最后就用 GitHub Page + 自定义域名了。</p>
</blockquote>
<h2 id="github-page自定义域名">GitHub Page+自定义域名</h2>
<p>这种方案比较简单（因为GitHub 都帮我们做了），这也是我现在的方式，只不过我的域名是国外的，所以没办法使用 CDN 加速。</p>
<p>你首先需要创建一个名为 <code>&lt;YourGitHubName&gt;.github.io</code> 的仓库，比如 <code>sh1luo.github.io</code>，然后购买一个域名（国内国外都行，国内要备案），因为我们是要使用 GitHub 的自定义域名，所以需要使用 <a href="https://baike.baidu.com/item/CNAME/9845877?fr=aladdin">CNAME</a> 记录，在域名服务器处添加两条CNAME 记录 ，就像这样</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/image-20210126230446099.png" alt="DNS记录"></p>
<p>我是国外的域名，不能使用国内 CDN 加速，正好 CloudFlare 提供免费全球 CDN，虽然效果一般，但是它提供的免费功能也是非常的多，包括各种流量统计分析，也是很良心了。想使用 CloudFlare 当 DNS 服务器做法也非常简单。注册一个账号填上域名信息，然后会提供给我们两个 DNS 服务器域名，我们把原域名服务器商的 NameServers 改成新解析服务器提供的就好了。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/image-20210126231932450.png" alt=""></p>
<p>当然，如果你本来就是国内域名，就不用这么麻烦了，直接添加两条 CNAME 记录，然后在 GitHub Pages 仓库的发布分支放一个 CNAME 文件，文件内容就是你的 CNAME 地址就可以了，它会自动帮你设置为这个域名并搞定一切的:)</p>
<p>最终应该是这样：</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/image-20210126232019604.png" alt=""></p>
<h2 id="cdn加速">CDN加速</h2>
<p>如果你是国内的域名但是是国外的空间，就可以使用 CDN 加速了，加速区域选国内。这里需要注意源站地址由于是 GitHub Pages ，而 GitHub Pages 有 4 个 IP。都写上一行一个，回源 HOST 写你自己地址就可以了。这个回源 HOST 实际上就是 HTTP 头里的 host 字段，如果同一台机器上有多个服务的话，用来标识是哪一个服务，比较常见就是一个 IP 地址上配置了多个域名，就是通过这种给 host 首部字段的方式区分的不同 Web 站点。</p>
<p>配置完源站信息后，会生成一个 CDN 域名，比如我的是 <code>kcode.icu.cdn.dnsv1.com</code> ，然后再添加一条 CNAME 记录指向这个域名就搞定。这样配置过，你的网站经过缓存后国内访问速度能达到非常恐怖的速度，可以试着 ping 一下哦。</p>
<p>不过我这里是尝试了一下，发现国内都是不支持加速国外域名，所以放弃了。</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/image-20210118184423991.png" alt=""></p>
<h2 id="actions自动化构建">Actions自动化构建</h2>
<h2 id="说在最后">说在最后</h2>
<p>这里说几点我个人看法。</p>
<ul>
<li>博客要注重内容，我看好多人把界面弄的 <strong>过于花哨</strong> 不注重内在，我觉得如果你内容很丰富的情况下可以适当美化，但是弄个 BGM 或者动态换图什么的还是不要了。</li>
<li>多踩坑不一定是坏事，在大学这个试错成本很低的环境里就要多尝试，在踩坑的过程中把基础打牢，锻炼问题定位能力，多思考，多总结，日积月累肯定有所提升。</li>
<li>写博客给别人看的同时要多去看别人的成果，尤其是大佬们的，进步很快。</li>
<li></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>记人生中前几次面试及思考</title>
			<link>https://www.kcode.icu/posts/interview/2020-12-interview/</link>
			<pubDate>Sun, 03 Jan 2021 21:18:13 +0000</pubDate>
			
			<guid>https://www.kcode.icu/posts/interview/2020-12-interview/</guid>
			<description>写作背景 由于早早有了就业的想法，于是我在大三上学期快要结束的时候便早早地”物色“各大公司的实习了，也是希望能在就业前增加段实习经历，丰富一下经验。这也是人生中我的第一次面试，感触颇多。特别记录下来自己的总结以及对于假期自己的学习规划。
面试总结 这次我面试的总共有三家公司，跟谁学、字节跳动和腾讯，对我印象最深也是帮助最大的就是”字节跳动“。关于面试的准备大致有三块，简历、技术口述和手撕代码，下面分开说。
简历 这里使用的简历风格是参考了 @帅地玩编程 和 @码农桃花源 两位大佬，一个是本科腾讯大学时期年入几十万的，第二个是 Go 圈的全成大佬，推荐大家关注。
总体是简约并且色调一致，简历也是需要一点点迭代的，不断完善用词，前面挂了也是没有办法的事情。这里需要确保这么几点：
 不要造假，实事求是 。如果你写熟悉甚至精通，你躲过了 HR，但是人家面试官上来问了一个很简单的问题你答不上来，人家可能没兴趣继续问了。。在面试官心里你的这项技术等于没写，并且有了吹牛的成分，众所周知，搞技术的都不喜欢这种人。 拿出有说服力的证据。 举个简单的例子，你在个人相关那栏里写英语能力强，学习能力不错，热爱并常学习新技术，人家让你现场看个英文技术文，或者跟你聊两句看法，你蒙蔽了，尴尬不。问你平时咋学习的，你磕磕巴巴说不出个所以然，或者一点逻辑没有，东一头看书，西一头看视频，再来一手看野生技术文章，你说尴尬不。 注意行业基础。 我拿技术来说，搞技术的，你说你写了个热爱技术，结果写个 GitHub ，都能拼错，写成 Github 等等，写个 CSDN 写成 Csdn ，虽说这不是什么大事，但是这些书面东西，我们搞技术的不能犯错的，这给人的印象就是你很不专业，或者说你接触的很少以至于记不清楚。假如说你说热爱开源，整天 GitHub 排行榜逛个遍，你告诉我你不知道 GitHub 怎么拼，不合适吧？我曾经见过一个人说他懂这懂那，结果拿来简历一看，关于技术的名字错了好几个，还说自己热爱这些。  技术口述 这部分是面试重头戏，除去手撕代码部分其余就是这个了（还可能有项目环节），对于这部分我感触最多。
感触最大的就是一定要有自己的理解，并有深度。什么叫有自己的理解，就是如果换个方式问你，或者从另一个问题引申过来你能不能想到。有经验的面试官很喜欢这样问，如果你对知识没有形成体系，很容易造成一问就脑子一片空白的情况。
有深度指的是要能从使用到原理再到理解讲出一系列成体系的知识点，不是仅仅说一点应用层面的东西。我觉得这点我们平时很容易忽视，常常说个 10 秒就没了，谈不上熟悉。
手撕 这个环节部分大厂面试其实做的不错的，如果你上来没思路没见过，他会引导你让你一步一步去解决，看你思维和反应能力，要平时多思考，不能无脑刷，没啥说的。
假期规划 早些面试还是有好处的，确实能认识到自己的不足，我总结有这些点：
 自我介绍说重点，这会作为后续提问参考。 项目要有难点，解决方法，思考。 知识理解要有深度。  每一条都是实战出来的教训。。你可以比对自己成长，希望对你有所帮助。</description>
			<content type="html"><![CDATA[<h2 id="写作背景">写作背景</h2>
<p>由于早早有了就业的想法，于是我在大三上学期快要结束的时候便早早地”物色“各大公司的实习了，也是希望能在就业前增加段实习经历，丰富一下经验。这也是人生中我的第一次面试，感触颇多。特别记录下来自己的总结以及对于假期自己的学习规划。</p>
<h2 id="面试总结">面试总结</h2>
<p>这次我面试的总共有三家公司，跟谁学、字节跳动和腾讯，对我印象最深也是帮助最大的就是”字节跳动“。关于面试的准备大致有三块，简历、技术口述和手撕代码，下面分开说。</p>
<h3 id="简历">简历</h3>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/image-20210103221551405.png" alt=""></p>
<p>这里使用的简历风格是参考了 @帅地玩编程 和 @码农桃花源 两位大佬，一个是本科腾讯大学时期年入几十万的，第二个是 Go 圈的全成大佬，推荐大家关注。</p>
<p>总体是简约并且色调一致，简历也是需要一点点迭代的，不断完善用词，前面挂了也是没有办法的事情。这里需要确保这么几点：</p>
<ul>
<li><strong>不要造假，实事求是</strong> 。如果你写熟悉甚至精通，你躲过了 HR，但是人家面试官上来问了一个很简单的问题你答不上来，人家可能没兴趣继续问了。。在面试官心里你的这项技术等于没写，并且有了吹牛的成分，众所周知，搞技术的都不喜欢这种人。</li>
<li><strong>拿出有说服力的证据。</strong> 举个简单的例子，你在个人相关那栏里写英语能力强，学习能力不错，热爱并常学习新技术，人家让你现场看个英文技术文，或者跟你聊两句看法，你蒙蔽了，尴尬不。问你平时咋学习的，你磕磕巴巴说不出个所以然，或者一点逻辑没有，东一头看书，西一头看视频，再来一手看野生技术文章，你说尴尬不。</li>
<li><strong>注意行业基础。</strong> 我拿技术来说，搞技术的，你说你写了个热爱技术，结果写个 <code>GitHub</code> ，都能拼错，写成 <code>Github</code> 等等，写个 <code>CSDN</code> 写成 <code>Csdn</code> ，虽说这不是什么大事，但是这些书面东西，我们搞技术的不能犯错的，这给人的印象就是你很不专业，或者说你<strong>接触的很少以至于记不清楚</strong>。假如说你说热爱开源，整天 <code>GitHub</code> 排行榜逛个遍，你告诉我你不知道 <code>GitHub</code> 怎么拼，不合适吧？我曾经见过一个人说他懂这懂那，结果拿来简历一看，关于技术的名字错了好几个，还说自己热爱这些。</li>
</ul>
<h3 id="技术口述">技术口述</h3>
<p>这部分是面试重头戏，除去手撕代码部分其余就是这个了（还可能有项目环节），对于这部分我感触最多。</p>
<p>感触最大的就是一定要<strong>有自己的理解</strong>，并有深度。什么叫有自己的理解，就是如果换个方式问你，或者从另一个问题引申过来你能不能想到。有经验的面试官很喜欢这样问，如果你对知识没有形成体系，很容易造成一问就脑子一片空白的情况。</p>
<p>有深度指的是要能从使用到原理再到理解讲出一系列成体系的知识点，不是仅仅说一点应用层面的东西。我觉得这点我们平时很容易忽视，常常说个 10 秒就没了，谈不上熟悉。</p>
<h3 id="手撕">手撕</h3>
<p>这个环节部分大厂面试其实做的不错的，如果你上来没思路没见过，他会引导你让你一步一步去解决，看你思维和反应能力，要平时多思考，不能无脑刷，没啥说的。</p>
<h2 id="假期规划">假期规划</h2>
<p>早些面试还是有好处的，确实能认识到自己的不足，我总结有这些点：</p>
<ul>
<li>自我介绍说重点，这会作为后续提问参考。</li>
<li>项目要有难点，解决方法，思考。</li>
<li><strong>知识理解要有深度</strong>。</li>
</ul>
<p>每一条都是实战出来的教训。。你可以比对自己成长，希望对你有所帮助。</p>
]]></content>
		</item>
		
		<item>
			<title>手写一个RPCg（上）</title>
			<link>https://www.kcode.icu/posts/rpc/rpcg/</link>
			<pubDate>Sat, 28 Nov 2020 15:45:13 +0000</pubDate>
			
			<guid>https://www.kcode.icu/posts/rpc/rpcg/</guid>
			<description>须知 可能看到这里的一部分人还不知道什么是 RPC，也不知道为什么要用 RPC，内心：HTTP不香吗？那么你需要首先看一下这篇文章：
 你觉得HTTP哪都好用是因为你不知道RPC
 已经实现的 这篇文章我会带你手写一个简易版本的 RPC 框架，这个框架会支持如下这些功能：
 多种网络传输方式 服务端自动注册可导出服务 可以心跳保活的注册中心 服务注册与服务发现 多种序列化方式 超时控制 一些负载均衡策略，一致性哈希、平滑带权轮询等  未来需要做的   自定义的代码生成插件
  一种压缩方式
  基于服务器时延的负载均衡策略？
  心里有数 ”切忌重复造轮子“这句话你应该听过，不过这个”框架“的目的是带领我们大致了解 RPC 框架的工作过程，目标并不是工业级应用，我想你也一定清楚用框架和自己写框架对框架的理解程度有什么区别。也不必把 RPC 想成多么”高端“的技术，RPC 也只是一个调用，微服务的一个组件，从小的地方出发更容易让人接受罢了。好了，话不多说，让我们正式开始。
俯瞰RPCg 这个图向我们展示了最基本的 RPC 调用关系：服务端将自己的服务注册到注册中心，客户端从注册中心获取所有服务端的所有信息，在拿到这些信息之后带着自己的请求去访问某个服务端的服务。你可能会问为什么要多个”第三者“注册中心出来呢，我直接就只有客户端和服务端多方便，那你需要思考以下问题：
 直接通信是不是需要将通信的地址等服务端信息硬编码到客户端的代码中？如果服务端节点数改变了怎么办，难道手动删改代码？ 客户端怎么知道服务端可不可用？难道需要服务端开个服务专门去处理这类信息吗？这属于服务端的业务吗？ &amp;hellip;&amp;hellip;  我想你应该大致能明白为什么需要这个注册中心了，就是屏蔽对方对己方的感知，通过一个第三方中介来提供/提出自己的服务/需求，这就够了，你可以类比 房产中介，婚介所等等机构，当然，注册中心还有很多功能，我们这里为了学习，就只提供这部分功能了，更多的需要留给你去探索 :)
我们再想想，我们现在有了三个主体，之前有不同的需求，怎么提供通信。业界有非常多的解决方法，比如 gRPC 的 HTTP/2.0，它的优势也是显而易见的：多路复用，pipelining 的通信方式，效率大幅提高，不必在等待对方的回复；首部压缩，这里我需要说明一下，RPC 调用大部分是服务端内部的互相调用，比如公司机房里 50 台机器之间相互调用，需要保证传输的效率，也就是说传送的数据要尽可能地小，这才有了 Protocol Buffers 的数据格式，所以经过压缩的首部数据量更小，效率更高。还有 tcp 连接，优势是简单等等。
等待更新&amp;hellip;&amp;hellip;.</description>
			<content type="html"><![CDATA[<h1 id="须知">须知</h1>
<p>可能看到这里的一部分人还不知道什么是 RPC，也不知道为什么要用 RPC，内心：HTTP不香吗？那么你需要首先看一下这篇文章：</p>
<blockquote>
<p><a href="">你觉得HTTP哪都好用是因为你不知道RPC</a></p>
</blockquote>
<h2 id="已经实现的">已经实现的</h2>
<p>这篇文章我会带你手写一个简易版本的 RPC 框架，这个框架会支持如下这些功能：</p>
<ul>
<li>多种网络传输方式</li>
<li>服务端自动注册可导出服务</li>
<li>可以心跳保活的注册中心</li>
<li>服务注册与服务发现</li>
<li>多种序列化方式</li>
<li>超时控制</li>
<li>一些负载均衡策略，一致性哈希、平滑带权轮询等</li>
</ul>
<h2 id="未来需要做的">未来需要做的</h2>
<ul>
<li>
<p>自定义的代码生成插件</p>
</li>
<li>
<p>一种压缩方式</p>
</li>
<li>
<p>基于服务器时延的负载均衡策略？</p>
</li>
</ul>
<h2 id="心里有数">心里有数</h2>
<p>”切忌重复造轮子“这句话你应该听过，不过这个”框架“的目的是带领我们大致了解 RPC 框架的工作过程，目标并不是工业级应用，我想你也一定清楚用框架和自己写框架对框架的理解程度有什么区别。也不必把 RPC 想成多么”高端“的技术，RPC 也只是一个调用，微服务的一个组件，从小的地方出发更容易让人接受罢了。好了，话不多说，让我们正式开始。</p>
<h1 id="俯瞰rpcg">俯瞰RPCg</h1>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/2C28140D4115AF68D708DAB4515B012C.jpg" alt="img"></p>
<p>这个图向我们展示了最基本的 RPC 调用关系：服务端将自己的服务注册到注册中心，客户端从注册中心获取所有服务端的所有信息，在拿到这些信息之后带着自己的请求去访问某个服务端的服务。你可能会问为什么要多个”第三者“注册中心出来呢，我直接就只有客户端和服务端多方便，那你需要思考以下问题：</p>
<ul>
<li>直接通信是不是需要将通信的地址等服务端信息硬编码到客户端的代码中？如果服务端节点数改变了怎么办，难道手动删改代码？</li>
<li>客户端怎么知道服务端可不可用？难道需要服务端开个服务专门去处理这类信息吗？这属于服务端的业务吗？</li>
<li>&hellip;&hellip;</li>
</ul>
<p>我想你应该大致能明白为什么需要这个注册中心了，就是屏蔽对方对己方的感知，通过一个第三方中介来提供/提出自己的服务/需求，这就够了，你可以类比 房产中介，婚介所等等机构，当然，注册中心还有很多功能，我们这里为了学习，就只提供这部分功能了，更多的需要留给你去探索 :)</p>
<p>我们再想想，我们现在有了三个主体，之前有不同的需求，怎么提供通信。业界有非常多的解决方法，比如 gRPC 的 HTTP/2.0，它的优势也是显而易见的：多路复用，pipelining 的通信方式，效率大幅提高，不必在等待对方的回复；首部压缩，这里我需要说明一下，RPC 调用大部分是服务端内部的互相调用，比如公司机房里 50 台机器之间相互调用，需要保证传输的效率，也就是说传送的数据要尽可能地小，这才有了 Protocol Buffers 的数据格式，所以经过压缩的首部数据量更小，效率更高。还有 tcp 连接，优势是简单等等。</p>
<p>等待更新&hellip;&hellip;.</p>
]]></content>
		</item>
		
		<item>
			<title>你觉得HTTP最香是因为你还不知道RPC</title>
			<link>https://www.kcode.icu/posts/rpc/rpcvshttp/</link>
			<pubDate>Tue, 10 Nov 2020 21:30:13 +0000</pubDate>
			
			<guid>https://www.kcode.icu/posts/rpc/rpcvshttp/</guid>
			<description>我在动手写 RPCg 这个”框架“之前看了大量的文章阐述 RPC 与 HTTP，这篇文章是比较不错的一篇，我翻译过来和你分享一下 :)
REST vs. RPC你要使用API去解决什么问题？ 有一则关于这个农民的笑话，他被问到”为什么他要尽量避免耕种出‘童话环’的形状“，他回答道，”因为如果我不那么做，我就会变成傻子“。（第一段的引用故事可暂时不关注）。
许多人关于他们自己构建的 APIs 会说同样的话，事实上，去思考一下你要用你的 APIs 去解决什么问题这非常重要，因为你所创建的 API 的风格和你所使用的技术都依赖于你上面的回答。
根据调用 自从 FORTRAN Ⅱ 在1958 年提出调用（也叫函数）这个概念，函数（调用）就一直是组织计算机代码的主要结构。所有现在主流被用来构建和使用 API 的编程语言例如 Java,Javascript, Python, Golang, C/C++ 和 PHP 都使用调用（也就是函数）来作为他们的主要组织结构。因此这数十年来”函数调用“以远程过程调用（RPC） 的形式称为设计和实现分布式 API 的主要模型也就不足为奇了。
如果你要问大多数软件开发者为什么要定义和构建 API，他们可能会解释说他们有个应用，它需要实现多个分布式组件，并且这些组件之间可以互相调用，来使整个应用程序正常运行。他们也可能说需要实现由多个应用程序使用的服务 API。</description>
			<content type="html"><![CDATA[<p>我在动手写 RPCg 这个”框架“之前看了大量的文章阐述 RPC 与 HTTP，这篇文章是比较不错的一篇，我翻译过来和你分享一下 :)</p>
<h2 id="rest-vs-rpc你要使用api去解决什么问题">REST vs. RPC你要使用API去解决什么问题？</h2>
<p>有一则关于这个农民的笑话，他被问到”为什么他要尽量避免耕种出‘童话环’的形状“，他回答道，”因为如果我不那么做，我就会变成傻子“。（第一段的引用故事可暂时不关注）。</p>
<p>许多人关于他们自己构建的 APIs 会说同样的话，事实上，去思考一下你要用你的 APIs 去解决什么问题这非常重要，因为你所创建的 API 的风格和你所使用的技术都依赖于你上面的回答。</p>
<h2 id="根据调用">根据调用</h2>
<p>自从 FORTRAN Ⅱ 在1958 年提出调用（也叫函数）这个概念，函数（调用）就一直是组织计算机代码的主要结构。所有现在主流被用来构建和使用 API 的编程语言例如 Java,Javascript, Python, Golang, C/C++ 和 PHP 都使用调用（也就是函数）来作为他们的主要组织结构。因此这数十年来”函数调用“以远程过程调用（RPC） 的形式称为设计和实现分布式 API 的主要模型也就不足为奇了。</p>
<p>如果你要问大多数软件开发者为什么要定义和构建 API，他们可能会解释说他们有个应用，它需要实现多个分布式组件，并且这些组件之间可以互相调用，来使整个应用程序正常运行。他们也可能说需要实现由多个应用程序使用的服务 API。</p>
]]></content>
		</item>
		
		<item>
			<title>Linux du/df命令总结</title>
			<link>https://www.kcode.icu/posts/chore/linux_df_du/</link>
			<pubDate>Wed, 04 Nov 2020 18:15:13 +0000</pubDate>
			
			<guid>https://www.kcode.icu/posts/chore/linux_df_du/</guid>
			<description>linux 在我们日常学习中用的非常多，连接远程 linux 服务器，使用各种 linux 命令，或者物理机就是 linux 系统或者 MacOS。如果你想要学习进阶知识，linux 已经是必不可少的一个组件了。这篇博客记录一下 linux 下常被混淆的 du/df 命令。
df df 就是 “disk free” 的缩写，一般是用来快速浏览你的文件系统，会显示所有磁盘的大小，使用空间，剩余空间，使用百分比还有磁盘挂载到哪个分区上了。使用的时候一般要带上 -h 参数来增加可读性。这些数据都是从挂载点或者文件系统级别计算出来的，比较 “宏观”。
而且，-h 标记会使你的数据四舍五入更方便显示，比如它显示 3G 的大小，实际上可能是 2.9G 或者 3.1G，并不确定。
du du 就是 “disk usage” 的缩写，如果你需要计算某个特定目录大小的时候非常好用。一般搭配 -sh 参数让结果更易读，比如这样：
df VS. du 看了这两个命令大致用法后，它们在使用场景是什么呢，众所周知不结合使用场景的技术都是耍流氓。大致可以这样总结：df 命令提供一个关于你整个文件系统的概览，比如你多少空间正在使用等等，du 命令更倾向于计算某个目录的精确快照。
如果非要说哪个的结果更有用一点，我觉得是 du。举个例子，我在 /var 目录下安装一个第三方包时遇到了一个目录空间不足的错误，那么我就可以先跑一下 df 命令去看看这个目录的空间来确认一下这是不是真的。我如果看到 /var 有足够空间，那我会接着跑一下 du /var 去看看是它的哪个子目录因为空间不够报的错。这样我就可以一直通过 df  去缩小出错目录的范围，直到找到问题。
理解这些命令的区别能让我们串联使用这些工具，从而更快的定位并解决我们所面临的绝大多数的问题。</description>
			<content type="html"><![CDATA[<p>linux 在我们日常学习中用的非常多，连接远程 linux 服务器，使用各种 linux 命令，或者物理机就是 linux 系统或者 MacOS。如果你想要学习进阶知识，linux 已经是必不可少的一个组件了。这篇博客记录一下 linux 下常被混淆的 du/df 命令。</p>
<h2 id="df">df</h2>
<p>df 就是 “disk free” 的缩写，一般是用来快速浏览你的文件系统，会显示所有磁盘的大小，使用空间，剩余空间，使用百分比还有磁盘挂载到哪个分区上了。使用的时候一般要带上 <code>-h</code> 参数来增加可读性。这些数据都是从挂载点或者文件系统级别计算出来的，比较 “宏观”。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/sh.png" alt="df -h"></p>
<p>而且，<code>-h</code> 标记会使你的数据四舍五入更方便显示，比如它显示 3G 的大小，实际上可能是 2.9G 或者  3.1G，并不确定。</p>
<h2 id="du">du</h2>
<p>du 就是 “disk usage” 的缩写，如果你需要计算某个特定目录大小的时候非常好用。一般搭配 <code>-sh</code> 参数让结果更易读，比如这样：</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/du.png" alt="du"></p>
<h2 id="df-vs-du">df VS. du</h2>
<p>看了这两个命令大致用法后，它们在使用场景是什么呢，众所周知不结合使用场景的技术都是耍流氓。大致可以这样总结：<code>df</code> 命令提供一个关于你整个文件系统的概览，比如你多少空间正在使用等等，<code>du</code> 命令更倾向于计算某个目录的精确快照。</p>
<p>如果非要说哪个的结果更有用一点，我觉得是 <code>du</code>。举个例子，我在 <code>/var</code> 目录下安装一个第三方包时遇到了一个目录空间不足的错误，那么我就可以先跑一下 <code>df</code> 命令去看看这个目录的空间来确认一下这是不是真的。我如果看到 <code>/var</code> 有足够空间，那我会接着跑一下 <code>du /var</code> 去看看是它的哪个子目录因为空间不够报的错。这样我就可以一直通过 <code>df </code> 去缩小出错目录的范围，直到找到问题。</p>
<p>理解这些命令的区别能让我们串联使用这些工具，从而更快的定位并解决我们所面临的绝大多数的问题。</p>
]]></content>
		</item>
		
		<item>
			<title>一文搞懂ASCII、Unicode和UTF</title>
			<link>https://www.kcode.icu/posts/ascii-unicode-utf/</link>
			<pubDate>Fri, 18 Sep 2020 09:27:13 +0000</pubDate>
			
			<guid>https://www.kcode.icu/posts/ascii-unicode-utf/</guid>
			<description>起因 最初在学习 Go 语言的各种类型时发现内置字符类型有两种类型，一种是 byte（1 字节表示一个 ASCII 字符），还有一个就是 rune 类型，可能从其他语言转过来的开发者都会对 rune 觉得非常陌生，我自己也是仅仅停留在会用的阶段上，久而久之就会特别乱，所以写一篇博客介绍一下各种字符以及编码方便彼此学习，彻底解决这类问题。
什么是ASCII，为什么又要引入Unicode 都应该了解过 ASCII、Unicode、Unicode 码点、UTF-8等一系列名词。先说 ASCII（American Standard Code for Information Interchange: 美国信息交换标准代码），它是一种字符集，说白了就是一个字符和数字的一一对应关系，你想找这个字符怎么办，计算机又不认识字符？给出他的对应的数字就行了。最初只有美国等一些使用英文的国家使用，所以 128 个字符完全够用，它包含了标点符号、数字和字母等。但是随着世界上使用计算机的国家越来越多，这 128 个字符是完全不够用的。所以 Unicode 字符集 就出现了。Unicode 包含了世界上绝大多数的字符，给他们提供了一一对应关系，比如“知”字对应 30693，即 U+77e5（16 进制形式）。所以说白了 ASCII 和 Unicode 就是一种字符集，一种字符对应关系，Unicode 中每个字符被称为一个 Code Point（码点），而 Go 语言中的 rune 类型正是代表了这样一个单位，即一个 rune 代表了一个 unicode 字符。
那么大家肯定都听说过 UTF-8，UTF-16 吧，那问题来了， UTF 又是什么呢，UTF-8 和 UTF-16 到底又有什么关系呢？
UTF（Unicode Transformation Format） 从字面上你就应该能看出来，这就是一个 Unicode 转换格式。什么是转换格式，为什么需要转换格式？上文说了 Unicode 就是提供了字符间的一一对应关系，比如“知”对应了 30693，那计算机怎么表示这个数（计算机只认识二进制）？它要做到：
在很长的文本中准确获取到每个字符，不能找错 **Unicode 表示一个字符可以使用 1 - 4 个字节。**它的转换规则如下：</description>
			<content type="html"><![CDATA[<h2 id="起因">起因</h2>
<p>最初在学习 Go 语言的各种类型时发现内置字符类型有两种类型，一种是 byte（1 字节表示一个 ASCII 字符），还有一个就是 rune 类型，可能从其他语言转过来的开发者都会对 rune 觉得非常陌生，我自己也是仅仅停留在<strong>会用</strong>的阶段上，久而久之就会特别乱，所以写一篇博客介绍一下各种字符以及编码方便彼此学习，彻底解决这类问题。</p>
<h2 id="什么是ascii为什么又要引入unicode">什么是ASCII，为什么又要引入Unicode</h2>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/ascii.png" alt="image"></p>
<p>都应该了解过 ASCII、Unicode、Unicode 码点、UTF-8等一系列名词。先说 ASCII（American Standard Code for Information Interchange: 美国信息交换标准代码），它是一种<strong>字符集</strong>，说白了就是一个字符和数字的<strong>一一对应关系</strong>，你想找这个字符怎么办，计算机又不认识字符？给出他的对应的数字就行了。最初只有美国等一些使用英文的国家使用，所以 128 个字符完全够用，它包含了标点符号、数字和字母等。但是随着世界上使用计算机的国家越来越多，这 128 个字符是完全不够用的。所以 <strong>Unicode 字符集</strong> 就出现了。Unicode 包含了世界上绝大多数的字符，给他们提供了一一对应关系，比如“知”字对应 30693，即 U+77e5（16 进制形式）。所以说白了 ASCII 和 Unicode 就是<strong>一种字符集</strong>，<strong>一种字符对应关系</strong>，Unicode 中每个字符被称为一个 <strong>Code Point</strong>（码点），而 Go 语言中的 rune 类型正是代表了这样一个单位，即一个 rune 代表了一个 unicode 字符。</p>
<p>那么大家肯定都听说过 UTF-8，UTF-16 吧，那问题来了， UTF 又是什么呢，UTF-8 和 UTF-16 到底又有什么关系呢？</p>
<h2 id="utfunicode-transformation-format">UTF（Unicode Transformation Format）</h2>
<p>从字面上你就应该能看出来，这就是一个 Unicode 转换格式。什么是转换格式，为什么需要转换格式？上文说了 Unicode 就是提供了字符间的一一对应关系，比如“知”对应了 30693，那计算机怎么表示这个数（计算机只认识二进制）？它要做到：</p>
<pre><code>在很长的文本中准确获取到每个字符，不能找错
</code></pre><p>**Unicode 表示一个字符可以使用 1 - 4 个字节。**它的转换规则如下：</p>
<table>
<thead>
<tr>
<th>1 字节</th>
<th>0xxxxxxx</th>
</tr>
</thead>
<tbody>
<tr>
<td>2 字节</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>3 字节</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>4 字节</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody>
</table>
<p>解释：如果它表示一个字符只需要 1 个字节，那么表示的就是 ASCII 字符集，从0 -&gt; 127。如果需要 2 个及以上字节表示，那么<strong>第一个字节的前 n 位是 1 ，第 n+1 位是 0，后面每个字节的前两位均为 10（n 是所需字节数）。</strong></p>
<p>所以按照上述规则，“知”字的二进制为：</p>
<pre><code>30693（十进制） -&gt; U+77E5(十六进制) -&gt; 0111 0111 1110 0101（二进制）
</code></pre><p>所以对应的 UTF-8 编码为：<strong>1110</strong>0111 <strong>10</strong>011111 <strong>10</strong>100101，你只需要从低位到高位依次按规则填充即可。</p>
<p>看到这里，我想有思考的读者应该有疑问，为什么原本只需要两字节就能表示的字经过 UTF-8 转换后需要三个字节了，这不是白白地增加内存消耗吗？你可以回忆一下哈夫曼编码的构建结果：将长短不同的<strong>二进制位段</strong>直接放在一起却不会读错，是因为他们没有共同前缀。这里的原理类似，要解决地问题是 <strong>怎么确保长短不同的字符不会重合</strong>。由于有的字符只需要一个字节，而有的需要两个，三个，n 个。当他们堆放在一起时，怎么保证不会出现读少，读多？</p>
<p>解释这个问题，我举个例子，“你”字<strong>假设</strong>表示的十六进制是 A，“我”是 B，“你我”是 AA，“好”是 AB，那我将“你好”放一起时表示就是 AAB，它为什么不是“你你我”，或者“你我我”？</p>
<p>我相信如果你看懂了这个例子，应该就能明白为什么 UTF-8 被称为变长编码了。</p>
<p>这段的标题是 UTF，上面只说了 UTF-8，其实常用的还有 UTF-16，UTF-8 是将一个字节作为一个单位，随着所需字节数量的不同给他们不同的前缀，当计算机读到第一个字节时，通过判断前面连续 1 的个数就能判断未来多少位属于这个字符的范围,，从而解决了不会读错的问题。而 UTF-16 是<strong>将两个字节作为了一个单位</strong>。原理类似，有兴趣的读者可以自己再去探索，我相信你会有更多的发现 :)</p>
<h2 id="验证结果梳理思路">验证结果，梳理思路</h2>
<p>我们可以写一个简单的 Go 语言程序来验证这个结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
 <span class="nx">str</span> <span class="o">:=</span> <span class="s">&#34;hello,狗狼&#34;</span>
 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">str</span><span class="p">))</span>
 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">([]</span><span class="nb">rune</span><span class="p">(</span><span class="nx">str</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre></div><p>输出结果为：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="m">12</span>
<span class="m">8</span>

Process finished with <span class="nb">exit</span> code <span class="m">0</span>
</code></pre></div><p>这里需要说明的是，str 字符串的底层实现就是一个字节数组，根据上面所说的汉字占用 3 个字节，总字节长度为 6+3+3=12，而转换为 rune 类型后，所有字符都占用一个 Unicode <strong>Code Point</strong>（码点），所以占用了共 8 个字符，共 8 个码点。</p>
<p>综上所述，ASCII 和 Unicode 都是一种字符集，代表了字符与数字间的一一对应关系。而 UTF 是一种变长的字符编码规范。而 rune 是 Go 语言中的一个变量类型，一个 rune 代表了一个 Unicode 码点单位。以上。</p>
<p>因个人能力有限，有疏漏之处欢迎和我交流 :)</p>
]]></content>
		</item>
		
		<item>
			<title>OBS显示器捕获黑屏解决方案</title>
			<link>https://www.kcode.icu/posts/chore/obs/</link>
			<pubDate>Sun, 26 Apr 2020 11:34:13 +0000</pubDate>
			
			<guid>https://www.kcode.icu/posts/chore/obs/</guid>
			<description>问题起因 由于我最近重新安装了系统，在重新下载 OBS 后发现捕获不到桌面。我之前解决方法就是直接在显卡控制面板里将 OBS 设置为集显就行了。但是这次设置了也不行，有可能是我下载的显卡驱动版本不对。。于是就找到了这个终极解决方案，基本电脑上有这个功能的都能解决。
问题环境 操作系统：Win10 64位 专业版 - 1909
CPU 集成显卡型号：Inter(R) UHD Graphics 630
独立显卡型号：NVIDIA GeForce GTX 1050
OBS 版本：25.0.4(64 bit)
 注：配置和我不一样也有可能解决，不用纠结
 问题描述 在来源中添加显示器捕获后 ，是黑屏，无法捕获到显示器。
问题分析 目前网上能搜集到的解决方案大部分是以下几种：
 右键 OBS 属性 - 兼容性 - 兼容模式 - 以兼容模式运行这个程序（win7）设置 - 以管理员方式运行 桌面上右键打开 NVIDIA 控制面板，管理 3D 设置 - 程序设置，找到 OBS，设置为集成图形。  但是我都试了都解决不了，我就去搜了一下问题的原因，最终发现 OBS 只能捕捉到和自己跟自己使用相同显卡的应用，然后我右键打开任务管理器，发现笔记本桌面使用的是我的集显。所以就需要把 OBS 设置为应用集显。
解决方法 左下角开始按钮 - 设置 - 系统 - 显示 - 图形设置 - 经典应用里浏览添加 OBS ，点击选项，设置为节能，节能就是使用集显。然后你再打开 OBS&amp;hellip;&amp;hellip;</description>
			<content type="html"><![CDATA[<h2 id="问题起因">问题起因</h2>
<p>由于我最近重新安装了系统，在重新下载 OBS 后发现捕获不到桌面。我之前解决方法就是直接在<strong>显卡控制面板</strong>里将 OBS 设置为集显就行了。但是这次设置了也不行，有可能是我下载的显卡驱动版本不对。。于是就找到了这个终极解决方案，基本电脑上有这个功能的都能解决。</p>
<h2 id="问题环境">问题环境</h2>
<p>操作系统：Win10 64位 专业版 - 1909</p>
<p>CPU 集成显卡型号：Inter(R) UHD Graphics 630</p>
<p>独立显卡型号：NVIDIA GeForce GTX 1050</p>
<p>OBS 版本：25.0.4(64 bit)</p>
<blockquote>
<p>注：配置和我不一样也有可能解决，不用纠结</p>
</blockquote>
<h2 id="问题描述">问题描述</h2>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/obs-noscreen.png" alt=""></p>
<p>在来源中添加<strong>显示器捕获后</strong> ，是黑屏，<strong>无法捕获到显示器</strong>。</p>
<h2 id="问题分析">问题分析</h2>
<p>目前网上能搜集到的解决方案大部分是以下几种：</p>
<ul>
<li>右键 OBS 属性 - 兼容性 - 兼容模式 - 以兼容模式运行这个程序（win7）设置 -  以管理员方式运行</li>
<li>桌面上右键打开 NVIDIA 控制面板，管理 3D 设置 - 程序设置，找到 OBS，设置为集成图形。</li>
</ul>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/obs-gpu.png" alt="任务管理器最下面"></p>
<p>但是我都试了都解决不了，我就去搜了一下问题的原因，<strong>最终</strong>发现 OBS <strong>只能捕捉到和自己跟自己使用相同显卡的应用</strong>，然后我右键打开任务管理器，发现笔记本桌面使用的是我的集显。所以就需要把 OBS 设置为应用集显。</p>
<h2 id="解决方法">解决方法</h2>
<p><!-- raw HTML omitted --></p>
<p>左下角开始按钮 - 设置 - 系统 - 显示 - 图形设置 - 经典应用里浏览添加 OBS ，点击选项，设置为节能，节能就是使用集显。然后你再打开 OBS&hellip;&hellip;</p>
<p>这时候你就会发现你成功了。</p>
<p>其他的推流软件也一样，比如什么 B 站直播姬等同理。</p>
<p>以上。</p>
]]></content>
		</item>
		
		<item>
			<title>Go&#43;QML开发的跨平台桌面直播助手[下]</title>
			<link>https://www.kcode.icu/posts/b%E7%AB%99%E7%9B%B4%E6%92%AD%E5%8A%A9%E6%89%8B%E5%BC%80%E5%8F%91%E4%B8%8B/</link>
			<pubDate>Fri, 13 Mar 2020 13:22:23 +0000</pubDate>
			
			<guid>https://www.kcode.icu/posts/b%E7%AB%99%E7%9B%B4%E6%92%AD%E5%8A%A9%E6%89%8B%E5%BC%80%E5%8F%91%E4%B8%8B/</guid>
			<description>Go + QML 结合上节的分析，开发的思路的大致流程我画了个图，大概是这样：
 因为是需要面向用户的，又考虑到 Go 语言的特殊性（可以直接调用 C/C++ 代码，GUI 官方不支持），最后决定使用 Qml 来呈现前端，与 Go 语言利用插槽和信号进行通信。
 处理思路是创建一个协程池来处理不同类型的包数据。判断每个包内所有子包类型，将接收的未处理的字节数组直接送入对应协程池中的管道。因为代码也比较简单，就是简单的 WebSocket 通信。
// 客户端实例 type Client struct { RoomID uint32	// 房间 ID 	Online uint32	// 用来判断人气是否变动 	Conn *websocket.Conn	// 连接后的对象 	IsConnected bool } // 使用了&amp;#34;github.com/gorilla/websocket&amp;#34;这个包，也可以自己升级 tcp 到 websocket u := url.URL{Scheme: &amp;#34;wss&amp;#34;, Host: DanMuServer, Path: &amp;#34;/sub&amp;#34;,} conn, _, err := websocket.DefaultDialer.Dial(u.String(), nil) if err != nil { return nil, err } // 发送包函数 func SendPackage(conn *websocket.</description>
			<content type="html"><![CDATA[<h1 id="go--qml">Go + QML</h1>
<p>结合上节的分析，开发的思路的大致流程我画了个图，大概是这样：</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/go_qml_flowchart.png" alt="流程图"></p>
<blockquote>
<p>因为是需要面向用户的，又考虑到 Go 语言的特殊性（可以直接调用 C/C++ 代码，GUI 官方不支持），最后决定使用 Qml 来呈现前端，与 Go 语言利用插槽和信号进行通信。</p>
</blockquote>
<p>处理思路是创建一个协程池来处理不同类型的包数据。判断每个包内所有子包类型，将接收的未处理的字节数组直接送入对应协程池中的管道。因为代码也比较简单，就是简单的 WebSocket 通信。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 客户端实例
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Client</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">RoomID</span>      <span class="kt">uint32</span>				<span class="c1">// 房间 ID
</span><span class="c1"></span>	<span class="nx">Online</span>      <span class="kt">uint32</span>				<span class="c1">// 用来判断人气是否变动
</span><span class="c1"></span>	<span class="nx">Conn</span>        <span class="o">*</span><span class="nx">websocket</span><span class="p">.</span><span class="nx">Conn</span>		<span class="c1">// 连接后的对象
</span><span class="c1"></span>	<span class="nx">IsConnected</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 使用了&#34;github.com/gorilla/websocket&#34;这个包，也可以自己升级 tcp 到 websocket
</span><span class="c1"></span><span class="nx">u</span> <span class="o">:=</span> <span class="nx">url</span><span class="p">.</span><span class="nx">URL</span><span class="p">{</span><span class="nx">Scheme</span><span class="p">:</span> <span class="s">&#34;wss&#34;</span><span class="p">,</span> <span class="nx">Host</span><span class="p">:</span> <span class="nx">DanMuServer</span><span class="p">,</span> <span class="nx">Path</span><span class="p">:</span> <span class="s">&#34;/sub&#34;</span><span class="p">,}</span>
<span class="nx">conn</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">websocket</span><span class="p">.</span><span class="nx">DefaultDialer</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="nx">u</span><span class="p">.</span><span class="nf">String</span><span class="p">(),</span> <span class="kc">nil</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="c1">// 发送包函数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">SendPackage</span><span class="p">(</span><span class="nx">conn</span> <span class="o">*</span><span class="nx">websocket</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">packetlen</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">magic</span> <span class="kt">uint16</span><span class="p">,</span> <span class="nx">ver</span> <span class="kt">uint16</span><span class="p">,</span> <span class="nx">typeID</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">param</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">packetHead</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">packetlen</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">packetlen</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="o">+</span> <span class="mi">16</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">pdata</span> <span class="p">=</span> <span class="p">[]</span><span class="kd">interface</span><span class="p">{}{</span>
		<span class="nx">packetlen</span><span class="p">,</span>
		<span class="nx">magic</span><span class="p">,</span>
		<span class="nx">ver</span><span class="p">,</span>
		<span class="nx">typeID</span><span class="p">,</span>
		<span class="nx">param</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="c1">// 将包的头部信息以大端序，二进制形式写入字节数组
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pdata</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">binary</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">packetHead</span><span class="p">,</span> <span class="nx">binary</span><span class="p">.</span><span class="nx">BigEndian</span><span class="p">,</span> <span class="nx">v</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 将包内数据部分追加到数据包内
</span><span class="c1"></span>	<span class="nx">sendData</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">packetHead</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">(),</span> <span class="nx">data</span><span class="o">...</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">WriteMessage</span><span class="p">(</span><span class="nx">websocket</span><span class="p">.</span><span class="nx">BinaryMessage</span><span class="p">,</span> <span class="nx">sendData</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// fmt.Println(&#34;c.conn.Write err: &#34;, err)
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div><p>拼接 URL 是使用的官方提供的 url 包，发送包数据要注意的是发送的是二进制数据流，所以要用 binary.Write 以二进制，且在网络上传输是大端序方式写入字节数组。</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/up.png" alt="心跳包上行"></p>
<p>心跳包上行是通过发送两个空的对象，所以我把这个固定的数直接粘贴下来转为字节数组后，创建一个 go 协程，按照每 30 秒一次的时间间隔发送就好。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Client</span><span class="p">)</span> <span class="nf">HeartBeat</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">IsConnected</span> <span class="p">{</span>
			<span class="nx">obj</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;5b6f626a656374204f626a6563745d&#34;</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">util</span><span class="p">.</span><span class="nf">SendPackage</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">obj</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
            <span class="c1">// 每 30 秒发一次
</span><span class="c1"></span>			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">30</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>心跳包下行是还是一个固定的包首部，只携带了一个 4 字节大小的实体就是直播间人气值，所以我只需要每次和 c.Online 进行比较，及时修改人气数就可以了。</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/down.png" alt="心跳包下行"></p>
<p>最后一个问题就是<strong>对每个包的所有子包依次进行判断，防止信息量过大的时候有漏掉的情况</strong>，思路是读取完第一个包后，根据第一个包的大小找到第二个包的偏移位置继续读取，直到达到末尾，里面的<code>ByteArrToDecimal</code>是自己写的一个将读取到的十进制字节数组转换为十进制表示数的方法函数，也附带在下方了，如果有更好的实现可以告诉我，我也是自己脑洞大开临时写的&hellip;.有可能有更简单的实现。。。。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">inflated</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
	<span class="nx">l</span> <span class="o">:=</span> <span class="nx">util</span><span class="p">.</span><span class="nf">ByteArrToDecimal</span><span class="p">(</span><span class="nx">inflated</span><span class="p">[:</span><span class="mi">4</span><span class="p">])</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">inflated</span><span class="p">[</span><span class="mi">16</span><span class="p">:</span><span class="nx">l</span><span class="p">],</span> <span class="s">&#34;cmd&#34;</span><span class="p">).</span><span class="nf">ToString</span><span class="p">()</span>
	<span class="k">switch</span> <span class="nx">c</span> <span class="p">{</span>
		<span class="k">case</span> <span class="s">&#34;DANMU_MSG&#34;</span><span class="p">:</span>
			<span class="nx">p</span><span class="p">.</span><span class="nx">DanmuSrc</span> <span class="o">&lt;-</span> <span class="nb">string</span><span class="p">(</span><span class="nx">inflated</span><span class="p">[</span><span class="mi">16</span><span class="p">:</span><span class="nx">l</span><span class="p">])</span>
		<span class="k">case</span> <span class="s">&#34;SEND_GIFT&#34;</span><span class="p">:</span>
			<span class="nx">p</span><span class="p">.</span><span class="nx">GiftSrc</span> <span class="o">&lt;-</span> <span class="nb">string</span><span class="p">(</span><span class="nx">inflated</span><span class="p">[</span><span class="mi">16</span><span class="p">:</span><span class="nx">l</span><span class="p">])</span>
		<span class="k">case</span> <span class="s">&#34;WELCOME&#34;</span><span class="p">,</span> <span class="s">&#34;WELCOME_GUARD&#34;</span><span class="p">:</span>
			<span class="nx">p</span><span class="p">.</span><span class="nx">WelCome</span> <span class="o">&lt;-</span> <span class="nb">string</span><span class="p">(</span><span class="nx">inflated</span><span class="p">[</span><span class="mi">16</span><span class="p">:</span><span class="nx">l</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="nx">inflated</span> <span class="p">=</span> <span class="nx">inflated</span><span class="p">[</span><span class="nx">l</span><span class="p">:]</span>
<span class="p">}</span>

<span class="c1">// 返回十六进制字节数组表示数的十进制形式
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">ByteArrToDecimal</span><span class="p">(</span><span class="nx">src</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">sum</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">src</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>
    <span class="c1">// 将读取的十进制字节数组数据编码为字符串，再转换为字节数组，方便后续进行逐字节处理
</span><span class="c1"></span>	<span class="nx">b</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">hex</span><span class="p">.</span><span class="nf">EncodeToString</span><span class="p">(</span><span class="nx">src</span><span class="p">))</span>
	<span class="nx">l</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
    <span class="c1">// 从低位开始
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">base</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Pow</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">l</span><span class="o">-</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
		<span class="kd">var</span> <span class="nx">mul</span> <span class="kt">int</span>
		<span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">97</span> <span class="p">{</span>
			<span class="nx">mul</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">-</span> <span class="mi">87</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">mul</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">-</span> <span class="mi">48</span>
		<span class="p">}</span>

		<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">base</span> <span class="o">*</span> <span class="nx">mul</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div><p>其余的与 Qml 进行通信的第三方包用的是 qamel，也可以使用比较广泛，功能大而全的 therecipe/qt ，是因为这个库比较小巧，安装使用简单，所以采用了这个。通信部分非常简单，就是使用了信号和插槽，整个程序包括了弹幕礼物进场点歌功能一共 500+ 行，有些代码略冗余，还需要凝练。如果大家有任何想法都可以跟我交流，不限于博客写法，代码规范，开发思路等等，欢迎！</p>
<h2 id="总结">总结</h2>
<p>其实从有这个程序的想法到现在落地开发完成，也是走了不少的弯路的。一开始以为那些被压缩了的“乱码”是被加密的结果，自己又配置了 <code>sslkey.log</code>文件使用 Wireshark 解密，结果自然是白忙活一场。关键还是还是协议分析这块不够熟练，对网络理解不够。还有在连接弹幕服务器的时候尝试使用了 net 包下 net.Dial 进行通信，结果报错 <code>GetInfoW</code> 方法类找不到，当时只知道 ws 是基于 tcp，后来才知道单纯 tcp 根本无法与 ws 服务器连接，这一点说到底还是自己对连接过程理解不够。经过这个小项目，让自己对网络这一块的重要程度有了新的认识，决定要好好学习这些内容，还有 Go 语言的实操，协程池的使用，与 Qml 的通信。总体来说收获还是不小，以后还是要多上手练习。</p>
]]></content>
		</item>
		
		<item>
			<title>Go&#43;QML开发的跨平台桌面直播助手[上]</title>
			<link>https://www.kcode.icu/posts/b%E7%AB%99%E7%9B%B4%E6%92%AD%E5%8A%A9%E6%89%8B%E5%BC%80%E5%8F%91%E4%B8%8A/</link>
			<pubDate>Thu, 05 Mar 2020 15:45:13 +0000</pubDate>
			
			<guid>https://www.kcode.icu/posts/b%E7%AB%99%E7%9B%B4%E6%92%AD%E5%8A%A9%E6%89%8B%E5%BC%80%E5%8F%91%E4%B8%8A/</guid>
			<description>B站直播协议分析  上篇介绍协议分析，下篇介绍开发思路。
 项目缘由 假期在家，群里有几个朋友决定尝个新鲜开直播娱乐一下，后来发现B站官方提供的直播姬只有弹幕显示功能，并没有点歌等其他自定义功能，网上的项目也比较少，而且一些点歌机不维护了导致功能有缺陷，因此打算开发一个自定义的具有多功能的直播助手，初步包含弹幕礼物显示，点歌等功能。
开发的思路是分析传输二进制包，从中找出我们想要的数据，以我们想要的方式显示出来。
总体过程 随便打开一个直播间，按 F12，切换到 Network 的 WS 栏。可以看到它是首先连接弹幕服务器，并且通过观察发现这个地址并不是固定的（应该是负载均衡的结果）。
然后发送一个握手包，携带了 Roomid，访问者 id，客户端版本等信息，最后还有一个 key，后来观察发现是通过请求某个接口获取的这个 key 值（就是 token）。
重点就是分析协议包。不管是接收还是发送的二进制包都有一个固定大小 16 字节的首部。这个首部的组成我用一个表格来表示：
   偏移 长度 内容     0 4 包的大小   4 4 未知（目前和分析无关）   8 4 包类型   12 4 未知（目前和分析无关）    除了首部之外的就是携带的数据部分了。在这里需要注意的一点是，由于瞬时信息量可能会很大，会把若干个包压缩为一个包发送，这个包组成是《包首部-包主体-下一个包首部-下一个包主体-&amp;hellip;..等等》，而且因为包类型为 5 的数量最多，传输信息量会很大，所以是用 gzip 压缩了的，这里要注意。这里随手拿一个包举例：
...G............{&amp;#34;cmd&amp;#34;:&amp;#34;DANMU_MSG&amp;#34;,&amp;#34;info&amp;#34;:[[0,1,25,8322816,1584073975908,1584073720,0,&amp;#34;7905c3d4&amp;#34;,0,0,0],&amp;#34;(=・ω・=)&amp;#34;,[14006391,&amp;#34;桥本环零&amp;#34;,0,1,0,10000,1,&amp;#34;&amp;#34;],[17,&amp;#34;小糕兔&amp;#34;,&amp;#34;娜可糕糕&amp;#34;,294526,16752445,&amp;#34;&amp;#34;,0],[47,0,16746162,10074],[&amp;#34;title-179-1&amp;#34;,&amp;#34;title-179-1&amp;#34;],0,0,null,{&amp;#34;ts&amp;#34;:1584073975,&amp;#34;ct&amp;#34;:&amp;#34;B0A7DFE4&amp;#34;},0,0,null,null,0]}...h............{&amp;#34;cmd&amp;#34;:&amp;#34;DANMU_MSG&amp;#34;,&amp;#34;info&amp;#34;:[[0,1,25,16777215,1584073975938,1584073264,0,&amp;#34;21635747&amp;#34;,0,0,0],&amp;#34;包砸是我关注的up里唯一一个很可爱的&amp;#34;,[339865528,&amp;#34;兰博基尼鬼怪&amp;#34;,0,0,0,10000,1,&amp;#34;&amp;#34;],[3,&amp;#34;包崽铺&amp;#34;,&amp;#34;喝薄荷奶绿&amp;#34;,1506599,6406234,&amp;#34;&amp;#34;,0],[10,0,9868950,&amp;#34;\u003e50000&amp;#34;],[&amp;#34;&amp;#34;,&amp;#34;&amp;#34;],0,0,null,{&amp;#34;ts&amp;#34;:1584073975,&amp;#34;ct&amp;#34;:&amp;#34;657DC663&amp;#34;},0,0,null,null,0]} 可以看到这里就是瞬时有两条弹幕，变为了一个包。每个包都有自己的头部，可以自行格式化一下。
也不是所有类型为 5 的包都被压缩，只有某些可能数据量很大才会被压缩，比如 DANMU_MSG，SEND_GIFT 等，并且类型为 5 的可能是用户弹幕，礼物，贵宾进场，房间关注变动等，就是依靠 “cmd” 这个字段值来判别的，目前我已知的 cmd 有这么几种，可以根据需求来利用：</description>
			<content type="html"><![CDATA[<h1 id="b站直播协议分析">B站直播协议分析</h1>
<blockquote>
<p>上篇介绍协议分析，下篇介绍开发思路。</p>
</blockquote>
<h2 id="项目缘由">项目缘由</h2>
<p>假期在家，群里有几个朋友决定尝个新鲜开直播娱乐一下，后来发现B站官方提供的直播姬只有弹幕显示功能，并没有点歌等其他自定义功能，网上的项目也比较少，而且一些点歌机不维护了导致功能有缺陷，因此打算开发一个自定义的具有多功能的直播助手，初步包含弹幕礼物显示，点歌等功能。</p>
<p>开发的思路是<strong>分析传输二进制包，从中找出我们想要的数据，以我们想要的方式显示出来。</strong></p>
<h2 id="总体过程">总体过程</h2>
<p>随便打开一个直播间，按 F12，切换到 Network 的 WS 栏。可以看到它是首先连接弹幕服务器，并且通过观察发现这个地址并不是固定的（应该是负载均衡的结果）。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/image-20210125220539933.png" alt="wss链接"></p>
<p>然后发送一个握手包，携带了 Roomid，访问者 id，客户端版本等信息，最后还有一个 key，后来观察发现是通过请求某个接口获取的这个 key 值（就是 token）。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/image-20210125220806540.png" alt="握手包"></p>
<p>重点就是分析协议包。不管是接收还是发送的二进制包都有一个固定大小 16 字节的首部。这个首部的组成我用一个表格来表示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">偏移</th>
<th style="text-align:center">长度</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">4</td>
<td style="text-align:center">包的大小</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">未知（目前和分析无关）</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">4</td>
<td style="text-align:center">包类型</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">4</td>
<td style="text-align:center">未知（目前和分析无关）</td>
</tr>
</tbody>
</table>
<p>除了首部之外的就是携带的数据部分了。在这里需要注意的一点是，<strong>由于瞬时信息量可能会很大，会把若干个包压缩为一个包发送，这个包组成是《包首部-包主体-下一个包首部-下一个包主体-&hellip;..等等》</strong>，而且因为包类型为 5 的数量最多，传输信息量会很大，所以是用 gzip 压缩了的，这里要注意。这里随手拿一个包举例：</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="err">...G............</span><span class="p">{</span><span class="nt">&#34;cmd&#34;</span><span class="p">:</span><span class="s2">&#34;DANMU_MSG&#34;</span><span class="p">,</span><span class="nt">&#34;info&#34;</span><span class="p">:[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">8322816</span><span class="p">,</span><span class="mi">1584073975908</span><span class="p">,</span><span class="mi">1584073720</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="s2">&#34;7905c3d4&#34;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="s2">&#34;(=・ω・=)&#34;</span><span class="p">,[</span><span class="mi">14006391</span><span class="p">,</span><span class="s2">&#34;桥本环零&#34;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">10000</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s2">&#34;&#34;</span><span class="p">],[</span><span class="mi">17</span><span class="p">,</span><span class="s2">&#34;小糕兔&#34;</span><span class="p">,</span><span class="s2">&#34;娜可糕糕&#34;</span><span class="p">,</span><span class="mi">294526</span><span class="p">,</span><span class="mi">16752445</span><span class="p">,</span><span class="s2">&#34;&#34;</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">47</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">16746162</span><span class="p">,</span><span class="mi">10074</span><span class="p">],[</span><span class="s2">&#34;title-179-1&#34;</span><span class="p">,</span><span class="s2">&#34;title-179-1&#34;</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="kc">null</span><span class="p">,{</span><span class="nt">&#34;ts&#34;</span><span class="p">:</span><span class="mi">1584073975</span><span class="p">,</span><span class="nt">&#34;ct&#34;</span><span class="p">:</span><span class="s2">&#34;B0A7DFE4&#34;</span><span class="p">},</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">0</span><span class="p">]}</span><span class="err">...h............</span><span class="p">{</span><span class="nt">&#34;cmd&#34;</span><span class="p">:</span><span class="s2">&#34;DANMU_MSG&#34;</span><span class="p">,</span><span class="nt">&#34;info&#34;</span><span class="p">:[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">16777215</span><span class="p">,</span><span class="mi">1584073975938</span><span class="p">,</span><span class="mi">1584073264</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="s2">&#34;21635747&#34;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="s2">&#34;包砸是我关注的up里唯一一个很可爱的&#34;</span><span class="p">,[</span><span class="mi">339865528</span><span class="p">,</span><span class="s2">&#34;兰博基尼鬼怪&#34;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">10000</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s2">&#34;&#34;</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="s2">&#34;包崽铺&#34;</span><span class="p">,</span><span class="s2">&#34;喝薄荷奶绿&#34;</span><span class="p">,</span><span class="mi">1506599</span><span class="p">,</span><span class="mi">6406234</span><span class="p">,</span><span class="s2">&#34;&#34;</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">9868950</span><span class="p">,</span><span class="s2">&#34;\u003e50000&#34;</span><span class="p">],[</span><span class="s2">&#34;&#34;</span><span class="p">,</span><span class="s2">&#34;&#34;</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="kc">null</span><span class="p">,{</span><span class="nt">&#34;ts&#34;</span><span class="p">:</span><span class="mi">1584073975</span><span class="p">,</span><span class="nt">&#34;ct&#34;</span><span class="p">:</span><span class="s2">&#34;657DC663&#34;</span><span class="p">},</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">0</span><span class="p">]}</span>
</code></pre></div><p>可以看到这里就是瞬时有两条弹幕，变为了一个包。每个包都有自己的头部，可以自行格式化一下。</p>
<p>也<strong>不是所有类型为 5 的包都被压缩</strong>，只有某些可能数据量很大才会被压缩，比如 DANMU_MSG，SEND_GIFT 等，并且类型为 5 的可能是用户弹幕，礼物，贵宾进场，房间关注变动等，就是依靠 “cmd” 这个字段值来判别的，目前我已知的 cmd 有这么几种，可以根据需求来利用：</p>
<table>
<thead>
<tr>
<th style="text-align:center">cmd</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">DANMU_MSG</td>
<td style="text-align:center">用户弹幕</td>
</tr>
<tr>
<td style="text-align:center">WELCOME</td>
<td style="text-align:center">Vip，Svip进场（<strong>标注1</strong>）</td>
</tr>
<tr>
<td style="text-align:center">WELCOME_GUARD</td>
<td style="text-align:center">房管进场</td>
</tr>
<tr>
<td style="text-align:center">ENTRY_EFFECT</td>
<td style="text-align:center">提督，总督等头衔</td>
</tr>
<tr>
<td style="text-align:center">SEND_GIFT</td>
<td style="text-align:center">用户礼物</td>
</tr>
<tr>
<td style="text-align:center">COMBO_SEND</td>
<td style="text-align:center">礼物连击</td>
</tr>
<tr>
<td style="text-align:center">COMBO_END</td>
<td style="text-align:center">连击结束（<strong>标注2</strong>）</td>
</tr>
<tr>
<td style="text-align:center">ROOMD_RANK</td>
<td style="text-align:center">这个不太清楚是什么</td>
</tr>
<tr>
<td style="text-align:center">NOTICE_MSG</td>
<td style="text-align:center">所有直播间的通告消息</td>
</tr>
</tbody>
</table>
<blockquote>
<p>标注 1: 我不太了解 B 站 Vip 的等级划分，我仅知道提督，总督等，还有老爷这些，其他不知道了，老爷是被划分到这一栏的。</p>
</blockquote>
<blockquote>
<p>标注 2: 如果送礼物连击是会有和《SEND_GIFT》不一样的特效的，连击结束也有提示，所以分开了。</p>
</blockquote>
<p>这里给出一些用到的接口，后续可能会更新失效，F12 打开找即可，截止博客发出时均有效。</p>
<table>
<thead>
<tr>
<th style="text-align:center">URL</th>
<th style="text-align:center">参数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="http://api.live.bilibili.com/room/v1/Room/room_init">http://api.live.bilibili.com/room/v1/Room/room_init</a></td>
<td style="text-align:center">id</td>
<td style="text-align:center">查询房间短id，长id等信息</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://api.live.bilibili.com/room/v1/Danmu/getConf">https://api.live.bilibili.com/room/v1/Danmu/getConf</a></td>
<td style="text-align:center">room_id=xxx&amp;platform=pc&amp;player=web</td>
<td style="text-align:center">查询可用弹幕服务器列表，握手包的key</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://api.bilibili.com/x/space/acc/info">https://api.bilibili.com/x/space/acc/info</a></td>
<td style="text-align:center">mid=382297465&amp;jsonp=jsonp</td>
<td style="text-align:center">根据userid查询用户个人信息</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://api.live.bilibili.com/xlive/web-room/v1/index/getInfoByRoom">https://api.live.bilibili.com/xlive/web-room/v1/index/getInfoByRoom</a></td>
<td style="text-align:center">room_id=xxx</td>
<td style="text-align:center">查询房间信息，标题等</td>
</tr>
</tbody>
</table>
<p>到这里其实就已经结束了，<strong>我们可以模拟连接某个弹幕服务器，然后按照要求发送握手包，随后一直接收信息，根据首部的类型 ID 可以判定不同的包，然后根据 cmd 字段判定消息类型，获取我们想要的字段值就可以了。再结合其他的一些接口就可以完整的获取直播间的各种信息了。</strong></p>
<p>分析完后，就可以根据流程去写程序了，下一节介绍如何使用 <a href="https://golang.org/">Go</a> 语言开发助手的后端部分。</p>
]]></content>
		</item>
		
	</channel>
</rss>
