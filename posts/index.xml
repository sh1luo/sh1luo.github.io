<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on 失落</title>
		<link>https://www.kcode.icu/posts/</link>
		<description>Recent content in Posts on 失落</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>zh-hans</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Fri, 22 Jan 2021 23:35:20 +0000</lastBuildDate>
		<atom:link href="https://www.kcode.icu/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>深入理解 Go map</title>
			<link>https://www.kcode.icu/posts/go/map/</link>
			<pubDate>Fri, 22 Jan 2021 23:35:20 +0000</pubDate>
			
			<guid>https://www.kcode.icu/posts/go/map/</guid>
			<description>哈希表 几乎所有语言都有 哈希表 这个数据结构，能够在平均 O(1)，最差 O(n) 的时间复杂度增删改查元素，Go 语言哈希表的精妙设计使得它几乎不会出现 O(n) 的糟糕情况。这篇文章我就带你从使用到底层由浅入深地探究 Go map 的奥秘，一起作一个不只是会用的”大神“。
问题来源于实际，我们先看看这些问题 ：
 声明。当我使用 :=，var，make，甚至 new 声明 map 的时候，编译器帮我们做了什么事情，它们有什么区别？ 增删改查。使用 数组+链表 的情况下如何设计才能避免 O(n) 的最差情况？ 注意事项。map 的键有什么要求？map 是值类型还是引用类型，函数传参时会有上层影响吗？是并发安全的吗？  还有一个常识是 Go map 的遍历是随机的，即多次遍历输出的结果集不同。
设计方式 Go map 实现哈希表使用的是 数组+链表 的形式，也就是使用链地址法解决的哈希冲突。这种方式桶的大小和元素个数之间没有关系，另外还有开放定址法，这是个宽泛的名字，具体包含线性探测法，再哈希法，平方探测法等等。
为了降低 map 操作的时间复杂度，引入了一个 负载因子 的概念，这个概念在其他实现哈希表这个数据结构的语言里也都有，比如 python 中这个值被定义为 2/3，Java 中是 0.75，这个值评估了哈希表里 实际上最好只存 多少个元素，而不是一直等到满载再处理，因为多到一定程度效率 可能 就低了。在 Go 语言里这个值被定义为 6.5。
数据结构 当我们在 Go 语言中声明一个 map 的时候，实际上就是创建了一个 hmap 的结构体，它定义在 runtime/map.go 文件下。 哈希表就是实现一个映射关系，给出自变量 x，能够通过平均 O(1) 的时间复杂度方法找到这个元素所对应的因变量 y=f(x)，这里有个非常重要的限制：对于无限的输入，需要给出有限的输出。在哈希函数中这句话成立，在 Go map 中也成立，指的是只有有限的桶，怎么放无限的元素？所以我们需要考虑这个问题。</description>
			<content type="html"><![CDATA[<h2 id="哈希表">哈希表</h2>
<p>几乎所有语言都有 <a href="https://en.wikipedia.org/wiki/Hash_table">哈希表</a> 这个数据结构，能够在平均 O(1)，最差 O(n) 的时间复杂度增删改查元素，Go 语言哈希表的精妙设计使得它几乎不会出现 O(n) 的糟糕情况。这篇文章我就带你从使用到底层由浅入深地探究 Go map 的奥秘，一起作一个不只是会用的”大神“。</p>
<p>问题来源于实际，我们先看看这些问题 ：</p>
<ul>
<li><strong>声明</strong>。当我使用 <code>:=</code>，<code>var</code>，<code>make</code>，甚至 <code>new</code> 声明 map 的时候，编译器帮我们做了什么事情，它们有什么区别？</li>
<li><strong>增删改查</strong>。使用 数组+链表 的情况下如何设计才能避免 O(n) 的最差情况？</li>
<li><strong>注意事项</strong>。map 的键有什么要求？map 是值类型还是引用类型，函数传参时会有上层影响吗？是并发安全的吗？</li>
</ul>
<p>还有一个常识是 Go map 的<strong>遍历是随机的</strong>，即多次遍历输出的结果集不同。</p>
<h3 id="设计方式">设计方式</h3>
<p>Go map 实现哈希表使用的是 <strong>数组+链表</strong> 的形式，也就是使用链地址法解决的哈希冲突。这种方式桶的大小和元素个数之间没有关系，另外还有开放定址法，这是个宽泛的名字，具体包含线性探测法，再哈希法，平方探测法等等。</p>
<p>为了降低 map 操作的时间复杂度，引入了一个 <a href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/map.go#L70">负载因子</a> 的概念，这个概念在其他实现哈希表这个数据结构的语言里也都有，比如 python 中这个值被定义为 2/3，Java 中是 0.75，这个值评估了哈希表里 <strong>实际上最好只存</strong> 多少个元素，而不是一直等到满载再处理，因为多到一定程度效率 <strong>可能</strong> 就低了。在 Go 语言里这个值被定义为 6.5。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/map_zipper.svg" alt="separate chaining"></p>
<h3 id="数据结构">数据结构</h3>
<p>当我们在 Go 语言中声明一个 map 的时候，实际上就是创建了一个 <a href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/map.go#L115">hmap</a> 的结构体，它定义在 <code>runtime/map.go</code> 文件下。 哈希表就是实现一个映射关系，给出自变量 x，能够通过平均 O(1) 的时间复杂度方法找到这个元素所对应的因变量 y=f(x)，这里有个非常重要的限制：<strong>对于无限的输入，需要给出有限的输出</strong>。在哈希函数中这句话成立，在 Go map 中也成立，指的是只有有限的桶，怎么放无限的元素？所以我们需要考虑这个问题。</p>
<h3 id="初始化">初始化</h3>
<h3 id="读写操作">读写操作</h3>
<h4 id="访问">访问</h4>
<h4 id="写入">写入</h4>
<h4 id="删除">删除</h4>
<h4 id="扩容">扩容</h4>
<h3 id="总结">总结</h3>
]]></content>
		</item>
		
		<item>
			<title>博客图床解决方案</title>
			<link>https://www.kcode.icu/posts/chore/imgs/</link>
			<pubDate>Wed, 20 Jan 2021 15:45:13 +0000</pubDate>
			
			<guid>https://www.kcode.icu/posts/chore/imgs/</guid>
			<description>很多人应该都听说过来人说过要写博客进行总结记录，一是说自己学习过程的复盘，二是在某些时候向不认识自己的人间接显示自己的大致水平。不过如果没有人“手把手”教的话我相信还会遇到各种各样的问题的，这篇文章就介绍一下在博客中必不可少的图片网络地址解决方法，也就是图床。它的目标是在你写文章的过程中可以一键插入目标图片并自动上传到网络，就像你使用本地图片一样快捷。
图床的目的就是把你的本地图片上传上去，从而能获得它的网络地址。当然了，只使用图床也是可以的，但是需要配合对应的工具上传拿 URL（比如 OSS）或者纯手动（GitHub/Gitee），非常不方便 一点也不极客，所以需要配合其他工具一键快速拿到它对应的网络地址（URL），所以我在下面介绍了我使用到的工具，仅供参考。
 评估用的稳定性指你上传的图片会不会在某个不确定的时间突然挂掉，让你的文章出现大量图片 404 丢失的情况。
 图床 这里我介绍三种图床，列出优缺点。可以根据需要进行选择。
GitHub/Gitee GitHub 和 Gitee 是干什么的我就不多说了，它们也是可以作为图床使用的，前者境内访问较慢，后者较快。没有账号可以免费注册一个，然后随便创建一个公开仓库，把图片上传上去就可以获取它的 URL 了，比较简单粗暴。
优点：稳定性较好，空间无限，上手难度较简单
缺点：无法阻止盗链，无法管理（原本目的就不是作为图床，没有统计流量等功能）。
总结，如果你是新手，不担心自己的图片被别人轻易获取 ，随缘使用图床，这个是首选。
OSS OSS （Object Storage Service）即对象存储服务，用来做个人博客的图床有点小题大做，腾讯云、阿里云等等提供 OSS 的平台都可以，一般需要续费，一年 50G 左右话 10 块钱左右。
优点：可控性比较强，提供了专业的平台，你能想到的各种需求基本都有，包括防盗链，流量统计与分析等。
缺点：对新手不友好，根据流量付费。
总结，如果你未来博客流量会不断增大，出于可控考虑选这个，流量较小的新人不考虑。
不稳定第三方 也可以使用这种第三方的图床，没有任何操作步骤，上传完就拿到 URL，当然事物都有两面性，这种极致快捷带来的就是不稳定，就跟当年的新浪图床一样，你不知道什么时候它就没了。。
优点：简单快捷打开一键就用，免费
缺点：不知道什么时候你的图片就被人家清了。。然后你的文章里的图片就全部 404 了。。
总结，随缘党首选不解释，懂得都懂。
工具 这里就介绍我使用的两个配合工具，其他的可以自行搜索。
typora typora 是一款 Markdown 文本编辑软件，我相信写过 Markdown 的都听说过，它的特点是真正的实时显示，不左右分栏，扩展性强，灵活可配置。我个人平时写 Markdown 文本都是使用这个软件，具体可以去它的官网首页看，十分推荐。
PicGo PicGo 是一款使用 Node + Electron 开发的跨平台可视化图片上传开源软件，支持 N 种图床平台，配置灵活简单，最重要的是它支持插件功能，理论上支持任意图床平台的使用（需要提供相应上传下载的 API），可以自行开发插件。操作也比较简单，把图片拖到框里就可以拿到 URL。这张图是 gitee 相关配置，其他平台类似，只需若干个必要参数即可：
配合使用 前面说的这两种工具可以结合使用快速进行写作，在 typora 主界面上方，文件-&amp;gt;偏好设置-&amp;gt;图像，修改 PicGo 路径为你安装的路径下的 exe 地址。这样就可以做到你在 typora 里编辑时直接粘贴图片到文档里一键点击上传，非常方便。当然了，如果你不需要 typora，或者使用的是别的 Markdown 编辑器，也可以只使用 PicGo。</description>
			<content type="html"><![CDATA[<p>很多人应该都听说过来人说过要写博客进行总结记录，一是说自己学习过程的复盘，二是在某些时候向不认识自己的人间接显示自己的大致水平。不过如果没有人“手把手”教的话我相信还会遇到各种各样的问题的，这篇文章就介绍一下在博客中必不可少的图片网络地址解决方法，也就是图床。它的目标是<strong>在你写文章的过程中可以一键插入目标图片并自动上传到网络，就像你使用本地图片一样快捷。</strong></p>
<p>图床的目的就是把你的本地图片上传上去，从而能获得它的网络地址。当然了，只使用图床也是可以的，但是需要配合对应的工具上传拿 URL（比如 OSS）或者纯手动（GitHub/Gitee），<del>非常不方便</del> 一点也不极客，所以需要配合其他工具一键快速拿到它对应的网络地址（URL），所以我在下面介绍了我使用到的工具，仅供参考。</p>
<blockquote>
<p>评估用的稳定性指你上传的图片会不会在某个不确定的时间突然挂掉，让你的文章出现大量图片 404 丢失的情况。</p>
</blockquote>
<h1 id="图床">图床</h1>
<p>这里我介绍三种图床，列出优缺点。可以根据需要进行选择。</p>
<h2 id="githubgitee">GitHub/Gitee</h2>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/123.png" alt="Gitee"></p>
<p><a href="https://github.com/">GitHub</a> 和 <a href="https://gitee.com/">Gitee</a> 是干什么的我就不多说了，它们也是可以作为图床使用的，前者境内访问较慢，后者较快。没有账号可以免费注册一个，然后随便创建一个公开仓库，把图片上传上去就可以获取它的 URL 了，比较简单粗暴。</p>
<p>优点：稳定性较好，空间无限，上手难度较简单</p>
<p>缺点：无法阻止盗链，无法管理（原本目的就不是作为图床，没有统计流量等功能）。</p>
<p>总结，如果你是新手，不担心自己的图片被别人<strong>轻易获取</strong> ，随缘使用图床，这个是首选。</p>
<h2 id="oss">OSS</h2>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/image-20210120131946016.png" alt="aliyun OSS"></p>
<p>OSS （Object Storage Service）即对象存储服务，用来做个人博客的图床有点小题大做，腾讯云、阿里云等等提供 OSS 的平台都可以，一般需要续费，一年 50G 左右话 10 块钱左右。</p>
<p>优点：可控性比较强，提供了专业的平台，你能想到的各种需求基本都有，包括防盗链，流量统计与分析等。</p>
<p>缺点：对新手不友好，根据流量付费。</p>
<p>总结，如果你未来博客流量会不断增大，出于可控考虑选这个，流量较小的新人不考虑。</p>
<h2 id="不稳定第三方">不稳定第三方</h2>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/image-20210120132728890.png" alt="SM.MS"></p>
<p>也可以使用这种第三方的图床，没有任何操作步骤，上传完就拿到 URL，当然事物都有两面性，这种极致快捷带来的就是不稳定，就跟当年的新浪图床一样，你不知道什么时候它就没了。。</p>
<p>优点：简单快捷打开一键就用，免费</p>
<p>缺点：不知道什么时候你的图片就被人家清了。。然后你的文章里的图片就全部 404 了。。</p>
<p>总结，随缘党首选不解释，懂得都懂。</p>
<h1 id="工具">工具</h1>
<p>这里就介绍我使用的两个配合工具，其他的可以自行搜索。</p>
<h2 id="typora">typora</h2>
<p><a href="https://typora.io/">typora</a> 是一款 Markdown 文本编辑软件，我相信写过 Markdown 的都听说过，它的特点是真正的实时显示，不左右分栏，扩展性强，灵活可配置。我个人平时写 Markdown 文本都是使用这个软件，具体可以去它的官网首页看，十分推荐。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/GIF%202021-1-20%2018-44-01.gif" alt="实时转换"></p>
<h2 id="picgo">PicGo</h2>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/image-20210120134735352.png" alt=""></p>
<p><a href="https://github.com/Molunerfinn/PicGo">PicGo</a> 是一款使用 Node + Electron 开发的跨平台可视化图片上传开源软件，支持 N 种图床平台，配置灵活简单，最重要的是它支持插件功能，理论上支持任意图床平台的使用（需要提供相应上传下载的 API），可以自行开发插件。操作也比较简单，把图片拖到框里就可以拿到 URL。这张图是 gitee 相关配置，其他平台类似，只需若干个必要参数即可：</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/image-20210120135009612.png" alt="配置"></p>
<h2 id="配合使用">配合使用</h2>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/test.png" alt="PicGo配置"></p>
<p>前面说的这两种工具可以结合使用快速进行写作，在 typora 主界面上方，文件-&gt;偏好设置-&gt;图像，修改 PicGo 路径为你安装的路径下的 exe 地址。这样就可以做到你在 typora 里编辑时直接粘贴图片到文档里一键点击上传，非常方便。当然了，如果你不需要 typora，或者使用的是别的 Markdown 编辑器，也可以只使用 PicGo。</p>
<p>而且它是开源的，如果你有任何建议可以提 Issue 或者自己为它增加特性 :)</p>
<p>我这里就有一个相关需求，自定义重命名上传文件，我想将所有图片按照我自己的规则自动重命名后再上传，比如统一按照格式 <code>year-month-day-imgID</code> 这种格式，方便后续整理图片。当然了，这里只是抛砖引玉，更多的留给大家去探索 :)</p>
<p>最后配一个最终的成品 GIF 图给大家看一下效果：</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/dddd.gif" alt="dddd"></p>
<p>如果你有什么问题欢迎来找我玩，一起交流。</p>
]]></content>
		</item>
		
		<item>
			<title>谈谈最常见的 HTTP</title>
			<link>https://www.kcode.icu/posts/http/</link>
			<pubDate>Fri, 15 Jan 2021 23:10:22 +0000</pubDate>
			
			<guid>https://www.kcode.icu/posts/http/</guid>
			<description>标题的”最常见“我想应该没有什么争议，对大多数人来说日常生活中接触到最多的应用层协议就是 HTTP了，从聊天软件、浏览器页面再到各种游戏实现，它们无处不在。这篇文章我就带你来看一看这个处于 OSI 标准最上层、最常用也是最普通的 HTTP 它究竟有什么“东西”，一起作为一个不只是听说过的“大神”。
这篇博客我想阐述除书本概念之外的一些个人理解，希望对你有所帮助。
HTTP是什么 超文本传输协议（Hypertext Transfer Protocol，HTTP），是一个应用层面上的，也就是软件双方通信的数据规则，不然你发给我一串 @#$%$%^$%^，只有你能看懂，我怎么知道你说的是什么玩意？双方按照这个规则去通信，有什么需求都在这个规范里写好了发给对方，对方就知道你想干什么，就可以也按照这个规范给你回过去，就是这么简单。只是因为随着技术的发展，所遇到的问题越来越多，安全、效率、可读性等等，不得不提出一系列的解决方案去完善，最终变得很”臃肿“罢了。但是你应该明白，这就是一个为应用程序通信所提出来的一个通信协议，站在这个角度上去理解我相信你能更容易明白。
HTTP方法、状态码这些究竟是什么？ 我常看到有关于 HTTP：
 ”get 和 post“方法有什么区别？ 状态码有哪些？  进阶的可能有：
 HTTP 演变过程是什么，从原因到解决方案一步一步说。   演变过程 </description>
			<content type="html"><![CDATA[<p>标题的”最常见“我想应该没有什么争议，对大多数人来说日常生活中接触到最多的应用层协议就是 HTTP了，从聊天软件、浏览器页面再到各种游戏实现，它们无处不在。这篇文章我就带你来看一看这个处于 OSI 标准最上层、最常用也是最普通的 HTTP 它究竟有什么“东西”，一起作为一个不只是听说过的“大神”。</p>
<p>这篇博客我想阐述除书本概念之外的一些个人理解，希望对你有所帮助。</p>
<h2 id="http是什么">HTTP是什么</h2>
<p>超文本传输协议（Hypertext Transfer Protocol，HTTP），是一个应用层面上的，也就是软件双方通信的数据规则，不然你发给我一串 @#$%$%^$%^，只有你能看懂，我怎么知道你说的是什么玩意？双方按照这个规则去通信，有什么需求都在这个规范里写好了发给对方，对方就知道你想干什么，就可以也按照这个规范给你回过去，就是这么简单。只是因为随着技术的发展，所遇到的问题越来越多，安全、效率、可读性等等，不得不提出一系列的解决方案去完善，最终变得很”臃肿“罢了。但是你应该明白，这就是一个为应用程序通信所提出来的一个通信协议，站在这个角度上去理解我相信你能更容易明白。</p>
<h2 id="http方法状态码这些究竟是什么">HTTP方法、状态码这些究竟是什么？</h2>
<p>我常看到有关于 HTTP：</p>
<ul>
<li>”get 和 post“方法有什么区别？</li>
<li>状态码有哪些？</li>
</ul>
<p>进阶的可能有：</p>
<ul>
<li>HTTP 演变过程是什么，从原因到解决方案一步一步说。</li>
<li></li>
</ul>
<h2 id="演变过程">演变过程</h2>
]]></content>
		</item>
		
		<item>
			<title>一些常见Go语言及面试问题的整理</title>
			<link>https://www.kcode.icu/posts/interview/somequestions/</link>
			<pubDate>Fri, 15 Jan 2021 21:10:55 +0000</pubDate>
			
			<guid>https://www.kcode.icu/posts/interview/somequestions/</guid>
			<description>这篇博客记录一些关于面试常见的 Go 语言方面的问题，希望能帮到大家，等待更新中。
Go make和new的区别，使用和底层？ Go内存管理 goroutine 什么时候会阻塞？ goroutine有几种状态？ m操作g的时候有自旋与非自旋状态？
线程有哪些状态 注册中心挂了怎么办？ N节点，raft一致性？
反射底层原理？ 通过反射执行函数，拿结构体tag？ 锁机制？饥饿模式正常模式？锁底层原理？ channel使用，坑，底层原理？ </description>
			<content type="html"><![CDATA[<p>这篇博客记录一些关于面试常见的 Go 语言方面的问题，希望能帮到大家，等待更新中。</p>
<h2 id="go-make和new的区别使用和底层">Go make和new的区别，使用和底层？</h2>
<h2 id="go内存管理">Go内存管理</h2>
<h2 id="goroutine-什么时候会阻塞">goroutine 什么时候会阻塞？</h2>
<h2 id="goroutine有几种状态">goroutine有几种状态？</h2>
<p>m操作g的时候有自旋与非自旋状态？</p>
<h2 id="线程有哪些状态">线程有哪些状态</h2>
<h2 id="注册中心挂了怎么办">注册中心挂了怎么办？</h2>
<p>N节点，raft一致性？</p>
<h2 id="反射底层原理">反射底层原理？</h2>
<h2 id="通过反射执行函数拿结构体tag">通过反射执行函数，拿结构体tag？</h2>
<h2 id="锁机制饥饿模式正常模式锁底层原理">锁机制？饥饿模式正常模式？锁底层原理？</h2>
<h2 id="channel使用坑底层原理">channel使用，坑，底层原理？</h2>
]]></content>
		</item>
		
		<item>
			<title>几经周折的博客变迁史</title>
			<link>https://www.kcode.icu/posts/chore/blog_journey/</link>
			<pubDate>Wed, 06 Jan 2021 21:13:13 +0000</pubDate>
			
			<guid>https://www.kcode.icu/posts/chore/blog_journey/</guid>
			<description>仔细想起来我的博客旅程也有好多年了，兜兜转转地走了不少弯路，也确实在这个过程中学到了很多东西，大致有这些时间节点：
 尝试购买了国内域名和学生机服务器，看到自己写的内容能在公网上让全世界的人看到就高兴了好久，内容很随意，自己管理。 使用 hexo 框架系统化内容，并部署到 GitHub Page 上交给 GitHub 管理。 发现了国内访问速度更快的 Gitee Page。 再次购买域名，使用 CDN 加速国外空间，未果（下文说）&amp;hellip;&amp;hellip;  前前后后也折腾了好几年，技术上的提升我倒觉得不太大，因为折腾地挺多但是都是应用层面上的，对我来说更多的是动手能力的提高，有好多东西不经过自己亲手尝试是根本理解不了的，我前面很多东西就是别人远程或者一步一步告诉我让我去点这个点那个就可以了，但是回过头来问你，你根本不知道发生了什么，甚至隔天就忘，这是典型的不理解、死记硬背式学习方法。
当时配置那个 A 记录，CNAME 记录啥的根本不知道是什么东西，也不知道 DNS 是什么，就是配，成功了就行，不成功就猜，一个个试呗。现在想想，真的是走了不少弯路，如果能系统地学一下多好。不过这些问题也都在我后来的实践以及学习过程中逐一解决了，现在遇到问题也不用像没头苍蝇一样乱撞了，这种感觉很不错 :)
这件事也让我大致理解了一句老话，大致是这么说的：真正厉害的技术人员不是说他写程序一定要多么多么厉害，而是他有非常强悍的问题定位能力（trouble shooting），能解决别人解决不了的问题，而这一切都源自于无数经验的积累以及深度的思考。
下面说我的最后一次迁移：)
 之所以有两个部分是因为买了域名后才发现必须要国内域名并且备案，才能加速国内。我买的是国外域名所以没办法，最后就用 GitHub Page + 自定义域名了。
 GitHub Page+自定义域名 这种方案比较简单（因为GitHub 都帮我们做了），你首先需要创建一个名为 &amp;lt;YourGitHubName&amp;gt;.github.io 的仓库，比如 sh1luo.github.io，然后购买一个域名（国内国外都行，国内要备案），给他添加一条 CNAME 记录 ，就像这样
我是国外的域名，所以转为了国内的 DNSPod 进行解析，希望快一点，做法也非常简单。就是把原域名服务器商的 NameServers 改成 新解析服务器提供的就好了，如上图的 hickory.dnspod.net 那两条。
当然，如果你本来就是国内域名，就不用这么麻烦了，直接添加一条 CNAME 记录，然后在 GitHub Pages 那里设置上自定义域名就完事了，它会自动帮你部署 HTTPS 和一切的 :)
CDN加速 如果你是国内的域名但是是国外的空间，就可以使用 CDN 加速了，加速区域选国内。这里需要注意源站地址由于是 GitHub Pages ，而 GitHub Pages 有 4 个 IP。都写上一行一个，回源 HOST 写你自己地址就可以了。这个回源 HOST 实际上就是 HTTP 头里的 host 字段，如果同一台机器上有多个服务的话，用来标识是哪一个服务，比较常见就是一个 IP 地址上配置了多个域名，就是通过这种给 host 首部字段的方式区分的不同 Web 站点。</description>
			<content type="html"><![CDATA[<p>仔细想起来我的博客旅程也有好多年了，兜兜转转地走了不少弯路，也确实在这个过程中学到了很多东西，大致有这些时间节点：</p>
<ul>
<li>尝试购买了国内域名和学生机服务器，看到自己写的内容能在公网上让全世界的人看到就高兴了好久，内容很随意，自己管理。</li>
<li>使用 hexo 框架系统化内容，并部署到 GitHub Page 上交给 GitHub 管理。</li>
<li>发现了国内访问速度更快的 Gitee Page。</li>
<li>再次购买域名，使用 CDN 加速国外空间，未果（下文说）&hellip;&hellip;</li>
</ul>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/image-20210118174633253.png" alt="现在的博客"></p>
<p>前前后后也折腾了好几年，技术上的提升我倒觉得不太大，因为折腾地挺多但是都是应用层面上的，对我来说更多的是动手能力的提高，有好多东西不经过自己亲手尝试是根本理解不了的，我前面很多东西就是别人远程或者一步一步告诉我让我去点这个点那个就可以了，但是回过头来问你，你根本不知道发生了什么，甚至隔天就忘，这是典型的不理解、死记硬背式学习方法。</p>
<p>当时配置那个 A 记录，CNAME 记录啥的根本不知道是什么东西，也不知道 DNS 是什么，就是配，成功了就行，不成功就猜，一个个试呗。现在想想，真的是走了不少弯路，如果能系统地学一下多好。不过这些问题也都在我后来的实践以及学习过程中逐一解决了，现在遇到问题也不用像没头苍蝇一样乱撞了，这种感觉很不错 :)</p>
<p>这件事也让我大致理解了一句老话，大致是这么说的：真正厉害的技术人员不是说他写程序一定要多么多么厉害，而是他有非常强悍的问题定位能力（trouble shooting），能解决别人解决不了的问题，而这一切都源自于无数经验的积累以及深度的思考。</p>
<p>下面说我的最后一次迁移：)</p>
<blockquote>
<p>之所以有两个部分是因为买了域名后才发现必须要国内域名并且备案，才能加速国内。我买的是国外域名所以没办法，最后就用 GitHub Page + 自定义域名了。</p>
</blockquote>
<h2 id="github-page自定义域名">GitHub Page+自定义域名</h2>
<p>这种方案比较简单（因为GitHub 都帮我们做了），你首先需要创建一个名为 <code>&lt;YourGitHubName&gt;.github.io</code> 的仓库，比如 <code>sh1luo.github.io</code>，然后购买一个域名（国内国外都行，国内要备案），给他添加一条 <a href="https://baike.baidu.com/item/CNAME/9845877?fr=aladdin">CNAME 记录</a> ，就像这样</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/image-20210119101326692.png" alt="DNS记录"></p>
<p>我是国外的域名，所以转为了国内的 <a href="https://www.dnspod.cn/">DNSPod</a> 进行解析，希望快一点，做法也非常简单。就是把原域名服务器商的 NameServers 改成 新解析服务器提供的就好了，如上图的 hickory.dnspod.net 那两条。</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/image-20210118183902580.png" alt="image-20210118183902580"></p>
<p>当然，如果你本来就是国内域名，就不用这么麻烦了，直接添加一条 CNAME 记录，然后在 GitHub Pages 那里设置上自定义域名就完事了，它会自动帮你部署 HTTPS 和一切的 :)</p>
<p><!-- raw HTML omitted --></p>
<h2 id="cdn加速">CDN加速</h2>
<p>如果你是国内的域名但是是国外的空间，就可以使用 CDN 加速了，加速区域选国内。这里需要注意源站地址由于是 GitHub Pages ，而 GitHub Pages 有 4 个 IP。都写上一行一个，回源 HOST 写你自己地址就可以了。这个回源 HOST 实际上就是 HTTP 头里的 host 字段，如果同一台机器上有多个服务的话，用来标识是哪一个服务，比较常见就是一个 IP 地址上配置了多个域名，就是通过这种给 host 首部字段的方式区分的不同 Web 站点。</p>
<p><!-- raw HTML omitted --></p>
<p>配置完源站信息后，会生成一个 CDN 域名，比如我的是 <code>kcode.icu.cdn.dnsv1.com</code> ，然后再添加一条 CNAME 记录指向这个域名就搞定。参考上面的 <code>DNS记录</code> 这张图。这样配置过，你的网站经过缓存后国内访问速度能达到非常恐怖的速度，可以试着 ping 一下哦。</p>
<h2 id="actions自动化构建">Actions自动化构建</h2>
<h2 id="说在最后">说在最后</h2>
<p>之前是在阿里云买的是国内域名并在阿里云备案，到期之后续费价格是之前 10 倍。。在这个期间还不小心把备案号主体（直到现在我也不知道是个啥，貌似还需要写个书面申请到当地管局）不小心删了，再次备案怎么也申请不过，左右摇头+上下点头了几十分钟脖子都酸了还不通过，于是直接去 <a href="https://www.namesilo.com/">NameSilo</a> 上买的国外域名。这里没什么好说的就是付费就完事（手动狗头）。</p>
<p>因为这是国外域名服务器，如果你想用国内域名服务器解析的话（比如国内的），就把 NameServers 设置为目标域名服务器提供的记录值就可以了，其实就是一条 NS 记录。我用的还是它默认的域名服务器，因为我的是国外域名，CDN 国内加速不了，必须要备案，下面会说。</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/image-20210117164512937.png" alt="hickory这个位置字段的这两条就是"></p>
<p>如果你要修改域名服务器的话，在目标网站上里创建域名后，就会为你生成若干条 NS 记录，回到原网站修改了就好了。</p>
<blockquote>
<p>买域名可以选择国内也可以选择国外，国内必须备案，国外不用。</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>记人生中前几次面试及思考</title>
			<link>https://www.kcode.icu/posts/interview/2020-12-interview/</link>
			<pubDate>Sun, 03 Jan 2021 21:18:13 +0000</pubDate>
			
			<guid>https://www.kcode.icu/posts/interview/2020-12-interview/</guid>
			<description>写作背景 由于早早有了就业的想法，于是我在大三上学期快要结束的时候便早早地”物色“各大公司的实习了，也是希望能在就业前增加几段实习经历，丰富一下经验。这也是人生中我的第一次面试，感触颇多。特别记录下来自己的总结以及对于假期自己的学习规划。
面试总结 这次我面试的总共有三家公司，跟谁学、字节跳动和腾讯，对我印象最深也是帮助最大的就是”字节跳动“。关于面试的准备大致有三块，简历、技术口述和手撕代码，下面分开说。
简历 我个人使用的简历大致是这样的风格，简约并且色调一致。简历这块我倒没什么卡壳，简历没过的 我猜 都是因为学历等等硬性条件不合适，这也是没有办法的事情。这里需要确保这么几点：
 不要造假，实事求是 。虽然有的公司面试官根本不看你简历问（我的几次实习面试不看，校招社招应该是要看的），但是如果你写熟悉甚至精通，你躲过了 HR，但是人家面试官上来问了一个很简单的问题你答不上来，人家可能没兴趣继续问了。。在面试官心里你的这项技术等于没写，并且有了吹牛的成分，众所周知，搞技术的都不喜欢这种人。 拿出有说服力的证据。 这一条不单指技术也包括其他方面，举个例子，如果你写了你优化了这个项目，那么等于没写，谁知道你优化了多少？比如原来服务器 CPU 总是跑到 90+%，然后你通过 xxx 手段优化，优化到了稳定在 70% 左右，这就比较有说服里，面试官也比较好针对你的这个点去问。再举个例子，你在个人相关那栏里写英语能力强，学习能力不错，热爱新技术，咱就不说过没过四六级了，人家让你现场看个技术文，获取跟你聊两句，你蒙蔽了，尴尬不。问你平时咋学习的，你磕磕巴巴说不出个所以然，或者一点逻辑没有，东一头看书，西一头看视频，再来一手看野生技术文章，你说尴尬不。 注意行业基础。 我拿技术来说，搞技术的，你说你写了个热爱技术，结果写个 GitHub ，都能拼错，写成 Github 等等，写个 CSDN 写成 Csdn ，虽说这不是什么大事，但是这些书面东西，我们搞技术的不能犯错的，这给人的印象就是你很不专业，或者说你接触的很少以至于记不清楚。假如说你说热爱开源，整天 GitHub 排行榜逛个遍，你告诉我你不知道 GitHub 怎么拼，不合适吧？我曾经见过一个人说他懂这懂那，结果拿来简历一看，关于技术的名字错了好几个，还说自己热爱这些，实际水平也就可想而知了。  我个人关于简历这块总结就是这样，虽然说简历很重要，但是我认为还是不难写的，把握好这些点即可 :)
技术口述 这部分是面试重头戏，除去手撕代码部分其余就是这个了（还可能有项目环节），对于这部分我感触最多。大体是，以前我认为掌握一种技术就是会用来解决某个问题就完事了，不想探究怎么实现的。举个例子，现在需要有个从反序列化出来的 json 字节数组里拿某个字段的值，以前的我就是去找个库用用完事了，现在经过大厂面试洗礼的我是这样的：我能不能自己写一个，看他代码不多呀，这样写效率高不高？紧接着看了源代码之后就会惊叹：哇还能这么设计，哇这个还能这么用，厉害了。。。真实。。。
而实际面试里也是这样的，我们不能只考虑表现层面的东西，而要去探究其底层大致的实现原理，只有这样，当你遇到问题的时候才能有初步想法从而去解决，而不是只会去问别人。别人不告诉你或者怎样你就解决不了了，不是有那么一句话说得好嘛，好的工程师（注意不是程序员）并不是他写的代码多厉害，而是他遇到问题总是能快速定位问题，并以最优雅的方式去解决，这一点值得我们深思。学会用工程师的视角去解决问题也是我们每一个人的最终目标。
在面试过程中我也遇到了很多之前没考虑过的问题，举个例子，我写的 RPC 框架里，大的问题比如说 注册中心挂了怎么办？能不能自动通过 .proto 文件生成规范的并且与我们框架配合使用的 RPC 代码？小的问题比如说 底层用的 NIO，NIO是什么，为什么快等等。因为我这个框架说白了只在运输层以上工作，我只在运输层以上思考，也就是说只是应用层面理解了而已，只是更深一点点的应用层面罢了，所以当面试官问我一系列深层次的问题后，我的问题就暴露出来了：对这个框架没有进一步的思考和认识。所以这也是我接下来要去思考和改进的一个点。项目大致都是如此，比如你写了一个 Web 类型的项目，用到了某某框架、技术或者标准库，你就要思考为什么它很好？好在哪了？我个人对它有优化吗？我实际上做了什么事情呢？我能从哪些方面提高它的并发量或者说是功能技术创新呢？
总结来说就是项目要有一定规模，有一定自己的思考在里面，别人问你关于你项目的特色，你的工作点，你都有的说。
假期规划 </description>
			<content type="html"><![CDATA[<h2 id="写作背景">写作背景</h2>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/bd.jpg" alt="bd"></p>
<p>由于早早有了就业的想法，于是我在大三上学期快要结束的时候便早早地”物色“各大公司的实习了，也是希望能在就业前增加几段实习经历，丰富一下经验。这也是人生中我的第一次面试，感触颇多。特别记录下来自己的总结以及对于假期自己的学习规划。</p>
<h2 id="面试总结">面试总结</h2>
<p>这次我面试的总共有三家公司，跟谁学、字节跳动和腾讯，对我印象最深也是帮助最大的就是”字节跳动“。关于面试的准备大致有三块，简历、技术口述和手撕代码，下面分开说。</p>
<h3 id="简历">简历</h3>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/image-20210103221551405.png" alt=""></p>
<p>我个人使用的简历大致是这样的风格，简约并且色调一致。简历这块我倒没什么卡壳，简历没过的 <strong>我猜</strong> 都是因为学历等等硬性条件不合适，这也是没有办法的事情。这里需要确保这么几点：</p>
<ul>
<li><strong>不要造假，实事求是</strong> 。虽然有的公司面试官根本不看你简历问（我的几次实习面试不看，校招社招应该是要看的），但是如果你写熟悉甚至精通，你躲过了 HR，但是人家面试官上来问了一个很简单的问题你答不上来，人家可能没兴趣继续问了。。在面试官心里你的这项技术等于没写，并且有了吹牛的成分，众所周知，搞技术的都不喜欢这种人。</li>
<li><strong>拿出有说服力的证据。</strong> 这一条不单指技术也包括其他方面，举个例子，如果你写了你优化了这个项目，那么等于没写，谁知道你优化了多少？比如原来服务器 CPU 总是跑到 90+%，然后你通过 xxx 手段优化，优化到了稳定在 <strong>70%</strong> 左右，这就比较有说服里，面试官也比较好针对你的这个点去问。再举个例子，你在个人相关那栏里写英语能力强，学习能力不错，热爱新技术，咱就不说过没过四六级了，人家让你现场看个技术文，获取跟你聊两句，你蒙蔽了，尴尬不。问你平时咋学习的，你磕磕巴巴说不出个所以然，或者一点逻辑没有，东一头看书，西一头看视频，再来一手看野生技术文章，你说尴尬不。</li>
<li><strong>注意行业基础。</strong> 我拿技术来说，搞技术的，你说你写了个热爱技术，结果写个 <code>GitHub</code> ，都能拼错，写成 <code>Github</code> 等等，写个 <code>CSDN</code> 写成 <code>Csdn</code> ，虽说这不是什么大事，但是这些书面东西，我们搞技术的不能犯错的，这给人的印象就是你很不专业，或者说你<strong>接触的很少以至于记不清楚</strong>。假如说你说热爱开源，整天 <code>GitHub</code> 排行榜逛个遍，你告诉我你不知道 <code>GitHub</code> 怎么拼，不合适吧？我曾经见过一个人说他懂这懂那，结果拿来简历一看，关于技术的名字错了好几个，还说自己热爱这些，实际水平也就可想而知了。</li>
</ul>
<p>我个人关于简历这块总结就是这样，虽然说简历很重要，但是我认为还是不难写的，把握好这些点即可 :)</p>
<h3 id="技术口述">技术口述</h3>
<p>这部分是面试重头戏，除去手撕代码部分其余就是这个了（还可能有项目环节），对于这部分我感触最多。大体是，以前我认为掌握一种技术就是会用来解决某个问题就完事了，不想探究怎么实现的。举个例子，现在需要有个从反序列化出来的 <code>json</code> 字节数组里拿某个字段的值，以前的我就是去找个库用用完事了，现在经过大厂面试洗礼的我是这样的：我能不能自己写一个，看他代码不多呀，这样写效率高不高？紧接着看了源代码之后就会惊叹：哇还能这么设计，哇这个还能这么用，厉害了。。。真实。。。</p>
<p>而实际面试里也是这样的，<strong>我们不能只考虑表现层面的东西，而要去探究其底层大致的实现原理，只有这样，当你遇到问题的时候才能有初步想法从而去解决，而不是只会去问别人</strong>。别人不告诉你或者怎样你就解决不了了，不是有那么一句话说得好嘛，好的工程师（注意不是程序员）并不是他写的代码多厉害，而是他遇到问题总是能快速定位问题，并以最优雅的方式去解决，这一点值得我们深思。<strong>学会用工程师的视角去解决问题也</strong>是我们每一个人的最终目标。</p>
<p>在面试过程中我也遇到了很多之前没考虑过的问题，举个例子，我写的 RPC 框架里，大的问题比如说 注册中心挂了怎么办？能不能自动通过 .proto 文件生成规范的并且与我们框架配合使用的 RPC 代码？小的问题比如说 底层用的 NIO，NIO是什么，为什么快等等。因为我这个框架说白了只在运输层以上工作，我只在运输层以上思考，也就是说只是应用层面理解了而已，只是更深一点点的应用层面罢了，所以当面试官问我一系列深层次的问题后，我的问题就暴露出来了：对这个框架没有进一步的思考和认识。所以这也是我接下来要去思考和改进的一个点。项目大致都是如此，比如你写了一个 Web 类型的项目，用到了某某框架、技术或者标准库，你就要思考为什么它很好？好在哪了？我个人对它有优化吗？我实际上做了什么事情呢？我能从哪些方面提高它的并发量或者说是功能技术创新呢？</p>
<p>总结来说就是项目<strong>要有一定规模</strong>，<strong>有一定自己的思考</strong>在里面，别人问你关于你项目的特色，你的工作点，你<strong>都有的说</strong>。</p>
<h2 id="假期规划">假期规划</h2>
]]></content>
		</item>
		
		<item>
			<title>手写一个RPCg（上）</title>
			<link>https://www.kcode.icu/posts/rpc/rpcg/</link>
			<pubDate>Sat, 28 Nov 2020 15:45:13 +0000</pubDate>
			
			<guid>https://www.kcode.icu/posts/rpc/rpcg/</guid>
			<description>须知 可能看到这里的一部分人还不知道什么是 RPC，也不知道为什么要用 RPC，内心：HTTP不香吗？那么你需要首先看一下这篇文章：
 你觉得HTTP哪都好用是因为你不知道RPC
 已经实现的 这篇文章我会带你手写一个简易版本的 RPC 框架，这个框架会支持如下这些功能：
 多种网络传输方式 服务端自动注册可导出服务 可以心跳保活的注册中心 服务注册与服务发现 多种序列化方式 超时控制 一些负载均衡策略，一致性哈希、平滑带权轮询等  未来需要做的   自定义的代码生成插件
  一种压缩方式
  基于服务器时延的负载均衡策略？
  心里有数 ”切忌重复造轮子“这句话你应该听过，不过这个”框架“的目的是带领我们大致了解 RPC 框架的工作过程，目标并不是工业级应用，我想你也一定清楚用框架和自己写框架对框架的理解程度有什么区别。也不必把 RPC 想成多么”高端“的技术，RPC 也只是一个调用，微服务的一个组件，从小的地方出发更容易让人接受罢了。好了，话不多说，让我们正式开始。
俯瞰RPCg 这个图向我们展示了最基本的 RPC 调用关系：服务端将自己的服务注册到注册中心，客户端从注册中心获取所有服务端的所有信息，在拿到这些信息之后带着自己的请求去访问某个服务端的服务。你可能会问为什么要多个”第三者“注册中心出来呢，我直接就只有客户端和服务端多方便，那你需要思考以下问题：
 直接通信是不是需要将通信的地址等服务端信息硬编码到客户端的代码中？如果服务端节点数改变了怎么办，难道手动删改代码？ 客户端怎么知道服务端可不可用？难道需要服务端开个服务专门去处理这类信息吗？这属于服务端的业务吗？ &amp;hellip;&amp;hellip;  我想你应该大致能明白为什么需要这个注册中心了，就是屏蔽对方对己方的感知，通过一个第三方中介来提供/提出自己的服务/需求，这就够了，你可以类比 房产中介，婚介所等等机构，当然，注册中心还有很多功能，我们这里为了学习，就只提供这部分功能了，更多的需要留给你去探索 :)
我们再想想，我们现在有了三个主体，之前有不同的需求，怎么提供通信。业界有非常多的解决方法，比如 gRPC 的 HTTP/2.0，它的优势也是显而易见的：多路复用，pipelining 的通信方式，效率大幅提高，不必在等待对方的回复；首部压缩，这里我需要说明一下，RPC 调用大部分是服务端内部的互相调用，比如公司机房里 50 台机器之间相互调用，需要保证传输的效率，也就是说传送的数据要尽可能地小，这才有了 Protocol Buffers 的数据格式，所以经过压缩的首部数据量更小，效率更高。还有 tcp 连接，优势是简单等等。
等待更新&amp;hellip;&amp;hellip;.</description>
			<content type="html"><![CDATA[<h1 id="须知">须知</h1>
<p>可能看到这里的一部分人还不知道什么是 RPC，也不知道为什么要用 RPC，内心：HTTP不香吗？那么你需要首先看一下这篇文章：</p>
<blockquote>
<p><a href="">你觉得HTTP哪都好用是因为你不知道RPC</a></p>
</blockquote>
<h2 id="已经实现的">已经实现的</h2>
<p>这篇文章我会带你手写一个简易版本的 RPC 框架，这个框架会支持如下这些功能：</p>
<ul>
<li>多种网络传输方式</li>
<li>服务端自动注册可导出服务</li>
<li>可以心跳保活的注册中心</li>
<li>服务注册与服务发现</li>
<li>多种序列化方式</li>
<li>超时控制</li>
<li>一些负载均衡策略，一致性哈希、平滑带权轮询等</li>
</ul>
<h2 id="未来需要做的">未来需要做的</h2>
<ul>
<li>
<p>自定义的代码生成插件</p>
</li>
<li>
<p>一种压缩方式</p>
</li>
<li>
<p>基于服务器时延的负载均衡策略？</p>
</li>
</ul>
<h2 id="心里有数">心里有数</h2>
<p>”切忌重复造轮子“这句话你应该听过，不过这个”框架“的目的是带领我们大致了解 RPC 框架的工作过程，目标并不是工业级应用，我想你也一定清楚用框架和自己写框架对框架的理解程度有什么区别。也不必把 RPC 想成多么”高端“的技术，RPC 也只是一个调用，微服务的一个组件，从小的地方出发更容易让人接受罢了。好了，话不多说，让我们正式开始。</p>
<h1 id="俯瞰rpcg">俯瞰RPCg</h1>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/2C28140D4115AF68D708DAB4515B012C.jpg" alt="img"></p>
<p>这个图向我们展示了最基本的 RPC 调用关系：服务端将自己的服务注册到注册中心，客户端从注册中心获取所有服务端的所有信息，在拿到这些信息之后带着自己的请求去访问某个服务端的服务。你可能会问为什么要多个”第三者“注册中心出来呢，我直接就只有客户端和服务端多方便，那你需要思考以下问题：</p>
<ul>
<li>直接通信是不是需要将通信的地址等服务端信息硬编码到客户端的代码中？如果服务端节点数改变了怎么办，难道手动删改代码？</li>
<li>客户端怎么知道服务端可不可用？难道需要服务端开个服务专门去处理这类信息吗？这属于服务端的业务吗？</li>
<li>&hellip;&hellip;</li>
</ul>
<p>我想你应该大致能明白为什么需要这个注册中心了，就是屏蔽对方对己方的感知，通过一个第三方中介来提供/提出自己的服务/需求，这就够了，你可以类比 房产中介，婚介所等等机构，当然，注册中心还有很多功能，我们这里为了学习，就只提供这部分功能了，更多的需要留给你去探索 :)</p>
<p>我们再想想，我们现在有了三个主体，之前有不同的需求，怎么提供通信。业界有非常多的解决方法，比如 gRPC 的 HTTP/2.0，它的优势也是显而易见的：多路复用，pipelining 的通信方式，效率大幅提高，不必在等待对方的回复；首部压缩，这里我需要说明一下，RPC 调用大部分是服务端内部的互相调用，比如公司机房里 50 台机器之间相互调用，需要保证传输的效率，也就是说传送的数据要尽可能地小，这才有了 Protocol Buffers 的数据格式，所以经过压缩的首部数据量更小，效率更高。还有 tcp 连接，优势是简单等等。</p>
<p>等待更新&hellip;&hellip;.</p>
]]></content>
		</item>
		
		<item>
			<title>你觉得HTTP最香是因为你还不知道RPC</title>
			<link>https://www.kcode.icu/posts/rpc/rpcvshttp/</link>
			<pubDate>Tue, 10 Nov 2020 21:30:13 +0000</pubDate>
			
			<guid>https://www.kcode.icu/posts/rpc/rpcvshttp/</guid>
			<description>我在动手写 RPCg 这个”框架“之前看了大量的文章阐述 RPC 与 HTTP，这篇文章是比较不错的一篇，我翻译过来和你分享一下 :)
REST vs. RPC你要使用API去解决什么问题？ 有一则关于这个农民的笑话，他被问到”为什么他要尽量避免耕种出‘童话环’的形状“，他回答道，”因为如果我不那么做，我就会变成傻子“。（第一段的引用故事可暂时不关注）。
许多人关于他们自己构建的 APIs 会说同样的话，事实上，去思考一下你要用你的 APIs 去解决什么问题这非常重要，因为你所创建的 API 的风格和你所使用的技术都依赖于你上面的回答。
根据调用 自从 FORTRAN Ⅱ 在1958 年提出调用（也叫函数）这个概念，函数（调用）就一直是组织计算机代码的主要结构。所有现在主流被用来构建和使用 API 的编程语言例如 Java,Javascript, Python, Golang, C/C++ 和 PHP 都使用调用（也就是函数）来作为他们的主要组织结构。因此这数十年来”函数调用“以远程过程调用（RPC） 的形式称为设计和实现分布式 API 的主要模型也就不足为奇了。
如果你要问大多数软件开发者为什么要定义和构建 API，他们可能会解释说他们有个应用，它需要实现多个分布式组件，并且这些组件之间可以互相调用，来使整个应用程序正常运行。他们也可能说需要实现由多个应用程序使用的服务 API。</description>
			<content type="html"><![CDATA[<p>我在动手写 RPCg 这个”框架“之前看了大量的文章阐述 RPC 与 HTTP，这篇文章是比较不错的一篇，我翻译过来和你分享一下 :)</p>
<h2 id="rest-vs-rpc你要使用api去解决什么问题">REST vs. RPC你要使用API去解决什么问题？</h2>
<p>有一则关于这个农民的笑话，他被问到”为什么他要尽量避免耕种出‘童话环’的形状“，他回答道，”因为如果我不那么做，我就会变成傻子“。（第一段的引用故事可暂时不关注）。</p>
<p>许多人关于他们自己构建的 APIs 会说同样的话，事实上，去思考一下你要用你的 APIs 去解决什么问题这非常重要，因为你所创建的 API 的风格和你所使用的技术都依赖于你上面的回答。</p>
<h2 id="根据调用">根据调用</h2>
<p>自从 FORTRAN Ⅱ 在1958 年提出调用（也叫函数）这个概念，函数（调用）就一直是组织计算机代码的主要结构。所有现在主流被用来构建和使用 API 的编程语言例如 Java,Javascript, Python, Golang, C/C++ 和 PHP 都使用调用（也就是函数）来作为他们的主要组织结构。因此这数十年来”函数调用“以远程过程调用（RPC） 的形式称为设计和实现分布式 API 的主要模型也就不足为奇了。</p>
<p>如果你要问大多数软件开发者为什么要定义和构建 API，他们可能会解释说他们有个应用，它需要实现多个分布式组件，并且这些组件之间可以互相调用，来使整个应用程序正常运行。他们也可能说需要实现由多个应用程序使用的服务 API。</p>
]]></content>
		</item>
		
		<item>
			<title>Linux du/df命令总结</title>
			<link>https://www.kcode.icu/posts/chore/linux_df_du/</link>
			<pubDate>Wed, 04 Nov 2020 18:15:13 +0000</pubDate>
			
			<guid>https://www.kcode.icu/posts/chore/linux_df_du/</guid>
			<description>linux 在我们日常学习中用的非常多，连接远程 linux 服务器，使用各种 linux 命令，或者物理机就是 linux 系统或者 MacOS。如果你想要学习进阶知识，linux 已经是必不可少的一个组件了。这篇博客记录一下 linux 下常被混淆的 du/df 命令。
df df 就是 “disk free” 的缩写，一般是用来快速浏览你的文件系统，会显示所有磁盘的大小，使用空间，剩余空间，使用百分比还有磁盘挂载到哪个分区上了。使用的时候一般要带上 -h 参数来增加可读性。这些数据都是从挂载点或者文件系统级别计算出来的，比较 “宏观”。
而且，-h 标记会使你的数据四舍五入更方便显示，比如它显示 3G 的大小，实际上可能是 2.9G 或者 3.1G，并不确定。
du du 就是 “disk usage” 的缩写，如果你需要计算某个特定目录大小的时候非常好用。一般搭配 -sh 参数让结果更易读，比如这样：
df VS. du 看了这两个命令大致用法后，它们在使用场景是什么呢，众所周知不结合使用场景的技术都是耍流氓。大致可以这样总结：df 命令提供一个关于你整个文件系统的概览，比如你多少空间正在使用等等，du 命令更倾向于计算某个目录的精确快照。
如果非要说哪个的结果更有用一点，我觉得是 du。举个例子，我在 /var 目录下安装一个第三方包时遇到了一个目录空间不足的错误，那么我就可以先跑一下 df 命令去看看这个目录的空间来确认一下这是不是真的。我如果看到 /var 有足够空间，那我会接着跑一下 du /var 去看看是它的哪个子目录因为空间不够报的错。这样我就可以一直通过 df  去缩小出错目录的范围，直到找到问题。
理解这些命令的区别能让我们串联使用这些工具，从而更快的定位并解决我们所面临的绝大多数的问题。</description>
			<content type="html"><![CDATA[<p>linux 在我们日常学习中用的非常多，连接远程 linux 服务器，使用各种 linux 命令，或者物理机就是 linux 系统或者 MacOS。如果你想要学习进阶知识，linux 已经是必不可少的一个组件了。这篇博客记录一下 linux 下常被混淆的 du/df 命令。</p>
<h2 id="df">df</h2>
<p>df 就是 “disk free” 的缩写，一般是用来快速浏览你的文件系统，会显示所有磁盘的大小，使用空间，剩余空间，使用百分比还有磁盘挂载到哪个分区上了。使用的时候一般要带上 <code>-h</code> 参数来增加可读性。这些数据都是从挂载点或者文件系统级别计算出来的，比较 “宏观”。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/sh.png" alt="df -h"></p>
<p>而且，<code>-h</code> 标记会使你的数据四舍五入更方便显示，比如它显示 3G 的大小，实际上可能是 2.9G 或者  3.1G，并不确定。</p>
<h2 id="du">du</h2>
<p>du 就是 “disk usage” 的缩写，如果你需要计算某个特定目录大小的时候非常好用。一般搭配 <code>-sh</code> 参数让结果更易读，比如这样：</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/du.png" alt="du"></p>
<h2 id="df-vs-du">df VS. du</h2>
<p>看了这两个命令大致用法后，它们在使用场景是什么呢，众所周知不结合使用场景的技术都是耍流氓。大致可以这样总结：<code>df</code> 命令提供一个关于你整个文件系统的概览，比如你多少空间正在使用等等，<code>du</code> 命令更倾向于计算某个目录的精确快照。</p>
<p>如果非要说哪个的结果更有用一点，我觉得是 <code>du</code>。举个例子，我在 <code>/var</code> 目录下安装一个第三方包时遇到了一个目录空间不足的错误，那么我就可以先跑一下 <code>df</code> 命令去看看这个目录的空间来确认一下这是不是真的。我如果看到 <code>/var</code> 有足够空间，那我会接着跑一下 <code>du /var</code> 去看看是它的哪个子目录因为空间不够报的错。这样我就可以一直通过 <code>df </code> 去缩小出错目录的范围，直到找到问题。</p>
<p>理解这些命令的区别能让我们串联使用这些工具，从而更快的定位并解决我们所面临的绝大多数的问题。</p>
]]></content>
		</item>
		
		<item>
			<title>一文搞懂ASCII、Unicode和UTF</title>
			<link>https://www.kcode.icu/posts/ascii-unicode-utf/</link>
			<pubDate>Fri, 18 Sep 2020 09:27:13 +0000</pubDate>
			
			<guid>https://www.kcode.icu/posts/ascii-unicode-utf/</guid>
			<description>起因 最初在学习 Go 语言的各种类型时发现内置字符类型有两种类型，一种是 byte（1 字节表示一个 ASCII 字符），还有一个就是 rune 类型，可能从其他语言转过来的开发者都会对 rune 觉得非常陌生，我自己也是仅仅停留在会用的阶段上，久而久之就会特别乱，所以写一篇博客介绍一下各种字符以及编码方便彼此学习，彻底解决这类问题。
什么是ASCII，为什么又要引入Unicode 都应该了解过 ASCII、Unicode、Unicode 码点、UTF-8等一系列名词。先说 ASCII（American Standard Code for Information Interchange: 美国信息交换标准代码），它是一种字符集，说白了就是一个字符和数字的一一对应关系，你想找这个字符怎么办，计算机又不认识字符？给出他的对应的数字就行了。最初只有美国等一些使用英文的国家使用，所以 128 个字符完全够用，它包含了标点符号、数字和字母等。但是随着世界上使用计算机的国家越来越多，这 128 个字符是完全不够用的。所以 Unicode 字符集 就出现了。Unicode 包含了世界上绝大多数的字符，给他们提供了一一对应关系，比如“知”字对应 30693，即 U+77e5（16 进制形式）。所以说白了 ASCII 和 Unicode 就是一种字符集，一种字符对应关系，Unicode 中每个字符被称为一个 Code Point（码点），而 Go 语言中的 rune 类型正是代表了这样一个单位，即一个 rune 代表了一个 unicode 字符。
那么大家肯定都听说过 UTF-8，UTF-16 吧，那问题来了， UTF 又是什么呢，UTF-8 和 UTF-16 到底又有什么关系呢？
UTF（Unicode Transformation Format） 从字面上你就应该能看出来，这就是一个 Unicode 转换格式。什么是转换格式，为什么需要转换格式？上文说了 Unicode 就是提供了字符间的一一对应关系，比如“知”对应了 30693，那计算机怎么表示这个数（计算机只认识二进制）？它要做到：
在很长的文本中准确获取到每个字符，不能找错 **Unicode 表示一个字符可以使用 1 - 4 个字节。**它的转换规则如下：</description>
			<content type="html"><![CDATA[<h2 id="起因">起因</h2>
<p>最初在学习 Go 语言的各种类型时发现内置字符类型有两种类型，一种是 byte（1 字节表示一个 ASCII 字符），还有一个就是 rune 类型，可能从其他语言转过来的开发者都会对 rune 觉得非常陌生，我自己也是仅仅停留在<strong>会用</strong>的阶段上，久而久之就会特别乱，所以写一篇博客介绍一下各种字符以及编码方便彼此学习，彻底解决这类问题。</p>
<h2 id="什么是ascii为什么又要引入unicode">什么是ASCII，为什么又要引入Unicode</h2>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/ascii.png" alt="image"></p>
<p>都应该了解过 ASCII、Unicode、Unicode 码点、UTF-8等一系列名词。先说 ASCII（American Standard Code for Information Interchange: 美国信息交换标准代码），它是一种<strong>字符集</strong>，说白了就是一个字符和数字的<strong>一一对应关系</strong>，你想找这个字符怎么办，计算机又不认识字符？给出他的对应的数字就行了。最初只有美国等一些使用英文的国家使用，所以 128 个字符完全够用，它包含了标点符号、数字和字母等。但是随着世界上使用计算机的国家越来越多，这 128 个字符是完全不够用的。所以 <strong>Unicode 字符集</strong> 就出现了。Unicode 包含了世界上绝大多数的字符，给他们提供了一一对应关系，比如“知”字对应 30693，即 U+77e5（16 进制形式）。所以说白了 ASCII 和 Unicode 就是<strong>一种字符集</strong>，<strong>一种字符对应关系</strong>，Unicode 中每个字符被称为一个 <strong>Code Point</strong>（码点），而 Go 语言中的 rune 类型正是代表了这样一个单位，即一个 rune 代表了一个 unicode 字符。</p>
<p>那么大家肯定都听说过 UTF-8，UTF-16 吧，那问题来了， UTF 又是什么呢，UTF-8 和 UTF-16 到底又有什么关系呢？</p>
<h2 id="utfunicode-transformation-format">UTF（Unicode Transformation Format）</h2>
<p>从字面上你就应该能看出来，这就是一个 Unicode 转换格式。什么是转换格式，为什么需要转换格式？上文说了 Unicode 就是提供了字符间的一一对应关系，比如“知”对应了 30693，那计算机怎么表示这个数（计算机只认识二进制）？它要做到：</p>
<pre><code>在很长的文本中准确获取到每个字符，不能找错
</code></pre><p>**Unicode 表示一个字符可以使用 1 - 4 个字节。**它的转换规则如下：</p>
<table>
<thead>
<tr>
<th>1 字节</th>
<th>0xxxxxxx</th>
</tr>
</thead>
<tbody>
<tr>
<td>2 字节</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>3 字节</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>4 字节</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody>
</table>
<p>解释：如果它表示一个字符只需要 1 个字节，那么表示的就是 ASCII 字符集，从0 -&gt; 127。如果需要 2 个及以上字节表示，那么<strong>第一个字节的前 n 位是 1 ，第 n+1 位是 0，后面每个字节的前两位均为 10（n 是所需字节数）。</strong></p>
<p>所以按照上述规则，“知”字的二进制为：</p>
<pre><code>30693（十进制） -&gt; U+77E5(十六进制) -&gt; 0111 0111 1110 0101（二进制）
</code></pre><p>所以对应的 UTF-8 编码为：<strong>1110</strong>0111 <strong>10</strong>011111 <strong>10</strong>100101，你只需要从低位到高位依次按规则填充即可。</p>
<p>看到这里，我想有思考的读者应该有疑问，为什么原本只需要两字节就能表示的字经过 UTF-8 转换后需要三个字节了，这不是白白地增加内存消耗吗？你可以回忆一下哈夫曼编码的构建结果：将长短不同的<strong>二进制位段</strong>直接放在一起却不会读错，是因为他们没有共同前缀。这里的原理类似，要解决地问题是 <strong>怎么确保长短不同的字符不会重合</strong>。由于有的字符只需要一个字节，而有的需要两个，三个，n 个。当他们堆放在一起时，怎么保证不会出现读少，读多？</p>
<p>解释这个问题，我举个例子，“你”字<strong>假设</strong>表示的十六进制是 A，“我”是 B，“你我”是 AA，“好”是 AB，那我将“你好”放一起时表示就是 AAB，它为什么不是“你你我”，或者“你我我”？</p>
<p>我相信如果你看懂了这个例子，应该就能明白为什么 UTF-8 被称为变长编码了。</p>
<p>这段的标题是 UTF，上面只说了 UTF-8，其实常用的还有 UTF-16，UTF-8 是将一个字节作为一个单位，随着所需字节数量的不同给他们不同的前缀，当计算机读到第一个字节时，通过判断前面连续 1 的个数就能判断未来多少位属于这个字符的范围,，从而解决了不会读错的问题。而 UTF-16 是<strong>将两个字节作为了一个单位</strong>。原理类似，有兴趣的读者可以自己再去探索，我相信你会有更多的发现 :)</p>
<h2 id="验证结果梳理思路">验证结果，梳理思路</h2>
<p>我们可以写一个简单的 Go 语言程序来验证这个结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
 <span class="nx">str</span> <span class="o">:=</span> <span class="s">&#34;hello,狗狼&#34;</span>
 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">str</span><span class="p">))</span>
 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">([]</span><span class="nb">rune</span><span class="p">(</span><span class="nx">str</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre></div><p>输出结果为：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="m">12</span>
<span class="m">8</span>

Process finished with <span class="nb">exit</span> code <span class="m">0</span>
</code></pre></div><p>这里需要说明的是，str 字符串的底层实现就是一个字节数组，根据上面所说的汉字占用 3 个字节，总字节长度为 6+3+3=12，而转换为 rune 类型后，所有字符都占用一个 Unicode <strong>Code Point</strong>（码点），所以占用了共 8 个字符，共 8 个码点。</p>
<p>综上所述，ASCII 和 Unicode 都是一种字符集，代表了字符与数字间的一一对应关系。而 UTF 是一种变长的字符编码规范。而 rune 是 Go 语言中的一个变量类型，一个 rune 代表了一个 Unicode 码点单位。以上。</p>
<p>因个人能力有限，有疏漏之处欢迎和我交流 :)</p>
]]></content>
		</item>
		
		<item>
			<title>OBS显示器捕获黑屏解决方案</title>
			<link>https://www.kcode.icu/posts/chore/obs/</link>
			<pubDate>Sun, 26 Apr 2020 11:34:13 +0000</pubDate>
			
			<guid>https://www.kcode.icu/posts/chore/obs/</guid>
			<description>问题起因 由于我最近重新安装了系统，在重新下载 OBS 后发现捕获不到桌面。我之前解决方法就是直接在显卡控制面板里将 OBS 设置为集显就行了。但是这次设置了也不行，有可能是我下载的显卡驱动版本不对。。于是就找到了这个终极解决方案，基本电脑上有这个功能的都能解决。
问题环境 操作系统：Win10 64位 专业版 - 1909
CPU 集成显卡型号：Inter(R) UHD Graphics 630
独立显卡型号：NVIDIA GeForce GTX 1050
OBS 版本：25.0.4(64 bit)
 注：配置和我不一样也有可能解决，不用纠结
 问题描述 在来源中添加显示器捕获后 ，是黑屏，无法捕获到显示器。
问题分析 目前网上能搜集到的解决方案大部分是以下几种：
 右键 OBS 属性 - 兼容性 - 兼容模式 - 以兼容模式运行这个程序（win7）设置 - 以管理员方式运行 桌面上右键打开 NVIDIA 控制面板，管理 3D 设置 - 程序设置，找到 OBS，设置为集成图形。  但是我都试了都解决不了，我就去搜了一下问题的原因，最终发现 OBS 只能捕捉到和自己跟自己使用相同显卡的应用，然后我右键打开任务管理器，发现笔记本桌面使用的是我的集显。所以就需要把 OBS 设置为应用集显。
解决方法 左下角开始按钮 - 设置 - 系统 - 显示 - 图形设置 - 经典应用里浏览添加 OBS ，点击选项，设置为节能，节能就是使用集显。然后你再打开 OBS&amp;hellip;&amp;hellip;</description>
			<content type="html"><![CDATA[<h2 id="问题起因">问题起因</h2>
<p>由于我最近重新安装了系统，在重新下载 OBS 后发现捕获不到桌面。我之前解决方法就是直接在<strong>显卡控制面板</strong>里将 OBS 设置为集显就行了。但是这次设置了也不行，有可能是我下载的显卡驱动版本不对。。于是就找到了这个终极解决方案，基本电脑上有这个功能的都能解决。</p>
<h2 id="问题环境">问题环境</h2>
<p>操作系统：Win10 64位 专业版 - 1909</p>
<p>CPU 集成显卡型号：Inter(R) UHD Graphics 630</p>
<p>独立显卡型号：NVIDIA GeForce GTX 1050</p>
<p>OBS 版本：25.0.4(64 bit)</p>
<blockquote>
<p>注：配置和我不一样也有可能解决，不用纠结</p>
</blockquote>
<h2 id="问题描述">问题描述</h2>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/obs-noscreen.png" alt=""></p>
<p>在来源中添加<strong>显示器捕获后</strong> ，是黑屏，<strong>无法捕获到显示器</strong>。</p>
<h2 id="问题分析">问题分析</h2>
<p>目前网上能搜集到的解决方案大部分是以下几种：</p>
<ul>
<li>右键 OBS 属性 - 兼容性 - 兼容模式 - 以兼容模式运行这个程序（win7）设置 -  以管理员方式运行</li>
<li>桌面上右键打开 NVIDIA 控制面板，管理 3D 设置 - 程序设置，找到 OBS，设置为集成图形。</li>
</ul>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/obs-gpu.png" alt="任务管理器最下面"></p>
<p>但是我都试了都解决不了，我就去搜了一下问题的原因，<strong>最终</strong>发现 OBS <strong>只能捕捉到和自己跟自己使用相同显卡的应用</strong>，然后我右键打开任务管理器，发现笔记本桌面使用的是我的集显。所以就需要把 OBS 设置为应用集显。</p>
<h2 id="解决方法">解决方法</h2>
<p><!-- raw HTML omitted --></p>
<p>左下角开始按钮 - 设置 - 系统 - 显示 - 图形设置 - 经典应用里浏览添加 OBS ，点击选项，设置为节能，节能就是使用集显。然后你再打开 OBS&hellip;&hellip;</p>
<p>这时候你就会发现你成功了。</p>
<p>其他的推流软件也一样，比如什么 B 站直播姬等同理。</p>
<p>以上。</p>
]]></content>
		</item>
		
		<item>
			<title>B站直播助手开发[下]</title>
			<link>https://www.kcode.icu/posts/b%E7%AB%99%E7%9B%B4%E6%92%AD%E5%8A%A9%E6%89%8B%E5%BC%80%E5%8F%91%E4%B8%8B/</link>
			<pubDate>Fri, 13 Mar 2020 13:22:23 +0000</pubDate>
			
			<guid>https://www.kcode.icu/posts/b%E7%AB%99%E7%9B%B4%E6%92%AD%E5%8A%A9%E6%89%8B%E5%BC%80%E5%8F%91%E4%B8%8B/</guid>
			<description>Go + QML 结合上节的分析，开发的思路的大致流程我画了个图，大概是这样：
 因为是需要面向用户的，又考虑到 Go 语言的特殊性（可以直接调用 C/C++ 代码，GUI 官方不支持），最后决定使用 Qml 来呈现前端，与 Go 语言利用插槽和信号进行通信。
 处理思路是创建一个协程池来处理不同类型的包数据。判断每个包内所有子包类型，将接收的未处理的字节数组直接送入对应协程池中的管道。因为代码也比较简单，就是简单的 WebSocket 通信。
// 客户端实例 type Client struct { RoomID uint32	// 房间 ID 	Online uint32	// 用来判断人气是否变动 	Conn *websocket.Conn	// 连接后的对象 	IsConnected bool } // 使用了&amp;#34;github.com/gorilla/websocket&amp;#34;这个包，也可以自己升级 tcp 到 websocket u := url.URL{Scheme: &amp;#34;wss&amp;#34;, Host: DanMuServer, Path: &amp;#34;/sub&amp;#34;,} conn, _, err := websocket.DefaultDialer.Dial(u.String(), nil) if err != nil { return nil, err } // 发送包函数 func SendPackage(conn *websocket.</description>
			<content type="html"><![CDATA[<h1 id="go--qml">Go + QML</h1>
<p>结合上节的分析，开发的思路的大致流程我画了个图，大概是这样：</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/go_qml_flowchart.png" alt="流程图"></p>
<blockquote>
<p>因为是需要面向用户的，又考虑到 Go 语言的特殊性（可以直接调用 C/C++ 代码，GUI 官方不支持），最后决定使用 Qml 来呈现前端，与 Go 语言利用插槽和信号进行通信。</p>
</blockquote>
<p>处理思路是创建一个协程池来处理不同类型的包数据。判断每个包内所有子包类型，将接收的未处理的字节数组直接送入对应协程池中的管道。因为代码也比较简单，就是简单的 WebSocket 通信。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 客户端实例
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Client</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">RoomID</span>      <span class="kt">uint32</span>				<span class="c1">// 房间 ID
</span><span class="c1"></span>	<span class="nx">Online</span>      <span class="kt">uint32</span>				<span class="c1">// 用来判断人气是否变动
</span><span class="c1"></span>	<span class="nx">Conn</span>        <span class="o">*</span><span class="nx">websocket</span><span class="p">.</span><span class="nx">Conn</span>		<span class="c1">// 连接后的对象
</span><span class="c1"></span>	<span class="nx">IsConnected</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 使用了&#34;github.com/gorilla/websocket&#34;这个包，也可以自己升级 tcp 到 websocket
</span><span class="c1"></span><span class="nx">u</span> <span class="o">:=</span> <span class="nx">url</span><span class="p">.</span><span class="nx">URL</span><span class="p">{</span><span class="nx">Scheme</span><span class="p">:</span> <span class="s">&#34;wss&#34;</span><span class="p">,</span> <span class="nx">Host</span><span class="p">:</span> <span class="nx">DanMuServer</span><span class="p">,</span> <span class="nx">Path</span><span class="p">:</span> <span class="s">&#34;/sub&#34;</span><span class="p">,}</span>
<span class="nx">conn</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">websocket</span><span class="p">.</span><span class="nx">DefaultDialer</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="nx">u</span><span class="p">.</span><span class="nf">String</span><span class="p">(),</span> <span class="kc">nil</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="c1">// 发送包函数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">SendPackage</span><span class="p">(</span><span class="nx">conn</span> <span class="o">*</span><span class="nx">websocket</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">packetlen</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">magic</span> <span class="kt">uint16</span><span class="p">,</span> <span class="nx">ver</span> <span class="kt">uint16</span><span class="p">,</span> <span class="nx">typeID</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">param</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">packetHead</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">packetlen</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">packetlen</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="o">+</span> <span class="mi">16</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">pdata</span> <span class="p">=</span> <span class="p">[]</span><span class="kd">interface</span><span class="p">{}{</span>
		<span class="nx">packetlen</span><span class="p">,</span>
		<span class="nx">magic</span><span class="p">,</span>
		<span class="nx">ver</span><span class="p">,</span>
		<span class="nx">typeID</span><span class="p">,</span>
		<span class="nx">param</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="c1">// 将包的头部信息以大端序，二进制形式写入字节数组
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pdata</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">binary</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">packetHead</span><span class="p">,</span> <span class="nx">binary</span><span class="p">.</span><span class="nx">BigEndian</span><span class="p">,</span> <span class="nx">v</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 将包内数据部分追加到数据包内
</span><span class="c1"></span>	<span class="nx">sendData</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">packetHead</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">(),</span> <span class="nx">data</span><span class="o">...</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">WriteMessage</span><span class="p">(</span><span class="nx">websocket</span><span class="p">.</span><span class="nx">BinaryMessage</span><span class="p">,</span> <span class="nx">sendData</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// fmt.Println(&#34;c.conn.Write err: &#34;, err)
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div><p>拼接 URL 是使用的官方提供的 url 包，发送包数据要注意的是发送的是二进制数据流，所以要用 binary.Write 以二进制，且在网络上传输是大端序方式写入字节数组。</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/up.png" alt="心跳包上行"></p>
<p>心跳包上行是通过发送两个空的对象，所以我把这个固定的数直接粘贴下来转为字节数组后，创建一个 go 协程，按照每 30 秒一次的时间间隔发送就好。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Client</span><span class="p">)</span> <span class="nf">HeartBeat</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">IsConnected</span> <span class="p">{</span>
			<span class="nx">obj</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;5b6f626a656374204f626a6563745d&#34;</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">util</span><span class="p">.</span><span class="nf">SendPackage</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">obj</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
            <span class="c1">// 每 30 秒发一次
</span><span class="c1"></span>			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">30</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>心跳包下行是还是一个固定的包首部，只携带了一个 4 字节大小的实体就是直播间人气值，所以我只需要每次和 c.Online 进行比较，及时修改人气数就可以了。</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/down.png" alt="心跳包下行"></p>
<p>最后一个问题就是<strong>对每个包的所有子包依次进行判断，防止信息量过大的时候有漏掉的情况</strong>，思路是读取完第一个包后，根据第一个包的大小找到第二个包的偏移位置继续读取，直到达到末尾，里面的<code>ByteArrToDecimal</code>是自己写的一个将读取到的十进制字节数组转换为十进制表示数的方法函数，也附带在下方了，如果有更好的实现可以告诉我，我也是自己脑洞大开临时写的&hellip;.有可能有更简单的实现。。。。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">inflated</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
	<span class="nx">l</span> <span class="o">:=</span> <span class="nx">util</span><span class="p">.</span><span class="nf">ByteArrToDecimal</span><span class="p">(</span><span class="nx">inflated</span><span class="p">[:</span><span class="mi">4</span><span class="p">])</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">inflated</span><span class="p">[</span><span class="mi">16</span><span class="p">:</span><span class="nx">l</span><span class="p">],</span> <span class="s">&#34;cmd&#34;</span><span class="p">).</span><span class="nf">ToString</span><span class="p">()</span>
	<span class="k">switch</span> <span class="nx">c</span> <span class="p">{</span>
		<span class="k">case</span> <span class="s">&#34;DANMU_MSG&#34;</span><span class="p">:</span>
			<span class="nx">p</span><span class="p">.</span><span class="nx">DanmuSrc</span> <span class="o">&lt;-</span> <span class="nb">string</span><span class="p">(</span><span class="nx">inflated</span><span class="p">[</span><span class="mi">16</span><span class="p">:</span><span class="nx">l</span><span class="p">])</span>
		<span class="k">case</span> <span class="s">&#34;SEND_GIFT&#34;</span><span class="p">:</span>
			<span class="nx">p</span><span class="p">.</span><span class="nx">GiftSrc</span> <span class="o">&lt;-</span> <span class="nb">string</span><span class="p">(</span><span class="nx">inflated</span><span class="p">[</span><span class="mi">16</span><span class="p">:</span><span class="nx">l</span><span class="p">])</span>
		<span class="k">case</span> <span class="s">&#34;WELCOME&#34;</span><span class="p">,</span> <span class="s">&#34;WELCOME_GUARD&#34;</span><span class="p">:</span>
			<span class="nx">p</span><span class="p">.</span><span class="nx">WelCome</span> <span class="o">&lt;-</span> <span class="nb">string</span><span class="p">(</span><span class="nx">inflated</span><span class="p">[</span><span class="mi">16</span><span class="p">:</span><span class="nx">l</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="nx">inflated</span> <span class="p">=</span> <span class="nx">inflated</span><span class="p">[</span><span class="nx">l</span><span class="p">:]</span>
<span class="p">}</span>

<span class="c1">// 返回十六进制字节数组表示数的十进制形式
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">ByteArrToDecimal</span><span class="p">(</span><span class="nx">src</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">sum</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">src</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>
    <span class="c1">// 将读取的十进制字节数组数据编码为字符串，再转换为字节数组，方便后续进行逐字节处理
</span><span class="c1"></span>	<span class="nx">b</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">hex</span><span class="p">.</span><span class="nf">EncodeToString</span><span class="p">(</span><span class="nx">src</span><span class="p">))</span>
	<span class="nx">l</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
    <span class="c1">// 从低位开始
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">base</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Pow</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">l</span><span class="o">-</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
		<span class="kd">var</span> <span class="nx">mul</span> <span class="kt">int</span>
		<span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">97</span> <span class="p">{</span>
			<span class="nx">mul</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">-</span> <span class="mi">87</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">mul</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">-</span> <span class="mi">48</span>
		<span class="p">}</span>

		<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">base</span> <span class="o">*</span> <span class="nx">mul</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div><p>其余的与 Qml 进行通信的第三方包用的是 qamel，也可以使用比较广泛，功能大而全的 therecipe/qt ，是因为这个库比较小巧，安装使用简单，所以采用了这个。通信部分非常简单，就是使用了信号和插槽，整个程序包括了弹幕礼物进场点歌功能一共 500+ 行，有些代码略冗余，还需要凝练。如果大家有任何想法都可以跟我交流，不限于博客写法，代码规范，开发思路等等，欢迎！</p>
<h2 id="总结">总结</h2>
<p>其实从有这个程序的想法到现在落地开发完成，也是走了不少的弯路的。一开始以为那些被压缩了的“乱码”是被加密的结果，自己又配置了 <code>sslkey.log</code>文件使用 Wireshark 解密，结果自然是白忙活一场。关键还是还是协议分析这块不够熟练，对网络理解不够。还有在连接弹幕服务器的时候尝试使用了 net 包下 net.Dial 进行通信，结果报错 <code>GetInfoW</code> 方法类找不到，当时只知道 ws 是基于 tcp，后来才知道单纯 tcp 根本无法与 ws 服务器连接，这一点说到底还是自己对连接过程理解不够。经过这个小项目，让自己对网络这一块的重要程度有了新的认识，决定要好好学习这些内容，还有 Go 语言的实操，协程池的使用，与 Qml 的通信。总体来说收获还是不小，以后还是要多上手练习。</p>
]]></content>
		</item>
		
		<item>
			<title>B站直播助手开发[上]</title>
			<link>https://www.kcode.icu/posts/b%E7%AB%99%E7%9B%B4%E6%92%AD%E5%8A%A9%E6%89%8B%E5%BC%80%E5%8F%91%E4%B8%8A/</link>
			<pubDate>Thu, 05 Mar 2020 15:45:13 +0000</pubDate>
			
			<guid>https://www.kcode.icu/posts/b%E7%AB%99%E7%9B%B4%E6%92%AD%E5%8A%A9%E6%89%8B%E5%BC%80%E5%8F%91%E4%B8%8A/</guid>
			<description>B站直播协议分析  上篇介绍协议分析，下篇介绍开发思路。
 项目缘由 假期在家，群里有几个朋友决定尝个新鲜开直播娱乐一下，后来发现B站官方提供的直播姬只有弹幕显示功能，并没有点歌等其他自定义功能，网上的项目也比较少，而且一些点歌机不维护了导致功能有缺陷，因此打算开发一个自定义的具有多功能的直播助手，初步包含弹幕礼物显示，点歌等功能。
开发的思路是分析传输二进制包，从中找出我们想要的数据，以我们想要的方式显示出来。
总体过程 随便打开一个直播间，按 F12，切换到 Network 的 WS 栏。可以看到它是首先连接弹幕服务器，并且通过观察发现这个地址并不是固定的（应该是负载均衡的结果）。
然后发送一个握手包，携带了 Roomid，访问者 id，客户端版本等信息，最后还有一个 key，后来观察发现是通过请求某个接口获取的这个 key 值（就是 token）。
重点就是分析协议包。不管是接收还是发送的二进制包都有一个固定大小 16 字节的首部。这个首部的组成我用一个表格来表示：
   偏移 长度 内容     0 4 包的大小   4 4 未知（目前和分析无关）   8 4 包类型   12 4 未知（目前和分析无关）    除了首部之外的就是携带的数据部分了。在这里需要注意的一点是，由于瞬时信息量可能会很大，会把若干个包压缩为一个包发送，这个包组成是《包首部-包主体-下一个包首部-下一个包主体-&amp;hellip;..等等》，而且因为包类型为 5 的数量最多，传输信息量会很大，所以是用 gzip 压缩了的，这里要注意。这里随手拿一个包举例：
...G............{&amp;#34;cmd&amp;#34;:&amp;#34;DANMU_MSG&amp;#34;,&amp;#34;info&amp;#34;:[[0,1,25,8322816,1584073975908,1584073720,0,&amp;#34;7905c3d4&amp;#34;,0,0,0],&amp;#34;(=・ω・=)&amp;#34;,[14006391,&amp;#34;桥本环零&amp;#34;,0,1,0,10000,1,&amp;#34;&amp;#34;],[17,&amp;#34;小糕兔&amp;#34;,&amp;#34;娜可糕糕&amp;#34;,294526,16752445,&amp;#34;&amp;#34;,0],[47,0,16746162,10074],[&amp;#34;title-179-1&amp;#34;,&amp;#34;title-179-1&amp;#34;],0,0,null,{&amp;#34;ts&amp;#34;:1584073975,&amp;#34;ct&amp;#34;:&amp;#34;B0A7DFE4&amp;#34;},0,0,null,null,0]}...h............{&amp;#34;cmd&amp;#34;:&amp;#34;DANMU_MSG&amp;#34;,&amp;#34;info&amp;#34;:[[0,1,25,16777215,1584073975938,1584073264,0,&amp;#34;21635747&amp;#34;,0,0,0],&amp;#34;包砸是我关注的up里唯一一个很可爱的&amp;#34;,[339865528,&amp;#34;兰博基尼鬼怪&amp;#34;,0,0,0,10000,1,&amp;#34;&amp;#34;],[3,&amp;#34;包崽铺&amp;#34;,&amp;#34;喝薄荷奶绿&amp;#34;,1506599,6406234,&amp;#34;&amp;#34;,0],[10,0,9868950,&amp;#34;\u003e50000&amp;#34;],[&amp;#34;&amp;#34;,&amp;#34;&amp;#34;],0,0,null,{&amp;#34;ts&amp;#34;:1584073975,&amp;#34;ct&amp;#34;:&amp;#34;657DC663&amp;#34;},0,0,null,null,0]} 可以看到这里就是瞬时有两条弹幕，变为了一个包。每个包都有自己的头部，可以自行格式化一下。
也不是所有类型为 5 的包都被压缩，只有某些可能数据量很大才会被压缩，比如 DANMU_MSG，SEND_GIFT 等，并且类型为 5 的可能是用户弹幕，礼物，贵宾进场，房间关注变动等，就是依靠 “cmd” 这个字段值来判别的，目前我已知的 cmd 有这么几种，可以根据需求来利用：</description>
			<content type="html"><![CDATA[<h1 id="b站直播协议分析">B站直播协议分析</h1>
<blockquote>
<p>上篇介绍协议分析，下篇介绍开发思路。</p>
</blockquote>
<h2 id="项目缘由">项目缘由</h2>
<p>假期在家，群里有几个朋友决定尝个新鲜开直播娱乐一下，后来发现B站官方提供的直播姬只有弹幕显示功能，并没有点歌等其他自定义功能，网上的项目也比较少，而且一些点歌机不维护了导致功能有缺陷，因此打算开发一个自定义的具有多功能的直播助手，初步包含弹幕礼物显示，点歌等功能。</p>
<p>开发的思路是<strong>分析传输二进制包，从中找出我们想要的数据，以我们想要的方式显示出来。</strong></p>
<h2 id="总体过程">总体过程</h2>
<p>随便打开一个直播间，按 F12，切换到 Network 的 WS 栏。可以看到它是首先连接弹幕服务器，并且通过观察发现这个地址并不是固定的（应该是负载均衡的结果）。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/image-20210125220539933.png" alt="wss链接"></p>
<p>然后发送一个握手包，携带了 Roomid，访问者 id，客户端版本等信息，最后还有一个 key，后来观察发现是通过请求某个接口获取的这个 key 值（就是 token）。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/image-20210125220806540.png" alt="握手包"></p>
<p>重点就是分析协议包。不管是接收还是发送的二进制包都有一个固定大小 16 字节的首部。这个首部的组成我用一个表格来表示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">偏移</th>
<th style="text-align:center">长度</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">4</td>
<td style="text-align:center">包的大小</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">未知（目前和分析无关）</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">4</td>
<td style="text-align:center">包类型</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">4</td>
<td style="text-align:center">未知（目前和分析无关）</td>
</tr>
</tbody>
</table>
<p>除了首部之外的就是携带的数据部分了。在这里需要注意的一点是，<strong>由于瞬时信息量可能会很大，会把若干个包压缩为一个包发送，这个包组成是《包首部-包主体-下一个包首部-下一个包主体-&hellip;..等等》</strong>，而且因为包类型为 5 的数量最多，传输信息量会很大，所以是用 gzip 压缩了的，这里要注意。这里随手拿一个包举例：</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="err">...G............</span><span class="p">{</span><span class="nt">&#34;cmd&#34;</span><span class="p">:</span><span class="s2">&#34;DANMU_MSG&#34;</span><span class="p">,</span><span class="nt">&#34;info&#34;</span><span class="p">:[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">8322816</span><span class="p">,</span><span class="mi">1584073975908</span><span class="p">,</span><span class="mi">1584073720</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="s2">&#34;7905c3d4&#34;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="s2">&#34;(=・ω・=)&#34;</span><span class="p">,[</span><span class="mi">14006391</span><span class="p">,</span><span class="s2">&#34;桥本环零&#34;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">10000</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s2">&#34;&#34;</span><span class="p">],[</span><span class="mi">17</span><span class="p">,</span><span class="s2">&#34;小糕兔&#34;</span><span class="p">,</span><span class="s2">&#34;娜可糕糕&#34;</span><span class="p">,</span><span class="mi">294526</span><span class="p">,</span><span class="mi">16752445</span><span class="p">,</span><span class="s2">&#34;&#34;</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">47</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">16746162</span><span class="p">,</span><span class="mi">10074</span><span class="p">],[</span><span class="s2">&#34;title-179-1&#34;</span><span class="p">,</span><span class="s2">&#34;title-179-1&#34;</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="kc">null</span><span class="p">,{</span><span class="nt">&#34;ts&#34;</span><span class="p">:</span><span class="mi">1584073975</span><span class="p">,</span><span class="nt">&#34;ct&#34;</span><span class="p">:</span><span class="s2">&#34;B0A7DFE4&#34;</span><span class="p">},</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">0</span><span class="p">]}</span><span class="err">...h............</span><span class="p">{</span><span class="nt">&#34;cmd&#34;</span><span class="p">:</span><span class="s2">&#34;DANMU_MSG&#34;</span><span class="p">,</span><span class="nt">&#34;info&#34;</span><span class="p">:[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">16777215</span><span class="p">,</span><span class="mi">1584073975938</span><span class="p">,</span><span class="mi">1584073264</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="s2">&#34;21635747&#34;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="s2">&#34;包砸是我关注的up里唯一一个很可爱的&#34;</span><span class="p">,[</span><span class="mi">339865528</span><span class="p">,</span><span class="s2">&#34;兰博基尼鬼怪&#34;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">10000</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s2">&#34;&#34;</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="s2">&#34;包崽铺&#34;</span><span class="p">,</span><span class="s2">&#34;喝薄荷奶绿&#34;</span><span class="p">,</span><span class="mi">1506599</span><span class="p">,</span><span class="mi">6406234</span><span class="p">,</span><span class="s2">&#34;&#34;</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">9868950</span><span class="p">,</span><span class="s2">&#34;\u003e50000&#34;</span><span class="p">],[</span><span class="s2">&#34;&#34;</span><span class="p">,</span><span class="s2">&#34;&#34;</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="kc">null</span><span class="p">,{</span><span class="nt">&#34;ts&#34;</span><span class="p">:</span><span class="mi">1584073975</span><span class="p">,</span><span class="nt">&#34;ct&#34;</span><span class="p">:</span><span class="s2">&#34;657DC663&#34;</span><span class="p">},</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">0</span><span class="p">]}</span>
</code></pre></div><p>可以看到这里就是瞬时有两条弹幕，变为了一个包。每个包都有自己的头部，可以自行格式化一下。</p>
<p>也<strong>不是所有类型为 5 的包都被压缩</strong>，只有某些可能数据量很大才会被压缩，比如 DANMU_MSG，SEND_GIFT 等，并且类型为 5 的可能是用户弹幕，礼物，贵宾进场，房间关注变动等，就是依靠 “cmd” 这个字段值来判别的，目前我已知的 cmd 有这么几种，可以根据需求来利用：</p>
<table>
<thead>
<tr>
<th style="text-align:center">cmd</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">DANMU_MSG</td>
<td style="text-align:center">用户弹幕</td>
</tr>
<tr>
<td style="text-align:center">WELCOME</td>
<td style="text-align:center">Vip，Svip进场（<strong>标注1</strong>）</td>
</tr>
<tr>
<td style="text-align:center">WELCOME_GUARD</td>
<td style="text-align:center">房管进场</td>
</tr>
<tr>
<td style="text-align:center">ENTRY_EFFECT</td>
<td style="text-align:center">提督，总督等头衔</td>
</tr>
<tr>
<td style="text-align:center">SEND_GIFT</td>
<td style="text-align:center">用户礼物</td>
</tr>
<tr>
<td style="text-align:center">COMBO_SEND</td>
<td style="text-align:center">礼物连击</td>
</tr>
<tr>
<td style="text-align:center">COMBO_END</td>
<td style="text-align:center">连击结束（<strong>标注2</strong>）</td>
</tr>
<tr>
<td style="text-align:center">ROOMD_RANK</td>
<td style="text-align:center">这个不太清楚是什么</td>
</tr>
<tr>
<td style="text-align:center">NOTICE_MSG</td>
<td style="text-align:center">所有直播间的通告消息</td>
</tr>
</tbody>
</table>
<blockquote>
<p>标注 1: 我不太了解 B 站 Vip 的等级划分，我仅知道提督，总督等，还有老爷这些，其他不知道了，老爷是被划分到这一栏的。</p>
</blockquote>
<blockquote>
<p>标注 2: 如果送礼物连击是会有和《SEND_GIFT》不一样的特效的，连击结束也有提示，所以分开了。</p>
</blockquote>
<p>这里给出一些用到的接口，后续可能会更新失效，F12 打开找即可，截止博客发出时均有效。</p>
<table>
<thead>
<tr>
<th style="text-align:center">URL</th>
<th style="text-align:center">参数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="http://api.live.bilibili.com/room/v1/Room/room_init">http://api.live.bilibili.com/room/v1/Room/room_init</a></td>
<td style="text-align:center">id</td>
<td style="text-align:center">查询房间短id，长id等信息</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://api.live.bilibili.com/room/v1/Danmu/getConf">https://api.live.bilibili.com/room/v1/Danmu/getConf</a></td>
<td style="text-align:center">room_id=xxx&amp;platform=pc&amp;player=web</td>
<td style="text-align:center">查询可用弹幕服务器列表，握手包的key</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://api.bilibili.com/x/space/acc/info">https://api.bilibili.com/x/space/acc/info</a></td>
<td style="text-align:center">mid=382297465&amp;jsonp=jsonp</td>
<td style="text-align:center">根据userid查询用户个人信息</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://api.live.bilibili.com/xlive/web-room/v1/index/getInfoByRoom">https://api.live.bilibili.com/xlive/web-room/v1/index/getInfoByRoom</a></td>
<td style="text-align:center">room_id=xxx</td>
<td style="text-align:center">查询房间信息，标题等</td>
</tr>
</tbody>
</table>
<p>到这里其实就已经结束了，<strong>我们可以模拟连接某个弹幕服务器，然后按照要求发送握手包，随后一直接收信息，根据首部的类型 ID 可以判定不同的包，然后根据 cmd 字段判定消息类型，获取我们想要的字段值就可以了。再结合其他的一些接口就可以完整的获取直播间的各种信息了。</strong></p>
<p>分析完后，就可以根据流程去写程序了，下一节介绍如何使用 <a href="https://golang.org/">Go</a> 语言开发助手的后端部分。</p>
]]></content>
		</item>
		
	</channel>
</rss>
