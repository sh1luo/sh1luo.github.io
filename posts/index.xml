<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on wasabi</title><link>https://kcode.icu/posts/</link><description>Recent content in Posts on wasabi</description><generator>Hugo -- gohugo.io</generator><language>zh-hans</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Wed, 01 Dec 2021 16:04:20 +0000</lastBuildDate><atom:link href="https://kcode.icu/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Go 语言代码安全指南</title><link>https://kcode.icu/posts/go/2021-12-01-go%E5%AE%89%E5%85%A8%E8%A7%84%E8%8C%83/</link><pubDate>Wed, 01 Dec 2021 16:04:20 +0000</pubDate><guid>https://kcode.icu/posts/go/2021-12-01-go%E5%AE%89%E5%85%A8%E8%A7%84%E8%8C%83/</guid><description>这是一些关于 Go 安全编码方案，旨在从源头规避漏洞。
通用类 1. 代码实现类 1.1 内存管理 1.1.1【必须】切片长度校验 在对slice进行操作时，必须判断长度是否合法，防止程序panic // bad: 未判断data的长度，可导致 index out of range func decode(data []byte) bool { if data[0] == &amp;#39;F&amp;#39; &amp;amp;&amp;amp; data[1] == &amp;#39;U&amp;#39; &amp;amp;&amp;amp; data[2] == &amp;#39;Z&amp;#39; &amp;amp;&amp;amp; data[3] == &amp;#39;Z&amp;#39; &amp;amp;&amp;amp; data[4] == &amp;#39;E&amp;#39; &amp;amp;&amp;amp; data[5] == &amp;#39;R&amp;#39; { fmt.Println(&amp;#34;Bad&amp;#34;) return true } return false } // bad: slice bounds out of range func foo() { var slice = []int{0, 1, 2, 3, 4, 5, 6} fmt.</description><content type="html"><![CDATA[<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>这是一些关于 Go 安全编码方案，旨在从源头规避漏洞。</p>
<h1 id="通用类">通用类</h1>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h2 id="1-代码实现类">1. 代码实现类</h2>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="11-内存管理">1.1 内存管理</h3>
<h4 id="111必须切片长度校验">1.1.1【必须】切片长度校验</h4>
<ul>
<li>在对slice进行操作时，必须判断长度是否合法，防止程序panic</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// bad: 未判断data的长度，可导致 index out of range
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;F&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;U&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;Z&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;Z&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;E&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;R&#39;</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Bad&#34;</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="c1">// bad: slice bounds out of range
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">slice</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">slice</span><span class="p">[:</span><span class="mi">10</span><span class="p">])</span>
<span class="p">}</span>

<span class="c1">// good: 使用data前应判断长度是否合法
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;F&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;U&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;Z&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;Z&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;E&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;R&#39;</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Good&#34;</span><span class="p">)</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></div><h4 id="112必须nil指针判断">1.1.2【必须】nil指针判断</h4>
<ul>
<li>进行指针操作时，必须判断该指针是否为nil，防止程序panic，尤其在进行结构体Unmarshal时</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Packet</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">PackeyType</span>    <span class="kt">uint8</span>
	<span class="nx">PackeyVersion</span> <span class="kt">uint8</span>
	<span class="nx">Data</span>          <span class="o">*</span><span class="nx">Data</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Data</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Stat</span> <span class="kt">uint8</span>
	<span class="nx">Len</span>  <span class="kt">uint8</span>
	<span class="nx">Buf</span>  <span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="kt">byte</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Packet</span><span class="p">)</span> <span class="nf">UnmarshalBinary</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">2</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span>
	<span class="p">}</span>

	<span class="nx">p</span><span class="p">.</span><span class="nx">PackeyType</span> <span class="p">=</span> <span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="nx">p</span><span class="p">.</span><span class="nx">PackeyVersion</span> <span class="p">=</span> <span class="nx">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

	<span class="c1">// 若长度等于2，那么不会new Data
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">2</span> <span class="p">{</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">Data</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Data</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// bad: 未判断指针是否为nil
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">packet</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Packet</span><span class="p">)</span>
	<span class="nx">data</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">packet</span><span class="p">.</span><span class="nf">UnmarshalBinary</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Failed to unmarshal packet&#34;</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Stat: %v\n&#34;</span><span class="p">,</span> <span class="nx">packet</span><span class="p">.</span><span class="nx">Data</span><span class="p">.</span><span class="nx">Stat</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// good: 判断Data指针是否为nil
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">packet</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Packet</span><span class="p">)</span>
	<span class="nx">data</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">packet</span><span class="p">.</span><span class="nf">UnmarshalBinary</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Failed to unmarshal packet&#34;</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">packet</span><span class="p">.</span><span class="nx">Data</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Stat: %v\n&#34;</span><span class="p">,</span> <span class="nx">packet</span><span class="p">.</span><span class="nx">Data</span><span class="p">.</span><span class="nx">Stat</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="113必须整数安全">1.1.3【必须】整数安全</h4>
<ul>
<li>
<p>在进行数字运算操作时，需要做好长度限制，防止外部输入运算导致异常：</p>
<ul>
<li>确保无符号整数运算时不会反转</li>
<li>确保有符号整数运算时不会出现溢出</li>
<li>确保整型转换时不会出现截断错误</li>
<li>确保整型转换时不会出现符号错误</li>
</ul>
</li>
<li>
<p>以下场景必须严格进行长度限制：</p>
<ul>
<li>作为数组索引</li>
<li>作为对象的长度或者大小</li>
<li>作为数组的边界（如作为循环计数器）</li>
</ul>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// bad: 未限制长度，导致整数溢出
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">overflow</span><span class="p">(</span><span class="nx">numControlByUser</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">numInt</span> <span class="kt">int32</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">numInt</span> <span class="p">=</span> <span class="nx">numControlByUser</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="c1">// 对长度限制不当，导致整数溢出
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d\n&#34;</span><span class="p">,</span> <span class="nx">numInt</span><span class="p">)</span>
	<span class="c1">// 使用numInt，可能导致其他错误
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">overflow</span><span class="p">(</span><span class="mi">2147483647</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// good
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">overflow</span><span class="p">(</span><span class="nx">numControlByUser</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">numInt</span> <span class="kt">int32</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">numInt</span> <span class="p">=</span> <span class="nx">numControlByUser</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="k">if</span> <span class="nx">numInt</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;integer overflow&#34;</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;integer ok&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">overflow</span><span class="p">(</span><span class="mi">2147483647</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="114必须make分配长度验证">1.1.4【必须】make分配长度验证</h4>
<ul>
<li>在进行make分配内存时，需要对外部可控的长度进行校验，防止程序panic。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// bad
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">parse</span><span class="p">(</span><span class="nx">lenControlByUser</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">size</span> <span class="o">:=</span> <span class="nx">lenControlByUser</span>
	<span class="c1">// 对外部传入的size，进行长度判断以免导致panic
</span><span class="c1"></span>	<span class="nx">buffer</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
	<span class="nb">copy</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// good
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">parse</span><span class="p">(</span><span class="nx">lenControlByUser</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">size</span> <span class="o">:=</span> <span class="nx">lenControlByUser</span>
	<span class="c1">// 限制外部可控的长度大小范围
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">size</span> <span class="p">&gt;</span> <span class="mi">64</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;value too large&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">buffer</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
	<span class="nb">copy</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">buffer</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h4 id="115必须禁止setfinalizer和指针循环引用同时使用">1.1.5【必须】禁止SetFinalizer和指针循环引用同时使用</h4>
<ul>
<li>当一个对象从被GC选中到移除内存之前，runtime.SetFinalizer()都不会执行，即使程序正常结束或者发生错误。由指针构成的“循环引用”虽然能被GC正确处理，但由于无法确定Finalizer依赖顺序，从而无法调用runtime.SetFinalizer()，导致目标对象无法变成可达状态，从而造成内存无法被回收。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// bad
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">Data</span>
	<span class="nx">a</span><span class="p">.</span><span class="nx">o</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">b</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">o</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">a</span>

	<span class="c1">// 指针循环引用，SetFinalizer()无法正常调用
</span><span class="c1"></span>	<span class="nx">runtime</span><span class="p">.</span><span class="nf">SetFinalizer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">a</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Data</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;a %p final.\n&#34;</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span>
	<span class="p">})</span>
	<span class="nx">runtime</span><span class="p">.</span><span class="nf">SetFinalizer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Data</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;b %p final.\n&#34;</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span>
	<span class="p">})</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nf">foo</span><span class="p">()</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h4 id="116必须禁止重复释放channel">1.1.6【必须】禁止重复释放channel</h4>
<ul>
<li>重复释放一般存在于异常流程判断中，如果恶意攻击者构造出异常条件使程序重复释放channel，则会触发运行时panic，从而造成DoS攻击。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// bad
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">c</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nf">processBusiness</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">0</span>
		<span class="nb">close</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="c1">// 重复释放channel
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="c1">// good
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">c</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="c1">// 使用defer延迟关闭channel
</span><span class="c1"></span>	<span class="nx">err</span> <span class="o">:=</span> <span class="nf">processBusiness</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">0</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">1</span>
<span class="p">}</span>
</code></pre></div><h4 id="117必须确保每个协程都能退出">1.1.7【必须】确保每个协程都能退出</h4>
<ul>
<li>启动一个协程就会做一个入栈操作，在系统不退出的情况下，协程也没有设置退出条件，则相当于协程失去了控制，它占用的资源无法回收，可能会导致内存泄露。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// bad: 协程没有设置退出条件
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">doWaiter</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">second</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">second</span><span class="p">)</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="s">&#34; is ready!&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="118推荐不使用unsafe包">1.1.8【推荐】不使用unsafe包</h4>
<ul>
<li>由于unsafe包绕过了 Golang 的内存安全原则，一般来说使用该库是不安全的，可导致内存破坏，尽量避免使用该包。若必须要使用unsafe操作指针，必须做好安全校验。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// bad: 通过unsafe操作原始指针
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">unsafePointer</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">b</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">foo</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="kt">int</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mh">0xfffffffe</span><span class="p">)))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="o">*</span><span class="nx">foo</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// [signal SIGSEGV: segmentation violation code=0x1 addr=0xc100068f55 pc=0x49142b]
</span><span class="c1"></span>
</code></pre></div><h4 id="119推荐不使用slice作为函数入参">1.1.9【推荐】不使用slice作为函数入参</h4>
<ul>
<li>slice在作为函数入参时，函数内对slice的修改可能会影响原始数据</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">  <span class="c1">// bad
</span><span class="c1"></span>  <span class="c1">// slice作为函数入参时包含原始数组指针
</span><span class="c1"></span>  <span class="kd">func</span> <span class="nf">modify</span><span class="p">(</span><span class="nx">array</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">10</span> <span class="c1">// 对入参slice的元素修改会影响原始数据
</span><span class="c1"></span>  <span class="p">}</span>
  
  <span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">array</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
  
      <span class="nf">modify</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span> <span class="c1">// output：[10 2 3 4 5]
</span><span class="c1"></span>  <span class="p">}</span>

  <span class="c1">// good
</span><span class="c1"></span>  <span class="c1">// 数组作为函数入参，而不是slice
</span><span class="c1"></span>  <span class="kd">func</span> <span class="nf">modify</span><span class="p">(</span><span class="nx">array</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">10</span>
  <span class="p">}</span>

  <span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">// 传入数组，注意数组与slice的区别
</span><span class="c1"></span>      <span class="nx">array</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
  
      <span class="nf">modify</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span>
  <span class="p">}</span>
  
</code></pre></div><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="12-文件操作">1.2 文件操作</h3>
<h4 id="121必须-路径穿越检查">1.2.1【必须】 路径穿越检查</h4>
<ul>
<li>在进行文件操作时，如果对外部传入的文件名未做限制，可能导致任意文件读取或者任意文件写入，严重可能导致代码执行。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// bad: 任意文件读取
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">handler</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">path</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nf">Query</span><span class="p">()[</span><span class="s">&#34;path&#34;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

	<span class="c1">// 未过滤文件路径，可能导致任意文件读取
</span><span class="c1"></span>	<span class="nx">data</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadFile</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>

	<span class="c1">// 对外部传入的文件名变量，还需要验证是否存在../等路径穿越的文件名
</span><span class="c1"></span>	<span class="nx">data</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadFile</span><span class="p">(</span><span class="nx">filepath</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="s">&#34;/home/user/&#34;</span><span class="p">,</span> <span class="nx">path</span><span class="p">))</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// bad: 任意文件写入
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">unzip</span><span class="p">(</span><span class="nx">f</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">r</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">zip</span><span class="p">.</span><span class="nf">OpenReader</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">r</span><span class="p">.</span><span class="nx">File</span> <span class="p">{</span>
		<span class="nx">p</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">filepath</span><span class="p">.</span><span class="nf">Abs</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span>
		<span class="c1">// 未验证压缩文件名，可能导致../等路径穿越，任意文件路径写入
</span><span class="c1"></span>		<span class="nx">ioutil</span><span class="p">.</span><span class="nf">WriteFile</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;present&#34;</span><span class="p">),</span> <span class="mo">0640</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// good: 检查压缩的文件名是否包含..路径穿越特征字符，防止任意写入
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">unzipGood</span><span class="p">(</span><span class="nx">f</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">r</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">zip</span><span class="p">.</span><span class="nf">OpenReader</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;read zip file fail&#34;</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">r</span><span class="p">.</span><span class="nx">File</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="s">&#34;..&#34;</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">p</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">filepath</span><span class="p">.</span><span class="nf">Abs</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span>
			<span class="nx">ioutil</span><span class="p">.</span><span class="nf">WriteFile</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;present&#34;</span><span class="p">),</span> <span class="mo">0640</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></div><h4 id="122必须-文件访问权限">1.2.2【必须】 文件访问权限</h4>
<ul>
<li>根据创建文件的敏感性设置不同级别的访问权限，以防止敏感数据被任意权限用户读取。例如，设置文件权限为：<code>-rw-r-----</code></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">ioutil</span><span class="p">.</span><span class="nf">WriteFile</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;present&#34;</span><span class="p">),</span> <span class="mo">0640</span><span class="p">)</span>
</code></pre></div><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="13-系统接口">1.3 系统接口</h3>
<p><strong>1.3.1【必须】命令执行检查</strong></p>
<ul>
<li>使用<code>exec.Command</code>、<code>exec.CommandContext</code>、<code>syscall.StartProcess</code>、<code>os.StartProcess</code>等函数时，第一个参数（path）直接取外部输入值时，应使用白名单限定可执行的命令范围，不允许传入<code>bash</code>、<code>cmd</code>、<code>sh</code>等命令；</li>
<li>使用<code>exec.Command</code>、<code>exec.CommandContext</code>等函数时，通过<code>bash</code>、<code>cmd</code>、<code>sh</code>等创建shell，-c后的参数（arg）拼接外部输入，应过滤\n  $  &amp;  ;  |  '  &quot;  ( )  `等潜在恶意字符；</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// bad
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">userInputedVal</span> <span class="o">:=</span> <span class="s">&#34;&amp;&amp; echo &#39;hello&#39;&#34;</span> <span class="c1">// 假设外部传入该变量值
</span><span class="c1"></span>	<span class="nx">cmdName</span> <span class="o">:=</span> <span class="s">&#34;ping &#34;</span> <span class="o">+</span> <span class="nx">userInputedVal</span>

	<span class="c1">// 未判断外部输入是否存在命令注入字符，结合sh可造成命令注入
</span><span class="c1"></span>	<span class="nx">cmd</span> <span class="o">:=</span> <span class="nx">exec</span><span class="p">.</span><span class="nf">Command</span><span class="p">(</span><span class="s">&#34;sh&#34;</span><span class="p">,</span> <span class="s">&#34;-c&#34;</span><span class="p">,</span> <span class="nx">cmdName</span><span class="p">)</span>
	<span class="nx">output</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">cmd</span><span class="p">.</span><span class="nf">CombinedOutput</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">output</span><span class="p">))</span>

	<span class="nx">cmdName</span> <span class="o">:=</span> <span class="s">&#34;ls&#34;</span>
	<span class="c1">// 未判断外部输入是否是预期命令
</span><span class="c1"></span>	<span class="nx">cmd</span> <span class="o">:=</span> <span class="nx">exec</span><span class="p">.</span><span class="nf">Command</span><span class="p">(</span><span class="nx">cmdName</span><span class="p">)</span>
	<span class="nx">output</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">cmd</span><span class="p">.</span><span class="nf">CombinedOutput</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">output</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// good
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">checkIllegal</span><span class="p">(</span><span class="nx">cmdName</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">cmdName</span><span class="p">,</span> <span class="s">&#34;&amp;&#34;</span><span class="p">)</span> <span class="o">||</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">cmdName</span><span class="p">,</span> <span class="s">&#34;|&#34;</span><span class="p">)</span> <span class="o">||</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">cmdName</span><span class="p">,</span> <span class="s">&#34;;&#34;</span><span class="p">)</span> <span class="o">||</span>
		<span class="nx">strings</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">cmdName</span><span class="p">,</span> <span class="s">&#34;$&#34;</span><span class="p">)</span> <span class="o">||</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">cmdName</span><span class="p">,</span> <span class="s">&#34;&#39;&#34;</span><span class="p">)</span> <span class="o">||</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">cmdName</span><span class="p">,</span> <span class="s">&#34;`&#34;</span><span class="p">)</span> <span class="o">||</span>
		<span class="nx">strings</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">cmdName</span><span class="p">,</span> <span class="s">&#34;(&#34;</span><span class="p">)</span> <span class="o">||</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">cmdName</span><span class="p">,</span> <span class="s">&#34;)&#34;</span><span class="p">)</span> <span class="o">||</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">cmdName</span><span class="p">,</span> <span class="s">&#34;\&#34;&#34;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">userInputedVal</span> <span class="o">:=</span> <span class="s">&#34;&amp;&amp; echo &#39;hello&#39;&#34;</span>
	<span class="nx">cmdName</span> <span class="o">:=</span> <span class="s">&#34;ping &#34;</span> <span class="o">+</span> <span class="nx">userInputedVal</span>

	<span class="k">if</span> <span class="nf">checkIllegal</span><span class="p">(</span><span class="nx">cmdName</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 检查传给sh的命令是否有特殊字符
</span><span class="c1"></span>		<span class="k">return</span> <span class="c1">// 存在特殊字符直接return
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="nx">cmd</span> <span class="o">:=</span> <span class="nx">exec</span><span class="p">.</span><span class="nf">Command</span><span class="p">(</span><span class="s">&#34;sh&#34;</span><span class="p">,</span> <span class="s">&#34;-c&#34;</span><span class="p">,</span> <span class="nx">cmdName</span><span class="p">)</span>
	<span class="nx">output</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">cmd</span><span class="p">.</span><span class="nf">CombinedOutput</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">output</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="14-通信安全">1.4 通信安全</h3>
<h4 id="141必须网络通信采用tls方式">1.4.1【必须】网络通信采用TLS方式</h4>
<ul>
<li>明文传输的通信协议目前已被验证存在较大安全风险，被中间人劫持后可能导致许多安全风险，因此必须采用至少TLS的安全通信方式保证通信安全，例如gRPC/Websocket都使用TLS1.3。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// good
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">w</span><span class="p">.</span><span class="nf">Header</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;Strict-Transport-Security&#34;</span><span class="p">,</span> <span class="s">&#34;max-age=63072000; includeSubDomains&#34;</span><span class="p">)</span>
		<span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;This is an example server.\n&#34;</span><span class="p">))</span>
	<span class="p">})</span>

	<span class="c1">// 服务器配置证书与私钥
</span><span class="c1"></span>	<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServeTLS</span><span class="p">(</span><span class="s">&#34;:443&#34;</span><span class="p">,</span> <span class="s">&#34;yourCert.pem&#34;</span><span class="p">,</span> <span class="s">&#34;yourKey.pem&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><h4 id="142推荐tls启用证书验证">1.4.2【推荐】TLS启用证书验证</h4>
<ul>
<li>TLS证书应当是有效的、未过期的，且配置正确的域名，生产环境的服务端应启用证书验证。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// bad
</span><span class="c1"></span><span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;crypto/tls&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">doAuthReq</span><span class="p">(</span><span class="nx">authReq</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Response</span> <span class="p">{</span>
	<span class="nx">tr</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Transport</span><span class="p">{</span>
		<span class="nx">TLSClientConfig</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span><span class="nx">InsecureSkipVerify</span><span class="p">:</span> <span class="kc">true</span><span class="p">},</span>
	<span class="p">}</span>
	<span class="nx">client</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Client</span><span class="p">{</span><span class="nx">Transport</span><span class="p">:</span> <span class="nx">tr</span><span class="p">}</span>
	<span class="nx">res</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">authReq</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="c1">// good
</span><span class="c1"></span><span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;crypto/tls&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">doAuthReq</span><span class="p">(</span><span class="nx">authReq</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Response</span> <span class="p">{</span>
	<span class="nx">tr</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Transport</span><span class="p">{</span>
		<span class="nx">TLSClientConfig</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span><span class="nx">InsecureSkipVerify</span><span class="p">:</span> <span class="kc">false</span><span class="p">},</span>
	<span class="p">}</span>
	<span class="nx">client</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Client</span><span class="p">{</span><span class="nx">Transport</span><span class="p">:</span> <span class="nx">tr</span><span class="p">}</span>
	<span class="nx">res</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">authReq</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre></div><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="15-敏感数据保护">1.5 敏感数据保护</h3>
<h4 id="151必须敏感信息访问">1.5.1【必须】敏感信息访问</h4>
<ul>
<li>禁止将敏感信息硬编码在程序中，既可能会将敏感信息暴露给攻击者，也会增加代码管理和维护的难度</li>
<li>使用配置中心系统统一托管密钥等敏感信息</li>
</ul>
<h4 id="152必须敏感数据输出">1.5.2【必须】敏感数据输出</h4>
<ul>
<li>只输出必要的最小数据集，避免多余字段暴露引起敏感信息泄露</li>
<li>不能在日志保存密码（包括明文密码和密文密码）、密钥和其它敏感信息</li>
<li>对于必须输出的敏感信息，必须进行合理脱敏展示</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// bad
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">serve</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/register&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">.</span><span class="nf">ParseForm</span><span class="p">()</span>
		<span class="nx">user</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Form</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;user&#34;</span><span class="p">)</span>
		<span class="nx">pw</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Form</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;password&#34;</span><span class="p">)</span>

		<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Registering new user %s with password %s.\n&#34;</span><span class="p">,</span> <span class="nx">user</span><span class="p">,</span> <span class="nx">pw</span><span class="p">)</span>
	<span class="p">})</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:80&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// good
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">serve1</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/register&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">.</span><span class="nf">ParseForm</span><span class="p">()</span>
		<span class="nx">user</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Form</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;user&#34;</span><span class="p">)</span>
		<span class="nx">pw</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Form</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;password&#34;</span><span class="p">)</span>

		<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Registering new user %s.\n&#34;</span><span class="p">,</span> <span class="nx">user</span><span class="p">)</span>

		<span class="c1">// ...
</span><span class="c1"></span>		<span class="nf">use</span><span class="p">(</span><span class="nx">pw</span><span class="p">)</span>
	<span class="p">})</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:80&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>避免通过GET方法、代码注释、自动填充、缓存等方式泄露敏感信息</li>
</ul>
<h4 id="153必须敏感数据存储">1.5.3【必须】敏感数据存储</h4>
<ul>
<li>敏感数据应使用SHA2、RSA等算法进行加密存储</li>
<li>敏感数据应使用独立的存储层，并在访问层开启访问控制</li>
<li>包含敏感信息的临时文件或缓存一旦不再需要应立刻删除</li>
</ul>
<h4 id="154必须异常处理和日志记录">1.5.4【必须】异常处理和日志记录</h4>
<ul>
<li>应合理使用panic、recover、defer处理系统异常，避免出错信息输出到前端</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">defer</span> <span class="kd">func</span> <span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">r</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">r</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Recovered in start()&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}()</span>
</code></pre></div><ul>
<li>对外环境禁止开启debug模式，或将程序运行日志输出到前端</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">// bad
dlv --listen<span class="o">=</span>:2345 --headless<span class="o">=</span><span class="nb">true</span> --api-version<span class="o">=</span><span class="m">2</span> debug test.go
// good
dlv debug test.go
</code></pre></div><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="16-加密解密">1.6 加密解密</h3>
<h4 id="161必须不得硬编码密码密钥">1.6.1【必须】不得硬编码密码/密钥</h4>
<ul>
<li>在进行用户登陆，加解密算法等操作时，不得在代码里硬编码密钥或密码，可通过变换算法或者配置等方式设置密码或者密钥。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// bad
</span><span class="c1"></span><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">user</span>     <span class="p">=</span> <span class="s">&#34;dbuser&#34;</span>
	<span class="nx">password</span> <span class="p">=</span> <span class="s">&#34;s3cretp4ssword&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">connect</span><span class="p">()</span> <span class="o">*</span><span class="nx">sql</span><span class="p">.</span><span class="nx">DB</span> <span class="p">{</span>
	<span class="nx">connStr</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;postgres://%s:%s@localhost/pqgotest&#34;</span><span class="p">,</span> <span class="nx">user</span><span class="p">,</span> <span class="nx">password</span><span class="p">)</span>
	<span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">sql</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;postgres&#34;</span><span class="p">,</span> <span class="nx">connStr</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">db</span>
<span class="p">}</span>

<span class="c1">// bad
</span><span class="c1"></span><span class="kd">var</span> <span class="p">(</span>
	<span class="nx">commonkey</span> <span class="p">=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;0123456789abcdef&#34;</span><span class="p">)</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">AesEncrypt</span><span class="p">(</span><span class="nx">plaintext</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">block</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">aes</span><span class="p">.</span><span class="nf">NewCipher</span><span class="p">(</span><span class="nx">commonkey</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="162必须密钥存储安全">1.6.2【必须】密钥存储安全</h4>
<ul>
<li>在使用对称密码算法时，需要保护好加密密钥。当算法涉及敏感、业务数据时，可通过非对称算法协商加密密钥。其他较为不敏感的数据加密，可以通过变换算法等方式保护密钥。</li>
</ul>
<h4 id="163推荐不使用弱密码算法">1.6.3【推荐】不使用弱密码算法</h4>
<ul>
<li>在使用加密算法时，不建议使用加密强度较弱的算法。</li>
</ul>
<pre><code>// bad
crypto/des，crypto/md5，crypto/sha1，crypto/rc4等。

// good
crypto/rsa，crypto/aes等。
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="17-正则表达式">1.7 正则表达式</h3>
<h4 id="171推荐使用regexp进行正则表达式匹配">1.7.1【推荐】使用regexp进行正则表达式匹配</h4>
<ul>
<li>正则表达式编写不恰当可被用于DoS攻击，造成服务不可用，推荐使用regexp包进行正则表达式匹配。regexp保证了线性时间性能和优雅的失败：对解析器、编译器和执行引擎都进行了内存限制。但regexp不支持以下正则表达式特性，如业务依赖这些特性，则regexp不适合使用。
<ul>
<li>回溯引用<a href="https://www.regular-expressions.info/backref.html">Backreferences</a></li>
<li>查看<a href="https://www.regular-expressions.info/lookaround.html">Lookaround</a></li>
</ul>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// good
</span><span class="c1"></span><span class="nx">matched</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MatchString</span><span class="p">(</span><span class="s">`a.b`</span><span class="p">,</span> <span class="s">&#34;aaxbb&#34;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">matched</span><span class="p">)</span> <span class="c1">// true
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>     <span class="c1">// nil
</span></code></pre></div><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h1 id="后台类">后台类</h1>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h2 id="1-代码实现类-1">1 代码实现类</h2>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="11-输入校验">1.1 输入校验</h3>
<h4 id="111必须按类型进行数据校验">1.1.1【必须】按类型进行数据校验</h4>
<ul>
<li>所有外部输入的参数，应使用<code>validator</code>进行白名单校验，校验内容包括但不限于数据长度、数据范围、数据类型与格式，校验不通过的应当拒绝</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// good
</span><span class="c1"></span><span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;github.com/go-playground/validator/v10&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">validate</span> <span class="o">*</span><span class="nx">validator</span><span class="p">.</span><span class="nx">Validate</span>

<span class="kd">func</span> <span class="nf">validateVariable</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">myEmail</span> <span class="o">:=</span> <span class="s">&#34;abc@tencent.com&#34;</span>
	<span class="nx">errs</span> <span class="o">:=</span> <span class="nx">validate</span><span class="p">.</span><span class="nf">Var</span><span class="p">(</span><span class="nx">myEmail</span><span class="p">,</span> <span class="s">&#34;required,email&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">errs</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">errs</span><span class="p">)</span>
		<span class="k">return</span>
		<span class="c1">//停止执行
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="c1">// 验证通过，继续执行
</span><span class="c1"></span>	<span class="o">...</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">validate</span> <span class="p">=</span> <span class="nx">validator</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="nf">validateVariable</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>无法通过白名单校验的应使用<code>html.EscapeString</code>、<code>text/template</code>或<code>bluemonday</code>对<code>&lt;, &gt;, &amp;, ',&quot;</code>等字符进行过滤或编码</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;text/template&#34;</span>
<span class="p">)</span>

<span class="c1">// TestHTMLEscapeString HTML特殊字符转义
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">main</span><span class="p">(</span><span class="nx">inputValue</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">escapedResult</span> <span class="o">:=</span> <span class="nx">template</span><span class="p">.</span><span class="nf">HTMLEscapeString</span><span class="p">(</span><span class="nx">inputValue</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">escapedResult</span>
<span class="p">}</span>
</code></pre></div><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="12-sql操作">1.2 SQL操作</h3>
<h4 id="121必须sql语句默认使用预编译并绑定变量">1.2.1【必须】SQL语句默认使用预编译并绑定变量</h4>
<ul>
<li>使用<code>database/sql</code>的prepare、Query或使用GORM等ORM执行SQL操作</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/jinzhu/gorm&#34;</span>
	<span class="nx">_</span> <span class="s">&#34;github.com/jinzhu/gorm/dialects/sqlite&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Product</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">gorm</span><span class="p">.</span><span class="nx">Model</span>
	<span class="nx">Code</span>  <span class="kt">string</span>
	<span class="nx">Price</span> <span class="kt">uint</span>
<span class="p">}</span>

<span class="o">...</span>
<span class="kd">var</span> <span class="nx">product</span> <span class="nx">Product</span>
<span class="o">...</span>
<span class="nx">db</span><span class="p">.</span><span class="nf">First</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">product</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div><ul>
<li>使用参数化查询，禁止拼接SQL语句，另外对于传入参数用于order by或表名的需要通过校验</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// bad
</span><span class="c1"></span><span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;database/sql&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">handler</span><span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">sql</span><span class="p">.</span><span class="nx">DB</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">q</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=&#39;%s&#39; ORDER BY PRICE&#34;</span><span class="p">,</span>
		<span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nf">Query</span><span class="p">()[</span><span class="s">&#34;category&#34;</span><span class="p">])</span>
	<span class="nx">db</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// good
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">handlerGood</span><span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">sql</span><span class="p">.</span><span class="nx">DB</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 使用?占位符
</span><span class="c1"></span>	<span class="nx">q</span> <span class="o">:=</span> <span class="s">&#34;SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=&#39;?&#39; ORDER BY PRICE&#34;</span>
	<span class="nx">db</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="nx">q</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nf">Query</span><span class="p">()[</span><span class="s">&#34;category&#34;</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></div><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="13-网络请求">1.3 网络请求</h3>
<h4 id="131必须资源请求过滤验证">1.3.1【必须】资源请求过滤验证</h4>
<ul>
<li>
<p>使用<code>&quot;net/http&quot;</code>下的方法<code>http.Get(url)</code>、<code>http.Post(url, contentType, body)</code>、<code>http.Head(url)</code>、<code>http.PostForm(url, data)</code>、<code>http.Do(req)</code>时，如变量值外部可控（指从参数中动态获取），应对请求目标进行严格的安全校验。</p>
</li>
<li>
<p>如请求资源域名归属固定的范围，如只允许<code>a.qq.com</code>和<code>b.qq.com</code>，应做白名单限制。如不适用白名单，则推荐的校验逻辑步骤是：</p>
<ul>
<li>
<p>第 1 步、只允许HTTP或HTTPS协议</p>
</li>
<li>
<p>第 2 步、解析目标URL，获取其HOST</p>
</li>
<li>
<p>第 3 步、解析HOST，获取HOST指向的IP地址转换成Long型</p>
</li>
<li>
<p>第 4 步、检查IP地址是否为内网IP，网段有：</p>
<pre><code>// 以RFC定义的专有网络为例，如有自定义私有网段亦应加入禁止访问列表。
10.0.0.0/8
172.16.0.0/12
192.168.0.0/16
127.0.0.0/8
</code></pre></li>
<li>
<p>第 5 步、请求URL</p>
</li>
<li>
<p>第 6 步、如有跳转，跳转后执行1，否则绑定经校验的ip和域名，对URL发起请求</p>
</li>
</ul>
</li>
<li>
<p>官方库<code>encoding/xml</code>不支持外部实体引用，使用该库可避免xxe漏洞</p>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;encoding/xml&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;os&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">XMLName</span>  <span class="nx">xml</span><span class="p">.</span><span class="nx">Name</span> <span class="s">`xml:&#34;person&#34;`</span>
		<span class="nx">Id</span>       <span class="kt">int</span>      <span class="s">`xml:&#34;id,attr&#34;`</span>
		<span class="nx">UserName</span> <span class="kt">string</span>   <span class="s">`xml:&#34;name&gt;first&#34;`</span>
		<span class="nx">Comment</span>  <span class="kt">string</span>   <span class="s">`xml:&#34;,comment&#34;`</span>
	<span class="p">}</span>

	<span class="nx">v</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Person</span><span class="p">{</span><span class="nx">Id</span><span class="p">:</span> <span class="mi">13</span><span class="p">,</span> <span class="nx">UserName</span><span class="p">:</span> <span class="s">&#34;John&#34;</span><span class="p">}</span>
	<span class="nx">v</span><span class="p">.</span><span class="nx">Comment</span> <span class="p">=</span> <span class="s">&#34; Need more details. &#34;</span>

	<span class="nx">enc</span> <span class="o">:=</span> <span class="nx">xml</span><span class="p">.</span><span class="nf">NewEncoder</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">)</span>
	<span class="nx">enc</span><span class="p">.</span><span class="nf">Indent</span><span class="p">(</span><span class="s">&#34;  &#34;</span><span class="p">,</span> <span class="s">&#34;    &#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">enc</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;error: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="14-服务器端渲染">1.4 服务器端渲染</h3>
<h4 id="141必须模板渲染过滤验证">1.4.1【必须】模板渲染过滤验证</h4>
<ul>
<li>使用<code>text/template</code>或者<code>html/template</code>渲染模板时禁止将外部输入参数引入模板，或仅允许引入白名单内字符。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// bad
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">handler</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">ParseForm</span><span class="p">()</span>
	<span class="nx">x</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Form</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;name&#34;</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">tmpl</span> <span class="p">=</span> <span class="s">`&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;
</span><span class="s">    &lt;form action=&#34;https://kcode.icu/&#34; method=&#34;post&#34;&gt;
</span><span class="s">        First name:&lt;br&gt;
</span><span class="s">    &lt;input type=&#34;text&#34; name=&#34;name&#34; value=&#34;&#34;&gt;
</span><span class="s">    &lt;input type=&#34;submit&#34; value=&#34;Submit&#34;&gt;
</span><span class="s">    &lt;/form&gt;&lt;p&gt;`</span> <span class="o">+</span> <span class="nx">x</span> <span class="o">+</span> <span class="s">` &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;`</span>

	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">template</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;main&#34;</span><span class="p">)</span>
	<span class="nx">t</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">tmpl</span><span class="p">)</span>
	<span class="nx">t</span><span class="p">.</span><span class="nf">Execute</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;Hello&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// good
</span><span class="c1"></span><span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;github.com/go-playground/validator/v10&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">validate</span> <span class="o">*</span><span class="nx">validator</span><span class="p">.</span><span class="nx">Validate</span>
<span class="nx">validate</span> <span class="p">=</span> <span class="nx">validator</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

<span class="kd">func</span> <span class="nf">validateVariable</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">errs</span> <span class="o">:=</span> <span class="nx">validate</span><span class="p">.</span><span class="nf">Var</span><span class="p">(</span><span class="nx">val</span><span class="p">,</span> <span class="s">&#34;gte=1,lte=100&#34;</span><span class="p">)</span> <span class="c1">// 限制必须是1-100的正整数
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">errs</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">errs</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">handler</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">ParseForm</span><span class="p">()</span>
	<span class="nx">x</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Form</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;name&#34;</span><span class="p">)</span>

	<span class="k">if</span> <span class="nf">validateVariable</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">tmpl</span> <span class="p">=</span> <span class="s">`&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;
</span><span class="s">            &lt;form action=&#34;https://kcode.icu/&#34; method=&#34;post&#34;&gt;
</span><span class="s">            First name:&lt;br&gt;
</span><span class="s">            &lt;input type=&#34;text&#34; name=&#34;name&#34; value=&#34;&#34;&gt;
</span><span class="s">            &lt;input type=&#34;submit&#34; value=&#34;Submit&#34;&gt;
</span><span class="s">            &lt;/form&gt;&lt;p&gt;`</span> <span class="o">+</span> <span class="nx">x</span> <span class="o">+</span> <span class="s">` &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;`</span>
		<span class="nx">t</span> <span class="o">:=</span> <span class="nx">template</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;main&#34;</span><span class="p">)</span>
		<span class="nx">t</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">tmpl</span><span class="p">)</span>
		<span class="nx">t</span><span class="p">.</span><span class="nf">Execute</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;Hello&#34;</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// ...
</span><span class="c1"></span>	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="15-web跨域">1.5 Web跨域</h3>
<h4 id="151必须跨域资源共享cors限制请求来源">1.5.1【必须】跨域资源共享CORS限制请求来源</h4>
<ul>
<li>CORS请求保护不当可导致敏感信息泄漏，因此应当严格设置Access-Control-Allow-Origin使用同源策略进行保护。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// good
</span><span class="c1"></span><span class="nx">c</span> <span class="o">:=</span> <span class="nx">cors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">cors</span><span class="p">.</span><span class="nx">Options</span><span class="p">{</span>
	<span class="nx">AllowedOrigins</span><span class="p">:</span>   <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;http://qq.com&#34;</span><span class="p">,</span> <span class="s">&#34;https://qq.com&#34;</span><span class="p">},</span>
	<span class="nx">AllowCredentials</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
	<span class="nx">Debug</span><span class="p">:</span>            <span class="kc">false</span><span class="p">,</span>
<span class="p">})</span>

<span class="c1">// 引入中间件
</span><span class="c1"></span><span class="nx">handler</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Handler</span><span class="p">(</span><span class="nx">handler</span><span class="p">)</span>
</code></pre></div><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="16-响应输出">1.6 响应输出</h3>
<h4 id="161-必须设置正确的http响应包类型">1.6.1 【必须】设置正确的HTTP响应包类型</h4>
<ul>
<li>响应头Content-Type与实际响应内容，应保持一致。如：API响应数据类型是json，则响应头使用<code>application/json</code>；若为xml，则设置为<code>text/xml</code>。</li>
</ul>
<h4 id="162-必须添加安全响应头">1.6.2 【必须】添加安全响应头</h4>
<ul>
<li>所有接口、页面，添加响应头 <code>X-Content-Type-Options: nosniff</code>。</li>
<li>所有接口、页面，添加响应头<code>X-Frame-Options </code>。按需合理设置其允许范围，包括：<code>DENY</code>、<code>SAMEORIGIN</code>、<code>ALLOW-FROM origin</code>。用法参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options">MDN文档</a></li>
</ul>
<h4 id="163必须外部输入拼接到http响应头中需进行过滤">1.6.3【必须】外部输入拼接到HTTP响应头中需进行过滤</h4>
<ul>
<li>应尽量避免外部可控参数拼接到HTTP响应头中，如业务需要则需要过滤掉<code>\r</code>、<code>\n</code>等换行符，或者拒绝携带换行符号的外部输入。</li>
</ul>
<h4 id="164必须外部输入拼接到response页面前进行编码处理">1.6.4【必须】外部输入拼接到response页面前进行编码处理</h4>
<ul>
<li>直出html页面或使用模板生成html页面的，推荐使用<code>text/template</code>自动编码，或者使用<code>html.EscapeString</code>或<code>text/template</code>对<code>&lt;, &gt;, &amp;, ',&quot;</code>等字符进行编码。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;html/template&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">outtemplate</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">param1</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nf">Query</span><span class="p">().</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;param1&#34;</span><span class="p">)</span>
	<span class="nx">tmpl</span> <span class="o">:=</span> <span class="nx">template</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>
	<span class="nx">tmpl</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">tmpl</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="s">`</span><span class="cp">{{</span><span class="nx">define</span><span class="w"> </span><span class="s">&#34;T&#34;</span><span class="cp">}}{{</span><span class="na">.</span><span class="cp">}}{{</span><span class="k">end</span><span class="cp">}}</span><span class="s">`</span><span class="p">)</span>
	<span class="nx">tmpl</span><span class="p">.</span><span class="nf">ExecuteTemplate</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;T&#34;</span><span class="p">,</span> <span class="nx">param1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="17-会话管理">1.7 会话管理</h3>
<h4 id="171必须安全维护session信息">1.7.1【必须】安全维护session信息</h4>
<ul>
<li>用户登录时应重新生成session，退出登录后应清理session。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/gorilla/handlers&#34;</span>
	<span class="s">&#34;github.com/gorilla/mux&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
<span class="p">)</span>

<span class="c1">// 创建cookie
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">setToken</span><span class="p">(</span><span class="nx">res</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">expireToken</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Minute</span> <span class="o">*</span> <span class="mi">30</span><span class="p">).</span><span class="nf">Unix</span><span class="p">()</span>
	<span class="nx">expireCookie</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Minute</span> <span class="o">*</span> <span class="mi">30</span><span class="p">)</span>

	<span class="c1">//...
</span><span class="c1"></span>
	<span class="nx">cookie</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Cookie</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span>     <span class="s">&#34;Auth&#34;</span><span class="p">,</span>
		<span class="nx">Value</span><span class="p">:</span>    <span class="nx">signedToken</span><span class="p">,</span>
		<span class="nx">Expires</span><span class="p">:</span>  <span class="nx">expireCookie</span><span class="p">,</span> <span class="c1">// 过期失效
</span><span class="c1"></span>		<span class="nx">HttpOnly</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
		<span class="nx">Path</span><span class="p">:</span>     <span class="s">&#34;/&#34;</span><span class="p">,</span>
		<span class="nx">Domain</span><span class="p">:</span>   <span class="s">&#34;127.0.0.1&#34;</span><span class="p">,</span>
		<span class="nx">Secure</span><span class="p">:</span>   <span class="kc">true</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nx">http</span><span class="p">.</span><span class="nf">SetCookie</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">cookie</span><span class="p">)</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">Redirect</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">req</span><span class="p">,</span> <span class="s">&#34;/profile&#34;</span><span class="p">,</span> <span class="mi">307</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 删除cookie
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">logout</span><span class="p">(</span><span class="nx">res</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">deleteCookie</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Cookie</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span>    <span class="s">&#34;Auth&#34;</span><span class="p">,</span>
		<span class="nx">Value</span><span class="p">:</span>   <span class="s">&#34;none&#34;</span><span class="p">,</span>
		<span class="nx">Expires</span><span class="p">:</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">(),</span>
	<span class="p">}</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">SetCookie</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">deleteCookie</span><span class="p">)</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div><h4 id="172必须csrf防护">1.7.2【必须】CSRF防护</h4>
<ul>
<li>涉及系统敏感操作或可读取敏感信息的接口应校验<code>Referer</code>或添加<code>csrf_token</code>。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// good
</span><span class="c1"></span><span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/gorilla/csrf&#34;</span>
	<span class="s">&#34;github.com/gorilla/mux&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">mux</span><span class="p">.</span><span class="nf">NewRouter</span><span class="p">()</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/signup&#34;</span><span class="p">,</span> <span class="nx">ShowSignupForm</span><span class="p">)</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/signup/post&#34;</span><span class="p">,</span> <span class="nx">SubmitSignupForm</span><span class="p">)</span>
	<span class="c1">// 使用csrf_token验证
</span><span class="c1"></span>	<span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8000&#34;</span><span class="p">,</span>
		<span class="nx">csrf</span><span class="p">.</span><span class="nf">Protect</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;32-byte-long-auth-key&#34;</span><span class="p">))(</span><span class="nx">r</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="18-访问控制">1.8 访问控制</h3>
<h4 id="181必须默认鉴权">1.8.1【必须】默认鉴权</h4>
<ul>
<li>
<p>除非资源完全可对外开放，否则系统默认进行身份认证，使用白名单的方式放开不需要认证的接口或页面。</p>
</li>
<li>
<p>根据资源的机密程度和用户角色，以最小权限原则，设置不同级别的权限，如完全公开、登录可读、登录可写、特定用户可读、特定用户可写等</p>
</li>
<li>
<p>涉及用户自身相关的数据的读写必须验证登录态用户身份及其权限，避免越权操作</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- 伪代码
</span><span class="c1"></span><span class="k">select</span> <span class="n">id</span> <span class="k">from</span> <span class="k">table</span> <span class="k">where</span> <span class="n">id</span><span class="o">=</span><span class="p">:</span><span class="n">id</span> <span class="k">and</span> <span class="n">userid</span><span class="o">=</span><span class="k">session</span><span class="p">.</span><span class="n">userid</span>
</code></pre></div></li>
<li>
<p>没有独立账号体系的外网服务使用<code>QQ</code>或<code>微信</code>登录，内网服务使用<code>统一登录服务</code>登录，其他使用账号密码登录的服务需要增加验证码等二次验证</p>
</li>
</ul>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="19-并发保护">1.9 并发保护</h3>
<h4 id="191必须禁止在闭包中直接调用循环变量">1.9.1【必须】禁止在闭包中直接调用循环变量</h4>
<ul>
<li>在循环中启动协程，当协程中使用到了循环的索引值，由于多个协程同时使用同一个变量会产生数据竞争，造成执行结果异常。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// bad
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="nx">runtime</span><span class="p">.</span><span class="nf">NumCPU</span><span class="p">())</span>
	<span class="kd">var</span> <span class="nx">group</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">group</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="nx">group</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%-2d&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="c1">// 这里打印的i不是所期望的
</span><span class="c1"></span>		<span class="p">}()</span>
	<span class="p">}</span>
	<span class="nx">group</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// good
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="nx">runtime</span><span class="p">.</span><span class="nf">NumCPU</span><span class="p">())</span>
	<span class="kd">var</span> <span class="nx">group</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">group</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">r</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">r</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Recovered in start()&#34;</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="nx">group</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
			<span class="p">}()</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%-2d&#34;</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span> <span class="c1">// 闭包内部使用局部变量
</span><span class="c1"></span>		<span class="p">}(</span><span class="nx">i</span><span class="p">)</span> <span class="c1">// 把循环变量显式地传给协程
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="nx">group</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><h4 id="192必须禁止并发写map">1.9.2【必须】禁止并发写map</h4>
<ul>
<li>并发写map容易造成程序崩溃并异常退出，建议加锁保护</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// bad
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="c1">// 并发读写
</span><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="nx">_</span> <span class="p">=</span> <span class="nx">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="nx">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="k">select</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div><h4 id="193必须确保并发安全">1.9.3【必须】确保并发安全</h4>
<p>敏感操作如果未作并发安全限制，可导致数据读写异常，造成业务逻辑限制被绕过。可通过同步锁或者原子操作进行防护。</p>
<p>通过同步锁共享内存</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// good
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">count</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="nf">Count</span><span class="p">(</span><span class="nx">lock</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">lock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span> <span class="c1">// 加写锁
</span><span class="c1"></span>	<span class="nx">count</span><span class="o">++</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span>
	<span class="nx">lock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span> <span class="c1">// 解写锁，任何一个Lock()或RLock()均需要保证对应有Unlock()或RUnlock()
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">lock</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">{}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="nf">Count</span><span class="p">(</span><span class="nx">lock</span><span class="p">)</span> <span class="c1">// 传递指针是为了防止函数内的锁和调用锁不一致
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">lock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="nx">c</span> <span class="o">:=</span> <span class="nx">count</span>
		<span class="nx">lock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="nx">runtime</span><span class="p">.</span><span class="nf">Gosched</span><span class="p">()</span> <span class="c1">// 交出时间片给协程
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">c</span> <span class="p">&gt;</span> <span class="mi">10</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>使用<code>sync/atomic</code>执行原子操作</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// good
</span><span class="c1"></span><span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;sync/atomic&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">type</span> <span class="nx">Map</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
	<span class="kd">var</span> <span class="nx">m</span> <span class="nx">atomic</span><span class="p">.</span><span class="nx">Value</span>
	<span class="nx">m</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nb">make</span><span class="p">(</span><span class="nx">Map</span><span class="p">))</span>
	<span class="kd">var</span> <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// used only by writers
</span><span class="c1"></span>	<span class="nx">read</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">val</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">m1</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="nx">Map</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">m1</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="nx">insert</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span> <span class="c1">// 与潜在写入同步
</span><span class="c1"></span>		<span class="k">defer</span> <span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="nx">m1</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="nx">Map</span><span class="p">)</span> <span class="c1">// 导入struct当前数据
</span><span class="c1"></span>		<span class="nx">m2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">Map</span><span class="p">)</span>      <span class="c1">// 创建新值
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m1</span> <span class="p">{</span>
			<span class="nx">m2</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="p">=</span> <span class="nx">v</span>
		<span class="p">}</span>
		<span class="nx">m2</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">val</span>
		<span class="nx">m</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">m2</span><span class="p">)</span> <span class="c1">// 用新的替代当前对象
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">read</span><span class="p">,</span> <span class="nx">insert</span>
<span class="p">}</span>
</code></pre></div>]]></content></item><item><title>聊聊 22 届秋招的体验</title><link>https://kcode.icu/posts/interview/2021-12-interview/</link><pubDate>Sun, 21 Nov 2021 21:22:20 +0000</pubDate><guid>https://kcode.icu/posts/interview/2021-12-interview/</guid><description>今年的秋招早已结束了，因为我躺平了一个多月，所以这篇博客拖到了现在。</description><content type="html">&lt;p>今年的秋招早已结束了，因为我躺平了一个多月，所以这篇博客拖到了现在。&lt;/p></content></item><item><title>最近两个月及远程实习半个月小记</title><link>https://kcode.icu/posts/chore/2021-06-19-recent-life/</link><pubDate>Sat, 19 Jun 2021 15:00:13 +0000</pubDate><guid>https://kcode.icu/posts/chore/2021-06-19-recent-life/</guid><description>自 3 月末完成许多轮线上面试，4 月初拿到 offer，到现在因疫情远程实习，已经过去2个多月了，时间真的一晃就过去了，虽说还没拿到正式的秋招 offer，但也距离面试不远了，有必要记录一下这段时间的生活，顺便总结反思。
前段时间 在拿到实习 offer 后，和之前学习状态相比有点佛系，一方面是因为阶段性的目标没了，短时间内没有下一个目标；另一方面是把重心从看/背知识点转移到了深入思考，理解上来了。因为在准备时有一些知识难免是死记硬背的，或者理解不透彻，需要复现并弄清楚。
针对第一方面，其实我之前已经有了另一个目标的雏形，也是针对我的简历项目比较薄弱。就是寻找一个 “亮眼” 的项目来丰富简历上的项目部分，思前想后主要有四大块方向，竞赛类项目，开源贡献，造轮子，还有 秒杀/CRUD 类。
竞赛类项目是一些参加比赛的项目，比如一年一次的微信小程序开发大赛，用小程序解决一个实际问题或者开发一个趣味游戏。这个我现在来不及了，不适合。开源贡献这块我一直在关注 GSoC，奈何要求确实略高，另外需要提前至少 1-2 个月进行准备，为目标社区的项目贡献，联系导师等，之前加入了国内 GSoC 的 Gitter 社区讨论群，在 5 月恰巧看到群里有人说国内也搞了个开源夏令营，模仿谷歌的，是第二年举办，我就参加了，贡献了半个多月，累计 PR 10 个左右 ，也是常常肝到凌晨，目前结果怎么样还未知，不过学习到的东西真的很多，例如更多的 Git 用法，开源规范，还有具体项目的知识。这个如果成功了我觉得也应该比单纯的 CRUD 好（希望😄
参加这类夏令营，大多都不看重 proposal，也就是申请书/简历一类的，强调在实际贡献中体现代码及工程能力，所以要提前一段时间准备，了解项目。
造轮子就是创造一些小工具，这个需要有一定的代码能力，做得好了也很加分，但是我觉得写 用 tcp 实现 http，json 解析器之类的可以自己写，就没必要写简历上了，一来没啥问的，二来没啥实际用途。我个人是用 Go 写了个 rpc 框架的小轮子，不过难点也很多，很容易被怼。
秒杀/CRUD 类就是常见的 xx管理系统，多做一些 CRUD 的操作，不推荐，除非吃透不怕问，不过我觉得面试官比你更懂秒杀（​逃😆
除了简历，我也在思考一些常见问题如何回答的更深入，例如常见的 https，select/poll/epoll，memory，file system等等，这些问题想要答的透彻，基本都要看源码，看底层设计实现，比较耗时，但是能将清楚非常加分，也是拿到 sp/ssp 的关键一环。
近期实习 由于疫情远程参与了实习，前期也比较闲，主要是熟悉产品，在内网逛逛😄，不得不说，来大厂实习的一大好处就是可以体验一下大厂内部的环境。好多都是自研，确实方便。
很多资料，格式/规范，除非一部分实习生没权限之外（比如腾讯的乐问），技术资料都公开。因为可能是出售的产品，所以有的代码是不能访问，需要开权限才能访问。当然内部开源的工具的源码还是随便看的。
等疫情过去，7 月多我就过去线下实习体验一下，还是挺期待现场实习的。
2021.6.30 16:02更新，已入选~
顺便吐槽一下，入选有时候真的看运气，有的项目4、5个人，卷的飞起，10 几个PR不一定能进，有的没人，可能写个申请书随便交点PR就进了 😂</description><content type="html"><![CDATA[<p>自 3 月末完成许多轮线上面试，4 月初拿到 offer，到现在因疫情远程实习，已经过去2个多月了，时间真的一晃就过去了，虽说还没拿到正式的秋招 offer，但也距离面试不远了，有必要记录一下这段时间的生活，顺便总结反思。</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/image-20210619155644748.png" alt="image-20210619155644748"></p>
<h2 id="前段时间">前段时间</h2>
<p>在拿到实习 offer 后，和之前学习状态相比有点佛系，一方面是因为阶段性的目标没了，短时间内没有下一个目标；另一方面是把重心从看/背知识点转移到了深入思考，理解上来了。因为在准备时有一些知识难免是死记硬背的，或者理解不透彻，需要复现并弄清楚。</p>
<p>针对第一方面，其实我之前已经有了另一个目标的雏形，也是针对我的简历项目比较薄弱。就是寻找一个  “亮眼” 的项目来丰富简历上的项目部分，思前想后主要有四大块方向，<strong>竞赛类项目</strong>，<strong>开源贡献</strong>，<strong>造轮子</strong>，还有 <strong>秒杀/CRUD 类</strong>。</p>
<p>竞赛类项目是一些参加比赛的项目，比如一年一次的微信小程序开发大赛，用小程序解决一个实际问题或者开发一个趣味游戏。这个我现在来不及了，不适合。开源贡献这块我一直在关注 GSoC，奈何要求确实略高，另外需要提前至少 1-2 个月进行准备，为目标社区的项目贡献，联系导师等，之前加入了国内 GSoC 的 Gitter 社区讨论群，在 5 月恰巧看到群里有人说国内也搞了个开源夏令营，模仿谷歌的，是第二年举办，我就参加了，贡献了半个多月，累计 PR 10 个左右 ，也是常常肝到凌晨，目前结果怎么样还未知，不过学习到的东西真的很多，例如更多的 Git 用法，开源规范，还有具体项目的知识。这个如果成功了我觉得也应该比单纯的 CRUD 好（希望😄</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/image-20210703211531387.png" alt="image-20210703211531387"></p>
<p>参加这类夏令营，大多都不看重 proposal，也就是申请书/简历一类的，强调在实际贡献中体现代码及工程能力，所以要提前一段时间准备，了解项目。</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/image-20210619163352964.png" alt="image-20210619163352964"></p>
<p>造轮子就是创造一些小工具，这个需要有一定的代码能力，做得好了也很加分，但是我觉得写 用 tcp 实现 http，json 解析器之类的可以自己写，就没必要写简历上了，一来没啥问的，二来没啥实际用途。我个人是用 Go 写了个 rpc 框架的小轮子，不过难点也很多，很容易被怼。</p>
<p>秒杀/CRUD 类就是常见的 xx管理系统，多做一些 CRUD 的操作，不推荐，除非吃透不怕问，不过我觉得面试官比你更懂秒杀（​逃😆</p>
<hr>
<p>除了简历，我也在思考一些常见问题如何回答的更深入，例如常见的 https，select/poll/epoll，memory，file system等等，这些问题想要答的透彻，基本都要看源码，看底层设计实现，比较耗时，但是能将清楚非常加分，也是拿到  sp/ssp 的关键一环。</p>
<h2 id="近期实习">近期实习</h2>
<p>由于疫情远程参与了实习，前期也比较闲，主要是熟悉产品，在内网逛逛😄，不得不说，来大厂实习的一大好处就是可以体验一下大厂内部的环境。好多都是自研，确实方便。</p>
<p>很多资料，格式/规范，除非一部分实习生没权限之外（比如腾讯的乐问），技术资料都公开。因为可能是出售的产品，所以有的代码是不能访问，需要开权限才能访问。当然内部开源的工具的源码还是随便看的。</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/image-20210703211945974.png" alt="image-20210703211945974"></p>
<p>等疫情过去，7 月多我就过去线下实习体验一下，还是挺期待现场实习的。</p>
<blockquote>
<p>2021.6.30 16:02更新，已入选~</p>
<p>顺便吐槽一下，入选有时候真的看运气，有的项目4、5个人，卷的飞起，10 几个PR不一定能进，有的没人，可能写个申请书随便交点PR就进了 😂</p>
</blockquote>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/image-20210630160301943.png" alt="image-20210630160301943"></p>
]]></content></item><item><title>面试官：如何只使用一个指针域实现双向链表</title><link>https://kcode.icu/posts/interview/2021-06-05-%E5%A6%82%E4%BD%95%E5%8F%AA%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E5%9F%9F%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link><pubDate>Sat, 05 Jun 2021 14:36:20 +0000</pubDate><guid>https://kcode.icu/posts/interview/2021-06-05-%E5%A6%82%E4%BD%95%E5%8F%AA%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E5%9F%9F%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid><description>这是来自某学习群的群友提供的，一道 便利蜂 的实习面试题，恰好被看到了（不是
问题是：只使用一个指针如何实现双向链表，乍一想好像不可能，我当时的大致思路是这样的：原来直接使用 -&amp;gt;right 或者 -&amp;gt;left 就能访问到左右节点，现在只有一个指针，就要修改指针的含义，不能直接存储下一个节点的地址了，大概率是要根据某些条件算出下一个地址。
事实呢？为了了解具体做法，我去翻了维基百科关于这部分的 详细解释 ，并本地实现了一遍完整代码，记录在这里。
实现原理 这种链表被称为 异或链表（XOR Linked List），能够达到只使用一个指针域实现双向链表的效果，从而降低空间复杂度。当然它也不是没有缺点，如果只有一个节点，无法向两个方向遍历，必须有连续的两个节点地址。
回到之前说的问题，问题的关键就是如何只使用一个指针实现双向访问的效果，再来看链表名，异或链表。
任何一个节点的指针域的值为 它的前一个节点和下一个节点的地址异或。
假如现在有 3 个节点分别为 A,B 和 C，地址分别为 0x1,0x2,0x3，那么，
A.next = null^0x2 B.next = 0x1^0x3 C.next = 0x2^null XOR linked List +--- -----+ next=0x1 +---------+ next=0x1^0x3 +---------+ | *A=0x1 +--------- | *B=0x2 +------------ | *C=0x3 | +---------+ +---------+ +------+--+ | | | next=0x2 | | | next=0x1 | | +------+--+ +---------+ | null | | null | +---------+ +---------+ 这个图之所以没有画出箭头是因为这里并不是直接指向下一个节点的地址，而是需要和前一个节点异或计算才能得到下一个节点的地址。</description><content type="html"><![CDATA[<p>这是来自某学习群的群友提供的，一道 <a href="https://www.bianlifeng.com/">便利蜂</a> 的实习面试题，恰好被看到了（不是</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/image-20210605145233924.png" alt="image-20210605145233924"></p>
<p>问题是：只使用一个指针如何实现双向链表，乍一想好像不可能，我当时的大致思路是这样的：原来直接使用 <code>-&gt;right</code> 或者 <code>-&gt;left</code> 就能访问到左右节点，现在只有一个指针，就要修改指针的含义，不能直接存储下一个节点的地址了，大概率是要根据某些条件算出下一个地址。</p>
<p>事实呢？为了了解具体做法，我去翻了维基百科关于这部分的 <a href="https://en.wikipedia.org/wiki/XOR_linked_list">详细解释</a> ，并本地实现了一遍完整代码，记录在这里。</p>
<h2 id="实现原理">实现原理</h2>
<p>这种链表被称为 <strong>异或链表</strong>（XOR Linked List），能够达到只使用一个指针域实现双向链表的效果，从而降低空间复杂度。当然它也不是没有缺点，如果只有一个节点，无法向两个方向遍历，必须有连续的两个节点地址。</p>
<p>回到之前说的问题，问题的关键就是如何只使用一个指针实现双向访问的效果，再来看链表名，异或链表。</p>
<p>任何一个节点的指针域的值为 它的前一个节点和下一个节点的地址异或。</p>
<p>假如现在有 3 个节点分别为 A,B 和 C，地址分别为 0x1,0x2,0x3，那么，</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">A</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">null</span><span class="o">^</span><span class="mh">0x2</span>
<span class="n">B</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="mh">0x1</span><span class="o">^</span><span class="mh">0x3</span>
<span class="n">C</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="mh">0x2</span><span class="o">^</span><span class="n">null</span>
</code></pre></div><pre><code>                         XOR linked List



   +--- -----+ next=0x1    +---------+ next=0x1^0x3   +---------+
   | *A=0x1  +---------    | *B=0x2  +------------    | *C=0x3  |
   +---------+             +---------+                +------+--+
                                                             |
       |                                                     | next=0x2
       |                                                     |
       | next=0x1                                            |
       |
+------+--+                                               +---------+
|  null   |                                               |  null   |
+---------+                                               +---------+
</code></pre><p>这个图之所以没有画出箭头是因为这里并不是直接指向下一个节点的地址，而是需要和前一个节点异或计算才能得到下一个节点的地址。</p>
<p>由于遍历的时候需要知道前一个节点的地址，所以遍历方向也就确定了，所以需要用到当前节点的指针域参与异或运算。并不需要后一个节点的指针域。可能有一点绕，一直用前一个后一个的说法，不过结合一下上面这个图你就明白了。</p>
<h2 id="具体实现">具体实现</h2>
<p>需要实现链表的基本操作，构造/访问/删除/插入，这里的插入操作是在第 N 个节点之前，例如上图，如果 N = 2，那么就是在 A 与 B 之间插入，使新节点成为第二个节点。删除操作也是找到第 N 个节点。</p>
<h3 id="建表">建表</h3>
<h3 id="遍历">遍历</h3>
<h3 id="插入">插入</h3>
<h3 id="删除">删除</h3>
<h2 id="总结">总结</h2>
]]></content></item><item><title>正/反向代理与科学上网</title><link>https://kcode.icu/posts/2021-05-31-%E6%AD%A3%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</link><pubDate>Mon, 31 May 2021 15:33:50 +0000</pubDate><guid>https://kcode.icu/posts/2021-05-31-%E6%AD%A3%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</guid><description>代理
你可能听过许多 反向代理（Reverse Proxy） 软件例如 Nginx、Apache 等，它们性能优越，被广泛应用于实际场景中，那么你是否知道 “反向” 是什么意思，为什么叫反向呢，明白这个问题有助于我们更深入的理解它们。还有许多框架中常用的的 控制反转（IOC）/依赖注入（DI） 等概念，你是否理解 反转 或 注入 的真正含义。
既然有反向代理，就有正向代理，常用的科学上网就是使用了这个技术，你所见过的例如 ss/ssr/socks5 等等仅仅是协议名，配合上一些混淆方式，它们的技术原理还是 正向代理（ Forward Proxy）。
之前我在「刷」面试题的时候，就遇到过相关问题，“墙以及科学上网的原理”。相信读完这本文你会得到答案。
在了解正反向代理之前先牢记一句话，反向代理 代理并 隐藏服务端，正向代理与之相反，隐藏客户端。
反向代理 OK，记住了这句话，想想 Nginx/Apache 的功能，你将服务部署在服务器上，只公开了 80/443 端口，而内部服务有很多个，通过不同域名访问，然后使用 Nginx/Apache 来接受外界请求，利用提供的指令，例如 sever_name，listen，index，location 来控制其进行转发到不同的内部端口上，由于其使用了非常高效的 epoll IO多路复用模型，效率非常高。
那么你的脑海中应该有大致这么一张图，类似这样：
Reverse Proxy +------------------------------------------------------+ | | | +---------+ | | +-------&amp;gt; | Server1 | | | | +---------+ | +--------------+ | +-----------------+ | | | | | | | | +---------+ | | Client +-----------+--&amp;gt;| google.</description><content type="html"><![CDATA[<p>代理</p>
<p>你可能听过许多 <strong>反向代理（Reverse Proxy）</strong> 软件例如 Nginx、Apache 等，它们性能优越，被广泛应用于实际场景中，那么你是否知道 “反向” 是什么意思，为什么叫反向呢，明白这个问题有助于我们更深入的理解它们。还有许多框架中常用的的 <strong>控制反转（IOC）/依赖注入（DI）</strong> 等概念，你是否理解 <strong>反转</strong> 或 <strong>注入</strong> 的真正含义。</p>
<p>既然有反向代理，就有正向代理，常用的科学上网就是使用了这个技术，你所见过的例如 ss/ssr/socks5 等等仅仅是协议名，配合上一些混淆方式，它们的技术原理还是 <strong>正向代理（ Forward Proxy）</strong>。</p>
<p>之前我在「刷」面试题的时候，就遇到过相关问题，“墙以及科学上网的原理”。相信读完这本文你会得到答案。</p>
<p>在了解正反向代理之前先牢记一句话，<code>反向代理</code> 代理并 <strong>隐藏服务端</strong>，<code>正向代理</code>与之相反，<strong>隐藏客户端</strong>。</p>
<h2 id="反向代理">反向代理</h2>
<p>OK，记住了这句话，想想 Nginx/Apache 的功能，你将服务部署在服务器上，只公开了 80/443 端口，而内部服务有很多个，通过不同域名访问，然后使用 Nginx/Apache 来接受外界请求，利用提供的指令，例如 <code>sever_name</code>，<code>listen</code>，<code>index</code>，<code>location</code> 来控制其进行转发到不同的内部端口上，由于其使用了非常高效的 epoll IO多路复用模型，效率非常高。</p>
<p>那么你的脑海中应该有大致这么一张图，类似这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">                                 Reverse Proxy

                           +------------------------------------------------------+
                           <span class="p">|</span>                                                      <span class="p">|</span>
                           <span class="p">|</span>                                  +---------+         <span class="p">|</span>
                           <span class="p">|</span>                        +-------&gt; <span class="p">|</span> Server1 <span class="p">|</span>         <span class="p">|</span>
                           <span class="p">|</span>                        <span class="p">|</span>         +---------+         <span class="p">|</span>
+--------------+           <span class="p">|</span>   +-----------------+  <span class="p">|</span>                             <span class="p">|</span>
<span class="p">|</span>              <span class="p">|</span>           <span class="p">|</span>   <span class="p">|</span>                 <span class="p">|</span>  <span class="p">|</span>         +---------+         <span class="p">|</span>
<span class="p">|</span>    Client    +-----------+--&gt;<span class="p">|</span>   google.com    +-&gt;+--------&gt;<span class="p">|</span> Server2 <span class="p">|</span>         <span class="p">|</span>
<span class="p">|</span>              <span class="p">|</span>           <span class="p">|</span>   <span class="p">|</span>                 <span class="p">|</span>  <span class="p">|</span>         +---------+         <span class="p">|</span>
+--------------+           <span class="p">|</span>   +-----------------+  <span class="p">|</span>           ...               <span class="p">|</span>
                           <span class="p">|</span>                        <span class="p">|</span>         +---------+         <span class="p">|</span>
                           <span class="p">|</span>                        +--------&gt;<span class="p">|</span> Server99<span class="p">|</span>         <span class="p">|</span>
                           <span class="p">|</span>                                  +---------+         <span class="p">|</span>
                           <span class="p">|</span>                                                      <span class="p">|</span>
                           +------------------------------------------------------+
</code></pre></div><h2 id="正向代理">正向代理</h2>
<p>与反向代理相反，正向代理的作用是隐藏客户端，比较容易理解的例子还是科学上网，直接访问会受到运营商防火墙的限制例如 DNS 污染等导致查询失败。</p>
<p>而 “梯子”“代理”等等工具就是购买了一台服务器 S，在你需要请求这些受限网站 Google 时，直接请求 S，由于可以访问 S ，就由 S 替我们去访问 Google，再将结果返回给我们，就完成了一次 “科学上网”。</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">                                        Forward Proxy

+-----------------------------------------------------+
<span class="p">|</span>                                                     <span class="p">|</span>
<span class="p">|</span>                                                     <span class="p">|</span>
<span class="p">|</span>    +--------------+           +---------------+     <span class="p">|</span>             +--------------------+
<span class="p">|</span>    <span class="p">|</span>              <span class="p">|</span>           <span class="p">|</span>               <span class="p">|</span>     <span class="p">|</span>             <span class="p">|</span>                    <span class="p">|</span>
<span class="p">|</span>    <span class="p">|</span>    Client    +----------&gt;<span class="p">|</span>  Proxy Server +----&gt;<span class="p">|</span> -----------&gt;<span class="p">|</span>  Google/GitHub,etc <span class="p">|</span>
<span class="p">|</span>    <span class="p">|</span>              <span class="p">|</span>           <span class="p">|</span>               <span class="p">|</span>     <span class="p">|</span>             <span class="p">|</span>                    <span class="p">|</span>
<span class="p">|</span>    +--------------+           +---------------+     <span class="p">|</span>             +--------------------+
<span class="p">|</span>                                                     <span class="p">|</span>
<span class="p">|</span>                                                     <span class="p">|</span>
+-----------------------------------------------------+
</code></pre></div><p>当然，大致过程很简单，但是其中的细节非常多。为了限制网民的这种行为，会对访问境外的流量进行分析，如果有可疑特征，则直接拦截。现在甚至研究出了利用机器学习等技术智能审查流量的机。因此通过 SS/SSR 的方式由于特征明显，已经基本被淘汰。</p>
<h2 id="科学上网">科学上网</h2>
]]></content></item><item><title>极客时间专栏《RPC实战与核心原理》读后笔记</title><link>https://kcode.icu/posts/rpc/geektime-rpc/</link><pubDate>Fri, 14 May 2021 21:45:13 +0000</pubDate><guid>https://kcode.icu/posts/rpc/geektime-rpc/</guid><description>对 RPC 相关的学习也有了一段时间，算是有了一个初步的认识，回过头来读 极客时间的专栏 感觉思路清晰了不少，顺利了许多，再回头看 rpcx 的源码也没有那么费劲了。我把我在这个专栏中学到的一些内容记录下来，共同学习。
本文不再解释 RPC 相关基础概念，有需要可在上文链接或者往期文章中学习。
以下的二级标题均对应专栏的课程大纲，同样分单元总结。
开篇词 开篇词介绍了 RPC 的使用场景，重要意义，作为引文。
RPC 即远程过程调用，目的是使调用另一台机器上的程序就像调用本地程序一样简单。总是和 “微服务”，SOA 联系，其实理论上来说，任何牵扯到网络通信的系统都可能需要使用 RPC。比如分布式各个组件间或与应用间的通信，比如 etcd 作为统一的配置服务，客户端就是通过 gRPC 框架与服务端进行通信的。
RPC 是解决分布式系统通信问题的一大利器。 RPC 的通信原理十分简单，可是想完美驾驭却不那么容易，这个过程除了调用过程之外，还主要包括：通信节点查找，连接的建立与状态管理，数据传输的编解码，序列化与反序列化等等，每一项都十分复杂。
而完整的 RPC 框架却对上述过程进行了封装，使得网络通信逻辑的开发变得十分简单，效率也会更高。
最初的我学习 RPC 也是由浅入深，从 “字面意思” 出发，即如何调用远程主机上的某个函数，实现了编解码，序列化等等一整套调用流程，成功执行了远程主机的程序，当然了，这还是点对点的。
后来我发现这些仅仅是基础，冰山下的还包括一系列服务治理功能：连接管理，健康检测，负载均衡，优雅启停机，异常重试，业务分组以及熔断限流等等。十分复杂又充满了挑战性。</description><content type="html"><![CDATA[<p>对 <a href="https://en.wikipedia.org/wiki/Remote_procedure_call">RPC</a> 相关的学习也有了一段时间，算是有了一个初步的认识，回过头来读 <a href="https://time.geekbang.org/column/intro/100046201">极客时间的专栏</a> 感觉思路清晰了不少，顺利了许多，再回头看 <a href="https://rpcx.io/">rpcx</a> 的源码也没有那么费劲了。我把我在这个专栏中学到的一些内容记录下来，共同学习。</p>
<p>本文不再解释 RPC 相关基础概念，有需要可在上文链接或者往期文章中学习。</p>
<p>以下的二级标题均对应专栏的课程大纲，同样分单元总结。</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/image-20210515133206463.png" alt="image-20210515133206463"></p>
<h2 id="开篇词">开篇词</h2>
<p>开篇词介绍了 RPC 的使用场景，重要意义，作为引文。</p>
<p>RPC 即远程过程调用，目的是使调用另一台机器上的程序就像调用本地程序一样简单。总是和 “微服务”，SOA 联系，其实理论上来说，任何牵扯到网络通信的系统都可能需要使用 RPC。比如分布式各个组件间或与应用间的通信，比如 etcd 作为统一的配置服务，客户端就是通过 gRPC 框架与服务端进行通信的。</p>
<p><strong>RPC 是解决分布式系统通信问题的一大利器。</strong> RPC 的通信原理十分简单，可是想完美驾驭却不那么容易，这个过程除了调用过程之外，还主要包括：通信节点查找，连接的建立与状态管理，数据传输的编解码，序列化与反序列化等等，每一项都十分复杂。</p>
<p>而完整的 RPC 框架却对上述过程进行了封装，使得网络通信逻辑的开发变得十分简单，效率也会更高。</p>
<p>最初的我学习 RPC 也是由浅入深，从 “字面意思” 出发，即如何调用远程主机上的某个函数，实现了编解码，序列化等等一整套调用流程，成功执行了远程主机的程序，当然了，这还是点对点的。</p>
<p>后来我发现这些仅仅是基础，冰山下的还包括一系列服务治理功能：连接管理，健康检测，负载均衡，优雅启停机，异常重试，业务分组以及熔断限流等等。十分复杂又充满了挑战性。</p>
]]></content></item><item><title>MIT 6.828 课程学习记录</title><link>https://kcode.icu/posts/os/mitos/</link><pubDate>Sun, 25 Apr 2021 23:35:20 +0000</pubDate><guid>https://kcode.icu/posts/os/mitos/</guid><description>介绍 好多人推荐这个国外的课程，就找了一下课程，下载了一份讲义，打开第一眼就看到大名鼎鼎的 rsc 大佬，偶像啊，Go 的当下掌舵人。就冲这名必须得看完了（狗头😄）。 开个玩笑，我个人对计算机基础最感兴趣的就是组成原理、操作系统和汇编语言，除此之外就是分布式了，等搞定这个之后也去跟一下 MIT 6.824 分布式部分（开新坑🕳️ ）
待更&amp;hellip;.</description><content type="html"><![CDATA[<h2 id="介绍">介绍</h2>
<p>好多人推荐这个国外的课程，就找了一下课程，下载了一份讲义，打开第一眼就看到大名鼎鼎的 <a href="https://github.com/rsc">rsc</a> 大佬，偶像啊，Go 的当下掌舵人。就冲这名必须得看完了（狗头😄）。 开个玩笑，我个人对计算机基础最感兴趣的就是组成原理、操作系统和汇编语言，除此之外就是分布式了，等搞定这个之后也去跟一下 MIT 6.824 分布式部分（开新坑🕳️ ）</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/image-20210425171314612.png" alt="image-20210425171314612"></p>
<p>待更&hellip;.</p>
]]></content></item><item><title>Go 使用的 plan9 汇编语言初探</title><link>https://kcode.icu/posts/go/2021-03-20-go-%E4%BD%BF%E7%94%A8%E7%9A%84-plan9-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%88%9D%E6%8E%A2/</link><pubDate>Sun, 04 Apr 2021 20:30:20 +0000</pubDate><guid>https://kcode.icu/posts/go/2021-03-20-go-%E4%BD%BF%E7%94%A8%E7%9A%84-plan9-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%88%9D%E6%8E%A2/</guid><description>plan9 汇编既不同于 Intel-x86 家族的汇编，也不与 AT&amp;amp;T 标准相同，作者是 unix 操作系统的同一批人，bell 实验室所开发的，其实 plan9 是一个操作系统，我们主要关注构建它的汇编语言。
Go 语言早在 1.5 版本就实现了自举，即 使用 Go 语言去写 Go 语言。Go 的底层实现是使用 plan9 汇编完成的，并不是我们常见的 Intel 家族汇编，它与其他的汇编有几个不同点，在下文中一边比较一边介绍。
伪寄存器 plan9 抽象了 4 种伪寄存器：
FP（Frame Pointer），帧指针，快速访问函数的参数和返回值。 SP（Stack Pointer），栈指针，指向栈顶。 SB（Static base pointer），静态基址，全局变量。 PC（Program Counter），其实就是 IP（Instruction Pointer）的别名，指向下一条指令的地址。jmp等跳转指令还有分支控制等原理就是通过修改这个值。在 8086 机里等价于 CS:IP。 其实就是对 CPU 的重新抽象，这个抽象结构与具体的 CPU 结构无关。
它们之间的具体关系如下图：
与x86汇编的差异 许多人之前广泛了解的汇编可能是 AT&amp;amp;T 格式或者传统 Intel-x86 格式，AT&amp;amp;T 规范与 x86 有许多不同，而 plan9 与 AT&amp;amp;T 有许多相似的地方，比如操作数顺序许多是相同的，但 不完全等价。还是需要我们重新学习，这里列举一些常见区别。
Mnemonic | Go operands | AT&amp;amp;T operands ================================================ BOUNDW | m16&amp;amp;16, r16 | r16, m16&amp;amp;16 BOUNDL | m32&amp;amp;32, r32 | r32, m32&amp;amp;32 CMPB | AL, imm8 | imm8, AL CMPW | AX, imm16 | imm16, AX CMPL | EAX, imm32 | imm32, EAX CMPQ | RAX, imm32 | imm32, RAX CMPW | r/m16, imm16 | imm16, r/m16 CMPW | r/m16, imm8 | imm8, r/m16 CMPW | r/m16, r16 | r16, r/m16 CMPL | r/m32, imm32 | imm32, r/m32 CMPL | r/m32, imm8 | imm8, r/m32 CMPL | r/m32, r32 | r32, r/m32 CMPQ | r/m64, imm32 | imm32, r/m64 CMPQ | r/m64, imm8 | imm8, r/m64 CMPQ | r/m64, r64 | r64, r/m64 CMPB | r/m8, imm8 | imm8, r/m8 CMPB | r/m8, imm8 | imm8, r/m8 CMPB | r/m8, r8 | r8, r/m8 CMPB | r/m8, r8 | r8, r/m8 CMPW | r16, r/m16 | r/m16, r16 CMPL | r32, r/m32 | r/m32, r32 CMPQ | r64, r/m64 | r/m64, r64 CMPB | r8, r/m8 | r/m8, r8 CMPB | r8, r/m8 | r/m8, r8 CMPPD | imm8, xmm1, xmm2/m128 | imm8, xmm2/m128, xmm1 CMPPS | imm8, xmm1, xmm2/m128 | imm8, xmm2/m128, xmm1 CMPSD | imm8, xmm1, xmm2/m64 | imm8, xmm2/m64, xmm1 CMPSS | imm8, xmm1, xmm2/m32 | imm8, xmm2/m32, xmm1 ENTER | 0, imm16 | imm16, 0 ENTER | 1, imm16 | imm16, 1 操作数顺序不同 在 x86 中，一些常见指令是这样的：</description><content type="html"><![CDATA[<p>plan9 汇编既不同于 Intel-x86 家族的汇编，也不与 AT&amp;T 标准相同，作者是 unix 操作系统的同一批人，bell 实验室所开发的，其实 plan9 是一个操作系统，我们主要关注构建它的汇编语言。</p>
<p>Go 语言早在 1.5 版本就实现了自举，即 使用 Go 语言去写 Go 语言。Go 的底层实现是使用 plan9 汇编完成的，并不是我们常见的 Intel 家族汇编，它与其他的汇编有几个不同点，在下文中一边比较一边介绍。</p>
<h2 id="伪寄存器">伪寄存器</h2>
<p>plan9 抽象了 4 种伪寄存器：</p>
<ul>
<li>FP（Frame Pointer），帧指针，快速访问函数的参数和返回值。</li>
<li>SP（Stack Pointer），栈指针，指向栈顶。</li>
<li>SB（Static base pointer），静态基址，全局变量。</li>
<li>PC（Program Counter），其实就是 IP（Instruction Pointer）的别名，指向下一条指令的地址。jmp等跳转指令还有分支控制等原理就是通过修改这个值。在 8086 机里等价于 CS:IP。</li>
</ul>
<p>其实就是对 CPU 的重新抽象，<strong>这个抽象结构与具体的 CPU 结构无关</strong>。</p>
<p>它们之间的具体关系如下图：</p>
<h2 id="与x86汇编的差异">与x86汇编的差异</h2>
<p>许多人之前广泛了解的汇编可能是 AT&amp;T 格式或者传统 Intel-x86 格式，AT&amp;T 规范与 x86 有许多不同，而 plan9 与 AT&amp;T 有许多相似的地方，比如操作数顺序许多是相同的，但 <strong>不完全等价</strong>。还是需要我们重新学习，这里列举一些常见区别。</p>
<pre><code class="language-assembly" data-lang="assembly">Mnemonic | Go operands           | AT&amp;T operands
================================================
BOUNDW   | m16&amp;16, r16           | r16, m16&amp;16
BOUNDL   | m32&amp;32, r32           | r32, m32&amp;32
CMPB     | AL, imm8              | imm8, AL
CMPW     | AX, imm16             | imm16, AX
CMPL     | EAX, imm32            | imm32, EAX
CMPQ     | RAX, imm32            | imm32, RAX
CMPW     | r/m16, imm16          | imm16, r/m16
CMPW     | r/m16, imm8           | imm8, r/m16
CMPW     | r/m16, r16            | r16, r/m16
CMPL     | r/m32, imm32          | imm32, r/m32
CMPL     | r/m32, imm8           | imm8, r/m32
CMPL     | r/m32, r32            | r32, r/m32
CMPQ     | r/m64, imm32          | imm32, r/m64
CMPQ     | r/m64, imm8           | imm8, r/m64
CMPQ     | r/m64, r64            | r64, r/m64
CMPB     | r/m8, imm8            | imm8, r/m8
CMPB     | r/m8, imm8            | imm8, r/m8
CMPB     | r/m8, r8              | r8, r/m8
CMPB     | r/m8, r8              | r8, r/m8
CMPW     | r16, r/m16            | r/m16, r16
CMPL     | r32, r/m32            | r/m32, r32
CMPQ     | r64, r/m64            | r/m64, r64
CMPB     | r8, r/m8              | r/m8, r8
CMPB     | r8, r/m8              | r/m8, r8
CMPPD    | imm8, xmm1, xmm2/m128 | imm8, xmm2/m128, xmm1
CMPPS    | imm8, xmm1, xmm2/m128 | imm8, xmm2/m128, xmm1
CMPSD    | imm8, xmm1, xmm2/m64  | imm8, xmm2/m64, xmm1
CMPSS    | imm8, xmm1, xmm2/m32  | imm8, xmm2/m32, xmm1
ENTER    | 0, imm16              | imm16, 0
ENTER    | 1, imm16              | imm16, 1
</code></pre><h3 id="操作数顺序不同">操作数顺序不同</h3>
<p>在 x86 中，一些常见指令是这样的：</p>
<pre><code class="language-assembly" data-lang="assembly">MOV EAX, 10  ;EAX=10
MOV AH, [BL] ;AH=*BL
</code></pre><p>而在 plan9 中操作数的顺序会相反：</p>
<pre><code class="language-assembly" data-lang="assembly">MOVL a+0(FP), AX  ;AX=a 
MOVB BX, AX    ;AX=BX
</code></pre><p>不止这些，还有 LEA ADD SUB IMUL等等也都满足。</p>
<h3 id="操作数大小表示法不同">操作数大小表示法不同</h3>
<p>在 x86 中，表示大小通过直接区分操作数，比如 AX 寄存器的高 8 位就是 <code>AH</code> ，低 8 位就叫 <code>AL</code>.。而 plan9 中通过不同操作码来区分：</p>
<pre><code class="language-assembly" data-lang="assembly">MOVB $0x10, AX  ;1B, Byte
MOVW $-10, DI  ;2B, 1Word=2Byte
MOVL $0, SP   ;4B, Double Word
MOVQ $1, DX   ;8B, Quatury Word
</code></pre><h3 id="寄存器">寄存器</h3>
<p>寄存器分为 <strong>实寄存器（real register）和 伪寄存器（pseudo register）</strong> ，前者在 CPU 内部，属于 CPU 的固件，作为与 CPU 直接产生信息交换的单位，具体种类与架构有关，可以通过 dlv 工具查看：</p>
<blockquote>
<p>示例程序的机器为 AMD64，也就是 x86-64。不同的机器可能会因为 CPU 的不同而不同。</p>
</blockquote>
<pre><code>(dlv) regs                                       
   Rip = 0x00007ff90ed00771                      
   Rsp = 0x000000cfd45ff260                      
   Rax = 0x0000000000000000                      
   Rbx = 0x0000000000000010                      
   Rcx = 0x00007ff90eccd2c4                      
   Rdx = 0x0000000000000000                      
   Rsi = 0x00007ff90ed61a80                      
   Rdi = 0x000000cfd4237000                      
   Rbp = 0x0000000000000000                      
    R8 = 0x000000cfd45ff258                      
    R9 = 0x0000000000000000                      
   R10 = 0x0000000000000000                      
   R11 = 0x0000000000000246                      
   R12 = 0x0000000000000040                      
   R13 = 0x0000000000000000                      
   R14 = 0x00007ff90ed548f0                      
   R15 = 0x00000254e7900000                      
Rflags = 0x0000000000000246     [PF ZF IF IOPL=0]
    Cs = 0x0000000000000033                      
    Fs = 0x0000000000000053                      
    Gs = 0x000000000000002b                      
</code></pre><p>后者是应用层抽象出来的概念，实际并不存在，目的是为了更方便地写汇编。</p>
<p>由于历史原因，x86 平台要保证向后兼容，要求在 64 位机上要能够运行 32、16、8位程序。解决方法是通过给寄存器加前缀实现的。</p>
<pre><code class="language-assembly" data-lang="assembly">AH/AL -&gt; AX -&gt; EAX -&gt; RAX
  8      16     32     64
</code></pre><p>除此之外，还有这些对应关系</p>
<table>
<thead>
<tr>
<th>X64</th>
<th>rax</th>
<th>rbx</th>
<th>rcx</th>
<th>rdx</th>
<th>rdi</th>
<th>rsi</th>
<th>rbp</th>
<th>rsp</th>
<th>r8</th>
<th>r9</th>
<th>r10</th>
<th>r11</th>
<th>r12</th>
<th>r13</th>
<th>r14</th>
<th>rip</th>
</tr>
</thead>
<tbody>
<tr>
<td>Plan9</td>
<td>AX</td>
<td>BX</td>
<td>CX</td>
<td>DX</td>
<td>DI</td>
<td>SI</td>
<td>BP</td>
<td>SP</td>
<td>R8</td>
<td>R9</td>
<td>R10</td>
<td>R11</td>
<td>R12</td>
<td>R13</td>
<td>R14</td>
<td>PC</td>
</tr>
</tbody>
</table>
<h4 id="伪寄存器-1">伪寄存器</h4>
<p>为了方便编程，plan9 还引入了 4 个伪寄存器，<code>SP</code> <code>FP</code> <code>SB</code> <code>PC</code>。想当年面试的时候（其实就是去年，我张口就来引入这四个是为了增加性能（猜的，回头想想还真是离谱。</p>
<p>这 4 个有不同的作用，其中 伪SP寄存器 还与 真SP寄存器 重名了，就更容易让初学者懵逼了，这里放个曹大的图就明白了。</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/ch3-3-arch-amd64-02.ditaa.png" alt="图源《Go语言高级编程》"></p>
<p>这个图里有一点歧义，红色部分是栈，黄色是堆，图中的关系是堆在上面，而实际堆是向上增长的。</p>
<p>另外还有一点，这张图里没有标明 实寄存器BP 的位置，BP 是栈基地址。</p>
<h2 id="函数调用">函数调用</h2>
<p>这里拿一个简单的函数嵌套调用代码，来举例说明它们之间的具体位置关系和实现原理：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">upper</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">r0</span><span class="p">,</span> <span class="nx">r1</span> <span class="o">:=</span> <span class="nf">f0</span><span class="p">(</span><span class="nx">arg0</span><span class="p">,</span> <span class="nx">arg1</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">f0</span><span class="p">(</span><span class="nx">arg0</span><span class="p">,</span> <span class="nx">arg1</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">ret0</span><span class="p">,</span> <span class="nx">ret1</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">r0</span> <span class="o">:=</span> <span class="nx">arg0</span> <span class="o">-</span> <span class="nx">arg1</span>
    <span class="nx">r1</span> <span class="o">:=</span> <span class="nx">arg0</span> <span class="o">+</span> <span class="nx">arg1</span>
    <span class="nx">r1</span> <span class="p">=</span> <span class="nf">f1</span><span class="p">(</span><span class="nx">r0</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">r0</span><span class="p">,</span> <span class="nx">r1</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">f1</span><span class="p">(</span><span class="nx">arg0</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">ret0</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nx">arg0</span>
<span class="p">}</span>
</code></pre></div><h3 id="栈帧">栈帧</h3>
<p>函数实现嵌套调用依靠的数据结构就是栈，上面这个程序它的调用栈帧如下：</p>
<pre><code class="language-assembly" data-lang="assembly">       
                    +------------+ &lt;----------+
                    |    ....    |            |
                    +------------+            |
                    |    Ret1    |            |
                    +------------+            |
                    |    Ret0    |
                    +------------+      upper call stack
                    |    Arg1    |
                    +------------+            |
                    |    Arg0    |            |
                    +------------+            |
                    |  Ret Addr  |            |
                    +------------+ &lt;----------+
real BP(pseudo SP)  |  upper BP  |            |
------------------&gt; +------------+            |
                    |   Local0   |            |
                    +------------+            |
       real SP      |   Local1   |
  ----------------&gt; +------------+
                    |            |      f0 stack frame
                    |unused space|
                    |            |
                    +------------+            |
                    |    Ret0    |            |
                    +------------+            |
       pseudo FP    |    Arg1    |            |
  ----------------&gt; +------------+            |
                    |  Ret Addr  |            |
                    +------------+ &lt;----------+
                    |Caller f0'BP|
                    +------------+
                    |   Local0   |
                    +------------+
                    |   Local1   |
                    +------------+
                    |    ...     |
                    +------------+
                    
</code></pre><h3 id="验证">验证</h3>
<p>我们使用 FP/real SP/pseudo SP 来验证一下上面的栈帧示意图：</p>
<h2 id="分析一个简单的程序">分析一个简单的程序</h2>
<p>好了，终于见到 「真的汇编代码」 了，理论知识差不多了（误</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">sum</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">sub</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">z</span> <span class="o">:=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span>
  <span class="nx">w</span> <span class="o">:=</span> <span class="nx">x</span> <span class="o">-</span> <span class="nx">y</span>
  <span class="k">return</span> <span class="nx">z</span><span class="p">,</span> <span class="nx">w</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">c</span><span class="p">,</span> <span class="nx">d</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="前置知识">前置知识</h3>
<p>在命令行中执行 <code>go tool compile -S -N -l main.go</code> 查看汇编代码。看之前需要注意两点，</p>
<ul>
<li>不管使用 <code>go tool compile -S</code> 还是 <code>go tool objdump</code> 来查看汇编代码，都是和实际我们手写 plan9 不同的，不能照搬语法。这两者关于汇编指令的输出也是不同的。当然，十六进制肯定是相同的。</li>
<li>输出的所有 SP 指针无论带不带 symbol 都是实寄存器，而实际上在手写 plan9 时，如果使用了形如 <code>symbol+offset(SP)</code> 的表达则指使用的是 伪SP指针，不带则是 真SP指针。</li>
<li>而实际手写在使用 <code>FP</code> 寄存器时如果不带 <code>symbol</code> 会直接报错。</li>
</ul>
<h3 id="变量与常量">变量与常量</h3>
<h3 id="函数">函数</h3>
<pre><code class="language-assembly" data-lang="assembly">&quot;&quot;.add STEXT nosplit size=19 args=0x18 locals=0x0 funcid=0x0
        0x0000 00000 (notify.go:7)      TEXT    &quot;&quot;.add(SB), NOSPLIT|ABIInternal, $0-24
        0x0000 00000 (notify.go:7)      FUNCDATA        $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
        0x0000 00000 (notify.go:7)      FUNCDATA        $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
        0x0000 00000 (notify.go:8)      MOVQ    &quot;&quot;.b+16(SP), AX
        0x0005 00005 (notify.go:8)      MOVQ    &quot;&quot;.a+8(SP), CX
        0x000a 00010 (notify.go:8)      ADDQ    CX, AX
        0x000d 00013 (notify.go:8)      MOVQ    AX, &quot;&quot;.~r2+24(SP)
        0x0012 00018 (notify.go:8)      RET
</code></pre><p>先看第一行内容：</p>
<pre><code class="language-assembly" data-lang="assembly">&quot;&quot;.add STEXT nosplit size=19 args=0x18 locals=0x0 funcid=0x0
</code></pre><p>内容虽然多，但是非常好理解，不同数值均给出了名称，但是更标准的表示法一般是这样：</p>
<pre><code class="language-assembly" data-lang="assembly">TEXT runtime∕internal∕atomic·Cas(SB),NOSPLIT,$0-17
</code></pre><p>双引号里和 <code>runtime/internal/atomic</code> 都是函数名，可以省略，后面紧跟函数名。<code>TEXT</code> 是区段名。<code>SB</code> 是基于伪寄存器 <code>SB</code> 进行偏移，比如：</p>
<pre><code class="language-assembly" data-lang="assembly">+4(SB)
a+8(SB)
</code></pre><p>一个是在 SB 寄存器起始地址上正向偏移 4 个字节，一个是从 SB 的 a 变量开始偏移 4 个字节。</p>
<p>由于 Go 语言函数的调用栈帧默认是动态伸缩的，初始大小只有 2KB，你可以使用 <code>指令</code> 来控制这个行为：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">str2slc</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p>这条指令可以禁止扩容检测，这样做一定程度上可以增加效率。而汇编代码里的 <code>nosplit</code> 是编译器帮我们做的优化。除此之外，还有 <code>WRAPPER</code>、<code>noinline</code> 等许多指令，都是用来指导编译器的工作，例如禁用内联，禁止逃逸，禁止逃逸分析等等，具体及更多信息可以在官方文档 <a href="https://golang.org/cmd/compile/">golang.org/cmd/compile</a> 查看。</p>
<p><code>$0-17</code> 的 0 是函数栈帧大小，指函数内的局部变量总大小，这个值包括准备子函数参数的开销。17 是参数大小，'-' 不是减号，只是连接符，不要想当然认为栈向下增长所以是做减法（不过好像问题也不大</p>
<p><del>需要注意的是，如果没有 <code>nosplit</code>，则必须给出参数大小，而不能直接 <code>$x</code>，因为 Go 语言编译器已无法根据函数签名进行占用空间大小的推导。</del></p>
<p>所以，最终定义函数的标准语法如下：</p>
<pre><code class="language-assembly" data-lang="assembly">TEXT symbol(SB), [flags,] $framesize[-argsize]
</code></pre><h2 id="手写来练习一下吧">手写来练习一下吧</h2>
<p>看了这么多，来手写一个简单的 plan9 汇编程序练习一下。</p>
<blockquote>
<p>目标：实现一个求整型切片元素和的函数，函数签名为：func addSliceInt(slc []int) int。举个例子，如果 slc := []{1,2,3,4}，那么返回 10.</p>
</blockquote>
<h2 id="总结">总结</h2>
<p>plan9 是一个操作系统，对应一套汇编语法，被称为 plan9 汇编，与 AT&amp;T 规范非常相似，也不完全一样。与传统 x86 汇编差异较大。</p>
<p>plan9 重新定义了 4 个伪寄存器来方便编程，函数嵌套调用的核心就是依靠栈的先进先出特性，在调用前来保护 Caller 的执行现场，并在 Callee 执行完返回后恢复现场，从而继续执行。</p>
<ul>
<li>没有 push，pop 等栈操作，栈的增缩是通过对 sp 栈顶寄存器的加减实现的，例如 +8（sp）</li>
<li>操作数的大小不是通过区分操作码来实现的，而是通过操作码的后缀实现，例如复制 <code>ax</code> 寄存器低 1 字节到第二字节，在 <code>x86</code> 汇编中是通过 <code>mov ah,al</code>，而在 plan9 中则是通过 <code>movb al,ah</code>
<ul>
<li>b w d q分别代表1 2 4 8 Byte，含义是byte，word，double word，quatury。</li>
</ul>
</li>
<li>操作数在第一个参数，结果放在第二个参数，与intel汇编相反，具体看第二条</li>
</ul>
<blockquote>
<p>我们学习 plan9 汇编其实也并没有太大困难，前期在学习时也未必要看懂全部的汇编代码，可先学习大概思路，再深入了解即可。</p>
</blockquote>
<p>但是为什么 plan9 不与 x86 系兼容呢，而要单独开发一套自己的语法呢，我看了不少人的解释，貌似是因为 unix 团队是学院派，特立独行，也不屑于商业化（就是玩</p>
]]></content></item><item><title>大三上学期好未来字节腾讯实习面经</title><link>https://kcode.icu/posts/interview/2021-3-nowcoder/</link><pubDate>Tue, 30 Mar 2021 17:20:20 +0000</pubDate><guid>https://kcode.icu/posts/interview/2021-3-nowcoder/</guid><description>说在前面 经常“吸”社区，也要时不时反馈一点，一起延续开源精神。
个人情况：22 届双非一本，从去年 12 月开始面试找寒假的实习，由于学校疫情原因没去成功，于是经过寒假复习“二战”。先后面了跟谁学，腾讯，字节，阿里。
由于我个人情况特殊，从大一开始使用 Go 语言到现在，了解比较多，C++ 用来写题，有的问题可能不具有参考价值，理性看待。
另外有的问题确实记不得了，大家不要太看重问题，因为大部分都是八股的题型，网上一搜一大堆，博客的总结能几万字，但是没有面试官喜欢听这种东西，都是搞技术的不喜欢花里胡哨，我曾经就因为答协程区别和特点被反问 你这个有点像背的，，不过我也没反驳，下次总结避免就好了。你要答出问题的本质，底层的思考，说出跟别人不一样的地方，用有些面试官的话来说就是 这个问题我只想听你说一句话，我看我能不能听到。说白了就是你说了一大堆可能在对面听来都没听到，说不到点子上等于没说。
另外本文我主要突出面试过程，不是面试问题的总结帖（有的问题我真的记不得了 :(。
好了，不说废话了，大家看正文吧，有什么问题欢迎找我聊~
跟谁学两面 oc，第一次面试 一面 自我介绍
项目：
用go写的rpc框架的具体功能细节，注册中心单机还是分布式的，其中一个挂了怎么办？一致性，可靠性怎么保证的。超时控制，加锁和管道支持并发，单机（考虑了多机情况，说了已经在todo里了）。
Go+QML 利用cgo实现的跨平台桌面应用功能，场景，为什么要写这个东西？ 我说为了性能，追问性能如何体现，如何测试的，如何优化。答宏观上从任务管理器，top中看，细节上从pprof进行性能定位调优，从火焰图上看。追问pprof还有什么功能，你一般是怎么定位问题的？回答还是先具体再细节。
这时候我就俩项目，后面怕不够，又想拿go写个web的，正好学校说需要重构某个子选课系统，就跟同学接了，这个下面说。
写个快排？时分复杂度分析？看你了解过go的标准库实现，说说go的快排源码怎么实现的，答三数取中，根据数据量选择多种排序方式组合，追问细节我就不知道i了，，确实没看过这个。。他说没事。
协程与线程区别？为什么快，快在哪了？自定义了4个伪寄存器 fp sp sb pc，轻量，初始2KB动态伸缩，由runtime管理，对os透明等等各种原因，又说了以下gmp调度的优势。追问寄存器是什么，你对寄存器还有什么了解。我说了一点关于go和c 在寄存器方面使用的不同，函数传参，调用堆栈等等，扯了点汇编区别，就又问了几个汇编指令，过了。
虚拟地址，物理地址区别
rpc与http区别，使用场景，自己总结一下再说几条
还有点八股没啥难的 有点忘了。。
也没问啥难点一面就过了
二面部门leader 详细聊虚拟地址与物理地址，为什么分这俩，段页作用，为什么内存占用能比实际要大的多（还是虚拟地址作用），循序渐进的从现象到技术实现来问，不是考试。
go+qml项目问了几个关于cgo的特性，聊了聊优劣势，看得出来这个项目好多面试官也不懂，cgo特性一是用起来结合其他语言的时候确实有坑点，二是拿go写gui有点杀马特，不招人待见？
闲聊网络跟os，最后问了个智力问题，就过了。
总结 感觉难度不大，缺人进来打杂，要求不高。问了一下前辈，说加班严重，校招的话工资高了可以放备选考虑去。。面试体验还不错，自己缺乏一点回答技巧上的经验，聊技术不能一下到点子上，废话略多。
字节二面挂，腾讯二面挂 这俩对我帮助最大。
字节 字节对我最大的帮助是深度思考算法，为什么要这么写，别的方法行不行？
自己感觉有了点面试方面的经验，就投了较大的厂，遭到毒打。
字节一面是算法面，最后写了个单链表归并非递归，勉强通过。
二面上来扣20分钟rpc项目，挖出你这个项目的所有特点为止：
序列化方式有哪几个，区别是什么，自己写过吗 协议用的哪个，为啥不用udp &amp;hellip;鞭打。。。 当时确实缺少对项目的深度思考，也是参考了声哥的项目，不过他是java写的，用go写起来参考了不少框架源码，rpcx，grpc，实现起来略费劲，时间仓促，底层思考略少。
二面挂是因为问了个快排复杂度，详细分析这三个时间复杂度的结果，怎么来的这个值，举例子说明等等，自己算法这方面当时确实弱项，挂了正常。
腾讯 腾讯对我最大的帮助是看源码，有的东西嚼别人的东西是不够的，应该学习一手资料，详情参考曹大的博客《工程师应该怎么学习》。还是太菜了，缺乏深度思考
几个亿找中位数
搜索树旋转过程
对面应该是c++的，问我map，我说我用go，他就说go也行，你说说go map 时间复杂度，为啥是这个值，为什么这么多数，O1能直接访问到，当时map只了解了一点，遂答的浅。</description><content type="html"><![CDATA[<h2 id="说在前面">说在前面</h2>
<p>经常“吸”社区，也要时不时反馈一点，一起延续开源精神。</p>
<p>个人情况：22 届双非一本，从去年 12 月开始面试找寒假的实习，由于学校疫情原因没去成功，于是经过寒假复习“二战”。先后面了跟谁学，腾讯，字节，阿里。</p>
<p>由于我个人情况特殊，从大一开始使用 Go 语言到现在，了解比较多，C++ 用来写题，有的问题可能不具有参考价值，理性看待。</p>
<p>另外有的问题确实记不得了，大家不要太看重问题，因为大部分都是八股的题型，网上一搜一大堆，博客的总结能几万字，但是没有面试官喜欢听这种东西，都是搞技术的不喜欢花里胡哨，我曾经就因为答协程区别和特点被反问 你这个有点像背的，，不过我也没反驳，下次总结避免就好了。你要答出问题的本质，底层的思考，说出跟别人不一样的地方，用有些面试官的话来说就是 这个问题我只想听你说一句话，我看我能不能听到。说白了就是你说了一大堆可能在对面听来都没听到，说不到点子上等于没说。</p>
<p>另外本文我主要突出面试过程，不是面试问题的总结帖（有的问题我真的记不得了 :(。</p>
<p>好了，不说废话了，大家看正文吧，有什么问题欢迎找我聊~</p>
<h3 id="跟谁学两面-oc第一次面试">跟谁学两面 oc，第一次面试</h3>
<h4 id="一面">一面</h4>
<p>自我介绍</p>
<p>项目：</p>
<ul>
<li>
<p>用go写的rpc框架的具体功能细节，注册中心单机还是分布式的，其中一个挂了怎么办？一致性，可靠性怎么保证的。超时控制，加锁和管道支持并发，单机（考虑了多机情况，说了已经在todo里了）。</p>
</li>
<li>
<p>Go+QML 利用cgo实现的跨平台桌面应用功能，场景，<strong>为什么要写这个东西？</strong> 我说为了性能，追问性能如何体现，如何测试的，如何优化。答宏观上从任务管理器，top中看，细节上从pprof进行性能定位调优，从火焰图上看。追问pprof还有什么功能，你一般是怎么定位问题的？回答还是先具体再细节。</p>
</li>
</ul>
<p>这时候我就俩项目，后面怕不够，又想拿go写个web的，正好学校说需要重构某个子选课系统，就跟同学接了，这个下面说。</p>
<p>写个快排？时分复杂度分析？看你了解过go的标准库实现，说说go的快排源码怎么实现的，答三数取中，根据数据量选择多种排序方式组合，追问细节我就不知道i了，，确实没看过这个。。他说没事。</p>
<p>协程与线程区别？为什么快，快在哪了？自定义了4个伪寄存器 fp sp sb pc，轻量，初始2KB动态伸缩，由runtime管理，对os透明等等各种原因，又说了以下gmp调度的优势。追问寄存器是什么，你对寄存器还有什么了解。我说了一点关于go和c 在寄存器方面使用的不同，函数传参，调用堆栈等等，扯了点汇编区别，就又问了几个汇编指令，过了。</p>
<p>虚拟地址，物理地址区别</p>
<p>rpc与http区别，使用场景，自己总结一下再说几条</p>
<p>还有点八股没啥难的 有点忘了。。</p>
<p>也没问啥难点一面就过了</p>
<h4 id="二面部门leader">二面部门leader</h4>
<p>详细聊虚拟地址与物理地址，为什么分这俩，段页作用，为什么内存占用能比实际要大的多（还是虚拟地址作用），循序渐进的从现象到技术实现来问，不是考试。</p>
<p>go+qml项目问了几个关于cgo的特性，聊了聊优劣势，看得出来这个项目好多面试官也不懂，cgo特性一是用起来结合其他语言的时候确实有坑点，二是拿go写gui有点杀马特，不招人待见？</p>
<p>闲聊网络跟os，最后问了个智力问题，就过了。</p>
<h4 id="总结">总结</h4>
<p>感觉难度不大，缺人进来打杂，要求不高。问了一下前辈，说加班严重，校招的话工资高了可以放备选考虑去。。面试体验还不错，自己缺乏一点回答技巧上的经验，聊技术不能一下到点子上，废话略多。</p>
<h3 id="字节二面挂腾讯二面挂">字节二面挂，腾讯二面挂</h3>
<p>这俩对我帮助最大。</p>
<h4 id="字节">字节</h4>
<p>字节对我最大的帮助是深度思考算法，为什么要这么写，别的方法行不行？</p>
<p>自己感觉有了点面试方面的经验，就投了较大的厂，遭到毒打。</p>
<p>字节一面是算法面，最后写了个单链表归并非递归，勉强通过。</p>
<p>二面上来扣20分钟rpc项目，挖出你这个项目的所有特点为止：</p>
<ul>
<li>序列化方式有哪几个，区别是什么，自己写过吗</li>
<li>协议用的哪个，为啥不用udp</li>
<li>&hellip;鞭打。。。</li>
</ul>
<p>当时确实缺少对项目的深度思考，也是参考了声哥的项目，不过他是java写的，用go写起来参考了不少框架源码，rpcx，grpc，实现起来略费劲，时间仓促，底层思考略少。</p>
<p>二面挂是因为问了个快排复杂度，详细分析这三个时间复杂度的结果，怎么来的这个值，举例子说明等等，自己算法这方面当时确实弱项，挂了正常。</p>
<h4 id="腾讯">腾讯</h4>
<p>腾讯对我最大的帮助是看源码，有的东西嚼别人的东西是不够的，应该学习一手资料，详情参考曹大的博客《工程师应该怎么学习》。还是太菜了，缺乏深度思考</p>
<p>几个亿找中位数</p>
<p>搜索树旋转过程</p>
<p>对面应该是c++的，问我map，我说我用go，他就说go也行，你说说go map 时间复杂度，为啥是这个值，为什么这么多数，O1能直接访问到，当时map只了解了一点，遂答的浅。</p>
<p>问 gc，gmp模型</p>
<p>后面忘了。</p>
<p>从这里开始，我去把go map的源码包括 runtime/map.go还有相关的汇编代码过了3.4遍，逐行注释源码，写成了博客，这才有了后续跟阿里面试官（技术专家）扯map 20分钟，详细问到扩容的代码实现。。</p>
<p>也看了channel的源码，挺多的，假期期间算是把底层源码这块入了个门，能扯几句了。</p>
<h3 id="阿里三面挂">阿里三面挂</h3>
<p>笔试算法还是写的不好。</p>
<p>这个是寒假回来的了，阿里云的，一面跟技术专家聊了45min，面试官应该是c++的，懂go，全程比较愉快，最后15分钟写了个题，改编版无重复字符最长字串，10分钟a了就过了。这里记录几个有意思的问题：</p>
<ul>
<li>有什么方法可以让函数无限递归不爆栈？（尾递归，返回还是函数本身，栈帧覆盖）</li>
<li>什么方法可以限制从堆分配内存的内存范围？（不会）</li>
<li>逃逸分析，有哪些情况会逃逸，为什么？（go的逃逸分析）</li>
<li>内部布局，系统空间和用户空间，系统空间有中断向量表等不可访问资源，用户空间就是代码段，数据段，堆栈等等。</li>
</ul>
<p>二面是笔试面，1小时俩题，20分钟a了，接雨水改编版，左视图。问思路，把接雨水改了改，写完了过了</p>
<p>三面应该是主管，到这里的时候项目补了个选课系统，全程问项目整体设计，不具体扣到最深的细节，又问了职业规划，除了go 还意向什么语言，答py c++ rust也可，，貌似对c++意愿不够，其实我c++还可以的，go封装太多了，其实挺想学c++的，之后对方声音变低了，还问了俩问题就结束了，最后问一面的技术专家说原因是笔试不好所以挂了。。</p>
<p>原因我是没想明白，，二面不是补笔试都a了，问题也都答了。。玄学，也不纠结。</p>
<h3 id="阿里区块链测开">阿里区块链测开</h3>
<p>被捞了。一面摸底面，先问你学过哪几个方向，答网络os组原都学过，于是每个都问了一遍，问题有点多，记不住了，挑几个印象深的吧，不分先后：</p>
<ul>
<li>docker用过吗，隔离实现底层？dockerfile，dockercompose，指令说几个，看我说了expose，问端口映射方式，追问冒号左右哪个是主机哪个是容器。。。我还真忘了，上一个dockercompose和dockerfile是几个月前了。。</li>
<li>vlan了解吗，学校做过，但没深入了解。对方看我不太懂就没追问。。</li>
<li>https详细握手过程，说了tls 12 13，psk，sessionid，sessionticket，ecdhe，rsa反正一大堆，你懂的。</li>
<li>从源码到二进制代码的整个流程，编译链接载入内存等等。我说了这里看到的地址都是虚拟地址，平常看到的0xc00000xxxx里的c是虚拟地址与物理地址的转换表的下标，瞎扯了程序领空和用户领空的区别。</li>
</ul>
<p>昨晚突击二面，我说不想测开，他说给我转到平台研发部，还详细说了一下他们部门的工作，说不是BS架构，没后端，只能到平台研发，是C++，我就说也行，面试3分钟就结束了。</p>
<h3 id="腾讯过">腾讯过</h3>
<p>开学面了俩除了阿里云就是这个，比较顺，刚oc。</p>
<p>一面是俩人，问项目，应用层协议，https过程，最后写了个树的题，递归写的比较简单，忘了。。</p>
<p>二面就20分钟，全程问go rpc，穿插一些网络方面的问题，比如tcp udp选择，区别，技术实现等等，没写题。有的问题我感觉答的不好，比如序列化是自己实现的吗，我说用标准库，感觉对方有点失望，我也意识到这个应该自己写一下锻炼锻炼。感觉对方也不是很满意要凉了，最后还是过了，莫名其妙。</p>
]]></content></item><item><title>Go unsafe.Pointer、uintptr、Pointer之间的区别与联系</title><link>https://kcode.icu/posts/go/2021-03-14-go-unsafe.pointeruintptr%E4%B8%8E%E6%8C%87%E9%92%88/</link><pubDate>Sun, 14 Mar 2021 13:35:20 +0000</pubDate><guid>https://kcode.icu/posts/go/2021-03-14-go-unsafe.pointeruintptr%E4%B8%8E%E6%8C%87%E9%92%88/</guid><description>前几天见到了一个问题：
uintptr与 unsafe.Pointer 有什么区别？ 你可能曾经看到过类似这样的代码：
type T struct { a uint8 b bool c string } t := T{a: 1, b: true, c: &amp;#34;goooo&amp;#34;} Tc := *(*string)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;amp;a)) + unsafe.Offsetof(T{}.c))) fmt.Println(Tc) 这一行代码看似实现的功能非常复杂，其实它就是等价于：
fmt.Println(t.c) 从某种意义上来说，这好像没什么用（确实没啥作用&amp;hellip;），那你再看一段代码：
//go:nosplit func Bytes2String(bs []byte) string { return *(*string)(unsafe.Pointer(&amp;amp;bs)) } //go:nosplit func String2Bytes(s string) []byte { ss := *[2]uintptr(unsafe.Pointer(&amp;amp;s)) b := [3]uintptr{ss[0], ss[1], ss[1]} return *(*[]byte)(unsafe.Pointer(&amp;amp;b)) } 这两个函数实现了 []Byte 与 string 的互转，并且不需要申请任何内存，因为他们共享底层数据空间。
函数前的类似注释的一行是一些指令，用来指示编译器进行一些用户的行为，Go 中的栈帧是可以根据需要动态增长的，一开始只有 2048Byte，是固定在源码中的。而 go:nosplit 就是表明函数栈空间无需动态增长，这在一定程度上增加了效率，但是如果你申请了过量的空间，就会导致程序因为爆栈而 panic。</description><content type="html"><![CDATA[<p>前几天见到了一个问题：</p>
<pre><code>uintptr与 unsafe.Pointer 有什么区别？
</code></pre><p>你可能曾经看到过类似这样的代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">a</span> <span class="kt">uint8</span>
    <span class="nx">b</span> <span class="kt">bool</span>
    <span class="nx">c</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="nx">t</span> <span class="o">:=</span> <span class="nx">T</span><span class="p">{</span><span class="nx">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">c</span><span class="p">:</span> <span class="s">&#34;goooo&#34;</span><span class="p">}</span>
<span class="nx">Tc</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">string</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">a</span><span class="p">))</span> <span class="o">+</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Offsetof</span><span class="p">(</span><span class="nx">T</span><span class="p">{}.</span><span class="nx">c</span><span class="p">)))</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">Tc</span><span class="p">)</span>
</code></pre></div><p>这一行代码看似实现的功能非常复杂，其实它就是等价于：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">c</span><span class="p">)</span>
</code></pre></div><p>从某种意义上来说，这好像没什么用（确实没啥作用&hellip;），那你再看一段代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Bytes2String</span><span class="p">(</span><span class="nx">bs</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">string</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">bs</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">String2Bytes</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
    <span class="nx">ss</span> <span class="o">:=</span> <span class="o">*</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">))</span>
    <span class="nx">b</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">uintptr</span><span class="p">{</span><span class="nx">ss</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">ss</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">ss</span><span class="p">[</span><span class="mi">1</span><span class="p">]}</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">[]</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>这两个函数实现了 []Byte 与 string 的互转，并且不需要申请任何内存，因为他们共享底层数据空间。</p>
<p>函数前的类似注释的一行是一些指令，用来指示编译器进行一些用户的行为，Go 中的栈帧是可以根据需要动态增长的，一开始只有 2048Byte，是固定在源码中的。而 <code>go:nosplit</code> 就是表明函数栈空间无需动态增长，这在一定程度上增加了效率，但是如果你申请了过量的空间，就会导致程序因为爆栈而 panic。</p>
<p>这段代码通过 unsafe.Pointer 类型实现了从 float64 强转 uint64 的效果，出自标准库。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Float64bits</span><span class="p">(</span><span class="nx">f</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">uint64</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uint64</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">f</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><h2 id="unsafe包">unsafe包</h2>
<p><code>Go</code> 语言本身由于类型系统的原因，不支持指针的运算操作，对于指针的使用进行了极大的限制，不像 <code>C/C++</code> 语言那样对指针 “为所欲为”，也不像 <code>Java</code> 语言中那样根本不提供指针，采取了一种折中方案，只支持常见的取址（&amp;），取值（*）操作。但是为了有些场合的需要，还是提供了一个用来直接无视类型系统而直接操作的特性，这便是 <code>unsafe</code> 包提供的能力。</p>
<p><code>unsafe</code> 包开放了一个类型，三个函数，分别是：</p>
<ul>
<li>Pointer ，任意指针类型，类似于 C/C++ 语言中的 void* 类型</li>
<li>Alignof(x ArbitraryType) uintptr 函数，计算变量内存对齐边界大小</li>
<li>Sizeof(x ArbitraryType) uintptr 函数，计算该类型所占用内存大小，不包含底层数据大小</li>
<li>Offsetof(x ArbitraryType) uintptr 函数，计算该变量相对于结构体首地址的地址偏移</li>
</ul>
<blockquote>
<p>看源码过程中可能会看到  <code>ArbitraryType</code> 类型，而 <code>Pointer</code> 就是 <code>ArbitraryType</code> 类型，不必疑惑，这个类型没有任何实际意义，仅仅代表了它可以是任意 <code>Go</code> 语言类型，不是 <code>unsafe</code> 包的组成部分。</p>
</blockquote>
<p>Go 语言类型系统的限制，不允许进行指针运算，比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">a</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="nx">pa</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">a</span>
<span class="nx">pa</span><span class="o">++</span>
</code></pre></div><p>编译器无法通过这种写法，会报不支持这种运算的错误：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="err">#</span> <span class="nx">command</span><span class="o">-</span><span class="nx">line</span><span class="o">-</span><span class="nx">arguments</span>
<span class="p">.</span><span class="err">\</span><span class="nx">notify</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">17</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span> <span class="nx">invalid</span> <span class="nx">operation</span><span class="p">:</span> <span class="nx">pa</span><span class="o">++</span> <span class="p">(</span><span class="nx">non</span><span class="o">-</span><span class="nx">numeric</span> <span class="kd">type</span> <span class="o">*</span><span class="kt">int</span><span class="p">)</span>
</code></pre></div><p>这 “一类型，三函数” 所提供的能力就是直接无视这个限制，直接进行地址运算，下面详细介绍这些能力。</p>
<h3 id="一类型pointer">一类型Pointer</h3>
<p><code>Pointer</code> 类型提供了 <code>uintptr</code> 与类型指针之间的转换中介，要想将任意指针类型 *p 转为 uintptr 来进行指针运算，需要先转换为 <code>Pointer</code> 类型，再转换为 <code>uintptr</code> 类型。</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/unsafe_uintptr_p.svg" alt=""></p>
<h4 id="类型介绍">类型介绍</h4>
<p>unsafe.Pointer 类型的定义非常简单，就是一个任意类型的指针表示：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ArbitraryType</span> <span class="kt">int</span>
<span class="kd">type</span> <span class="nx">Pointer</span> <span class="o">*</span><span class="nx">ArbitraryType</span>
</code></pre></div><p>自定义了一个命名类型 <code>ArbitraryType</code>，这个类型并没有什么实际含义，只是表示任意类型，在代码文档中使用。如果没有这个类型，那么 Sizeof 等函数的参数就是 int 类型，会让人费解。所以正如字面意思，<code>Pointer</code> 的含义就是 “任意类型的指针”。</p>
<h4 id="使用注意">使用注意</h4>
<p>除了上图描述的这个类型间转换规则外，还需要遵循几个固定的规则。</p>
<h5 id="uintptr变量无法保持对变量的引用">uintptr变量无法保持对变量的引用</h5>
<p>你不能这么做：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">i</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">1</span>
<span class="nx">up</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">i</span><span class="p">))</span>
<span class="c1">// after 1000 years...
</span><span class="c1"></span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="c1">// maybe panic!
</span></code></pre></div><p><code>uintptr</code> 可以用来进行指针运算，实际上就是一个非常大的无符号整数类型，可以表示所有地址空间。上述代码可能会 panic 的原因是 i 变量可能会被 Garbage Collector（gc） 回收。一般这个 uintptr 类型只作为中间值参与运算。</p>
<h4 id="使用案例">使用案例</h4>
<p>go slice 的创建是通过 makeslice 创建，返回值是一个结构体：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">makeslice</span><span class="p">(</span><span class="nx">et</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">slice</span>
</code></pre></div><p>我们可以通过以下两种方式获取切片的长度：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="nf">Println</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">int</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">))</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">8</span><span class="p">))))</span> <span class="c1">// 8
</span><span class="c1"></span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span> <span class="c1">// 8
</span></code></pre></div><p>把 <code>uintptr(8)</code> 改为 <code>uintptr(16)</code> 就可以获取到容量了。</p>
<p>如果我们想获取 map 的大小，需要有一点小小的改变，因为 map 的创建是通过 makemap 函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">makemap</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">hint</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">bucket</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="o">*</span><span class="nx">hmap</span>
</code></pre></div><p>该返回的是一个指针，由于再次取地址，是二级指针，所以我们稍稍修改一下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">mm</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="nf">Println</span><span class="p">(</span><span class="o">**</span><span class="p">(</span><span class="o">**</span><span class="kt">int</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mm</span><span class="p">)))</span>  <span class="c1">// 8
</span></code></pre></div><h3 id="三函数alignofsizeof和offsetof">三函数Alignof、Sizeof和Offsetof</h3>
<p>看了上面的内容，可能会有一个疑问，这有什么用呢？不是有更优的 “常规” 解法吗？</p>
<p>我想说的是，除了 <code>zero-copy</code> 来转换 slice 与 string 这个例子之外，还有一个场景。</p>
<p>如果结构体成员私有，包外如何访问？你不能通过常规的运算符 &lsquo;.&rsquo; 来访问到私有字段，就要借助 unsafe 包了。通过 <code>unsafe.Sizeof</code> 函数计算偏移字段的大小和，直接获取到目标字段的地址偏移：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">a</span>
<span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">a</span> <span class="kt">int</span>
    <span class="nx">b</span> <span class="kt">bool</span>
    <span class="nx">c</span> <span class="kt">byte</span>
<span class="p">}</span>

<span class="kn">package</span> <span class="nx">b</span>
<span class="nx">t</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">T</span><span class="p">{</span> <span class="nx">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">c</span><span class="p">:</span> <span class="mi">2</span> <span class="p">}</span>
<span class="nx">tc</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">))</span> <span class="o">+</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="kc">true</span><span class="p">))</span>
<span class="nf">Println</span><span class="p">(</span><span class="nx">tc</span><span class="p">)</span> <span class="c1">// 2
</span></code></pre></div><h3 id="总结">总结</h3>
<p>Go 语言中和了 C/C++ 和 Java 语言对指针提供的能力，有效地解决了指针滥用导致内存泄露、非法访问等安全问题。通过静态语言的严格类型系统限制了一些内存操作，也提供了一个不安全但 “炫酷” 的 unsafe 包，标准库的源码许多都使用了 unsafe 包所提供了能力，高效简洁，让我们仿佛在看 C 系语言源码。这也不难理解，Go 语言的创始人之一正是 C 语言的创造者之一，许多设计思想优秀且独树一帜。</p>
<p>不过之所以命名为 unsafe，也是因为可以直接绕过类型系统直接操作底层内存，会带来一定的安全问题，与 GC 的工作 “冲突”，所以需要我们谨慎使用。</p>
]]></content></item><item><title>深入理解 Go channel</title><link>https://kcode.icu/posts/go/2021-02-22-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3go-channel/</link><pubDate>Thu, 25 Feb 2021 19:35:20 +0000</pubDate><guid>https://kcode.icu/posts/go/2021-02-22-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3go-channel/</guid><description>Go 语言的 Channel 关键字是实现其原生并发编程的关键组成，你可能听说过 “不要通过共享内存的方式通信，要通过通信的方式共享内存”，这句话正是针对 Channel 说的。
Go 语言倡导通过通信的方式共享内存，也就是减少锁的使用，尽量都通过 Channel 来进行协程间通信。
其实这被称为一种并发模型名为 CSP（Communicating Sequential Processes），即通信顺序进程。
两个实体 goroutine 通过 Channel 通信，收发消息。
数据结构 Channel 是一种 带锁环状队列，运行时结构定义在 runtime/chan.hchan ，代码也比较容易理解。
type hchan struct { qcount uint // 队列中元素数量 dataqsiz uint // 环形队列总大小 buf unsafe.Pointer // 底层数组指针 elemsize uint16 // 元素大小 closed uint32 // 是否已关闭 elemtype *_type // 元素类型 sendx uint // 发送端下标 recvx uint // 接收端下标 recvq waitq // 接收端等待队列 sendq waitq // 发送端等待队列 // 保护 hchan 并发访问的字段 lock mutex } type waitq struct { first *sudog // 等待队列链表的头节点 last *sudog // 尾节点 } 通过两个指针指向发送端和接收端接下来的操作位置，结合锁机制完成数据操作，这是很容易想到的并发处理方式。runtime/chan.</description><content type="html"><![CDATA[<p>Go 语言的 Channel 关键字是实现其原生并发编程的关键组成，你可能听说过 “不要通过共享内存的方式通信，要通过通信的方式共享内存”，这句话正是针对 Channel 说的。</p>
<p>Go 语言倡导通过通信的方式共享内存，也就是减少锁的使用，尽量都通过 Channel 来进行协程间通信。</p>
<p>其实这被称为一种并发模型名为 CSP（Communicating Sequential Processes），即通信顺序进程。</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/csp.svg" alt="csp"></p>
<p>两个实体 goroutine 通过 Channel  通信，收发消息。</p>
<h2 id="数据结构">数据结构</h2>
<p>Channel 是一种 <strong>带锁环状队列</strong>，运行时结构定义在 <a href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/chan.go#L32">runtime/chan.hchan</a> ，代码也比较容易理解。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">hchan</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">qcount</span>   <span class="kt">uint</span>           <span class="c1">// 队列中元素数量
</span><span class="c1"></span>	<span class="nx">dataqsiz</span> <span class="kt">uint</span>           <span class="c1">// 环形队列总大小
</span><span class="c1"></span>	<span class="nx">buf</span>      <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 底层数组指针
</span><span class="c1"></span>	<span class="nx">elemsize</span> <span class="kt">uint16</span>			<span class="c1">// 元素大小
</span><span class="c1"></span>	<span class="nx">closed</span>   <span class="kt">uint32</span>			<span class="c1">// 是否已关闭
</span><span class="c1"></span>	<span class="nx">elemtype</span> <span class="o">*</span><span class="nx">_type</span> 		<span class="c1">// 元素类型
</span><span class="c1"></span>	<span class="nx">sendx</span>    <span class="kt">uint</span>   <span class="c1">// 发送端下标
</span><span class="c1"></span>	<span class="nx">recvx</span>    <span class="kt">uint</span>   <span class="c1">// 接收端下标
</span><span class="c1"></span>	<span class="nx">recvq</span>    <span class="nx">waitq</span>  <span class="c1">// 接收端等待队列
</span><span class="c1"></span>	<span class="nx">sendq</span>    <span class="nx">waitq</span>  <span class="c1">// 发送端等待队列
</span><span class="c1"></span>
	<span class="c1">// 保护 hchan 并发访问的字段
</span><span class="c1"></span>	<span class="nx">lock</span> <span class="nx">mutex</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">waitq</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">first</span> <span class="o">*</span><span class="nx">sudog</span>	<span class="c1">// 等待队列链表的头节点
</span><span class="c1"></span>	<span class="nx">last</span>  <span class="o">*</span><span class="nx">sudog</span>	<span class="c1">// 尾节点
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>通过两个指针指向发送端和接收端接下来的操作位置，结合锁机制完成数据操作，这是很容易想到的并发处理方式。<a href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/chan.go#L53">runtime/chan.waiq</a> 是阻塞等待 goroutine 的双向链表，每一个节点是一个封装了的 goroutine，被命名为 <code>sudog</code>，定义在 <a href="https://github.com/golang/go/blob/41d8e61a6b/src/runtime/runtime2.go#L345">runtime/runtime2.go</a> 。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">sudog</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">g</span> <span class="o">*</span><span class="nx">g</span>

	<span class="nx">next</span> <span class="o">*</span><span class="nx">sudog</span>
	<span class="nx">prev</span> <span class="o">*</span><span class="nx">sudog</span>
	<span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// data element (may point to stack)
</span><span class="c1"></span>	<span class="o">...</span>

<span class="p">}</span>
</code></pre></div><p><code>next</code> 和 <code>prev</code> 就是指向前后节点的指针，并且包裹了一个 goroutine 结构。</p>
]]></content></item><item><title>记 MySQL 5.7.5 及以上实现的功能检测依赖报错分析</title><link>https://kcode.icu/posts/chore/2021-02-24-%E8%AE%B0-mysql-5.7.5-%E5%8F%8A%E4%BB%A5%E4%B8%8A%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%9F%E8%83%BD%E6%A3%80%E6%B5%8B%E4%BE%9D%E8%B5%96/</link><pubDate>Wed, 24 Feb 2021 15:15:13 +0000</pubDate><guid>https://kcode.icu/posts/chore/2021-02-24-%E8%AE%B0-mysql-5.7.5-%E5%8F%8A%E4%BB%A5%E4%B8%8A%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%9F%E8%83%BD%E6%A3%80%E6%B5%8B%E4%BE%9D%E8%B5%96/</guid><description>秉承着 “软件均使用最新版本，学习均从文档入手” 的理念，学习使用 MySQL 我也是在使用最新的大版本 MySQL 8，而在技术发展过程中，一个不可忽视的因素就是兼容性，在保证新特性无误的同时必须确保以前的功能不受影响，如果不能保证这一点，那么许多使用者在迁移的时候就需要考虑很多改动成本，除非不是大改动，一般都会考虑到这一点，比如 HTTP/2 、TLS/1.3 等等。
错误描述及分析 最近为学校写一个选课平台时关系型数据库使用的是 MySQL 8+，使用 Group by 时报了这个错误：
ERROR 1055 (42000): Expression #2 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'mydb.t.address' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by 意思是说 select 列表中包含了非聚合列，其并不函数依赖于 Group by 子句中的列。并且和 sql_mode 这个配置项的 only_full_group_by 值冲突。不过这篇文章并不只是单纯说解决方法，如果想要解决方法请直接移步文末。
可以确定的是同样的使用了 Group by 的 SQL 查询语句在低版本中是正常的但是高版本却不行，猜测可能是版本差异造成的，而且还是因为这个配置项导致的。
所以虽然我们一开始可能看不懂这个报错信息，但是我们通过一些分析已经定位了问题，并且报错的错误码明显（ERROR 1055(42000)），报错提示信息清楚，并不难找到解决方法。</description><content type="html"><![CDATA[<p>秉承着 “软件均使用最新版本，学习均从文档入手” 的理念，学习使用 MySQL 我也是在使用最新的大版本 MySQL 8，而在技术发展过程中，一个不可忽视的因素就是兼容性，在保证新特性无误的同时必须确保以前的功能不受影响，如果不能保证这一点，那么许多使用者在迁移的时候就需要考虑很多改动成本，除非不是大改动，一般都会考虑到这一点，比如 HTTP/2 、TLS/1.3 等等。</p>
<h2 id="错误描述及分析">错误描述及分析</h2>
<p>最近为学校写一个选课平台时关系型数据库使用的是 MySQL 8+，使用 Group by 时报了这个错误：</p>
<pre><code>ERROR 1055 (42000): Expression #2 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'mydb.t.address' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
</code></pre><p>意思是说 select 列表中包含了非聚合列，其并不函数依赖于 Group by 子句中的列。并且和 <code>sql_mode</code> 这个配置项的  <code>only_full_group_by</code> 值冲突。不过这篇文章并不只是单纯说解决方法，如果想要解决方法请直接移步文末。</p>
<p>可以确定的是同样的使用了 Group by 的 SQL 查询语句在低版本中是正常的但是高版本却不行，猜测可能是版本差异造成的，而且还是因为这个配置项导致的。</p>
<p>所以虽然我们一开始可能看不懂这个报错信息，但是我们通过一些分析已经定位了问题，并且报错的错误码明显（ERROR 1055(42000)），报错提示信息清楚，并不难找到解决方法。</p>
<h2 id="追根溯源">追根溯源</h2>
<p>为了更好理解错误原因，举个例子，假定你有这个查询语句：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span> <span class="n">name</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="nf">MAX</span><span class="p">(</span><span class="n">age</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">t</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">name</span><span class="p">;</span>
</code></pre></div><p>看起来很正常，但是如果 name 列不是主键，并且表中数据是这样子呢：</p>
<pre><code>name 	address 	age
wasabi	   a         2
wasabi	   b         2
</code></pre><p>分组以后 MAX(age) 还相同怎么办，是显示 a 地址还是 b 地址呢？MySQL 这就确定不了了，所以在 <strong>MySQL5.7.5 及以上</strong> 引入了函数依赖检测，具体描述是：如果 SELECT 列表，HAVING 条件，ORDER BY 列表应用了聚合列，但是并没有在 Group by 子句中命名，就会拒绝查询，如果启用了 ONLY_FULL_GROUP_BY 这个配置项也可以引用非聚合列，可以有多列，但是必须确保每列值唯一，不然会引起冲突。</p>
<p>不过你也可以通过允许任意值来让 MySQL 为你随便选一个返回，比如这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span> <span class="n">name</span><span class="p">,</span> <span class="nf">ANY_VALUE</span><span class="p">(</span><span class="n">address</span><span class="p">),</span> <span class="nf">MAX</span><span class="p">(</span><span class="n">age</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">t</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">name</span><span class="p">;</span>
</code></pre></div><p>再举个例子，你有这些数据，使用如下查询语句：</p>
<pre><code>c1 c2 c3
1  2  A
3  4  B
1  2  C

SELECT DISTINCT c1, c2 FROM t ORDER BY c3;
</code></pre><p>你应该返回哪行呢，第一行还是第三行？无法确定，这就是 MySQL 解决的问题。</p>
<h2 id="总结">总结</h2>
<p>MySQL 在 5.7.5+ 版本实现了函数依赖检测，如果某些列中不存在函数依赖关系，还没有被引用使用的话，就认为可能存在冲突，所以为 sql_mode 配置项增加了一个列表值 <code>ONLY_FULL_GROUP_BY</code> 你可以通过这些命令查看这个配置项的值：</p>
<pre><code>mysql&gt; select @@global.sql_mode;
mysql&gt; select @@session.sql_mode;

+---------------------------------------------------------------+
| @@session.sql_mode                                            |
+---------------------------------------------------------------+
| ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION |
+---------------------------------------------------------------+
</code></pre><p>然后通过 set 来重新设置这个值，把这个列表项去掉即可：</p>
<pre><code>set @@global.sql_mode='STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION';
</code></pre><h2 id="扩展阅读">扩展阅读</h2>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/group-by-handling.html">MySQL5.7 版本对于GroupBy的处理</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sqlmode_only_full_group_by">sql_mode配置中的ONLY_FULL_GROUP_BY配置项</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/group-by-functional-dependence.html">函数依赖</a></li>
</ul>
]]></content></item><item><title>深入理解 Go string 与 slice</title><link>https://kcode.icu/posts/go/2021-02-20-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3go-string-slice/</link><pubDate>Mon, 15 Feb 2021 23:35:20 +0000</pubDate><guid>https://kcode.icu/posts/go/2021-02-20-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3go-string-slice/</guid><description>数据结构 我们先通过标准库源码来简单看一下。string 和 slice 的数据结构都定义在 reflect/value.go 中，分别对应着 StringHeader 和 SliceHeader 。
type StringHeader struct { Data uintptr Len int } type SliceHeader struct { Data uintptr Len int Cap int } 定义非常简单，Data 表示底层数据的地址，Len 表示长度，Cap 表示容量。容量评估了当前切片最多能容纳多少字节元素，而长度表示当前已经存储多少个字节了，切片只是对底层数据的引用：
[图片]
字符串就是字符的数组，我们先来看个小程序的例子：
package main func main() { s := &amp;#34;abc&amp;#34; println(s) } 我们执行 go tool compile -S main.go 使用自带工具包查看汇编代码，可以看到有这样一段信息：
... go.string.&amp;quot;abc&amp;quot; SRODATA dupok size=3 0x0000 61 62 63 abc ... 很直观的可以看到字符串被分配到了 RODATA 区段，也就是只读区段（Read Only），也就是说 Go 字符串是不可修改的。</description><content type="html"><![CDATA[<h2 id="数据结构">数据结构</h2>
<p>我们先通过标准库源码来简单看一下。string 和 slice 的数据结构都定义在 <code>reflect/value.go</code> 中，分别对应着 <a href="https://github.com/golang/go/blob/ac0ba6707c/src/reflect/value.go#L1983">StringHeader</a> 和 <a href="https://github.com/golang/go/blob/ac0ba6707c/src/reflect/value.go#L1994">SliceHeader</a> 。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">StringHeader</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Data</span> <span class="kt">uintptr</span>
	<span class="nx">Len</span>  <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SliceHeader</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Data</span> <span class="kt">uintptr</span>
	<span class="nx">Len</span>  <span class="kt">int</span>
	<span class="nx">Cap</span>  <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div><p>定义非常简单，Data 表示底层数据的地址，Len 表示长度，Cap 表示容量。容量评估了当前切片最多能容纳多少字节元素，而长度表示当前已经存储多少个字节了，切片只是对底层数据的引用：</p>
<p>[图片]</p>
<p>字符串就是字符的数组，我们先来看个小程序的例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">s</span> <span class="o">:=</span> <span class="s">&#34;abc&#34;</span>
	<span class="nb">println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>我们执行 <code>go tool compile -S main.go</code> 使用自带工具包查看汇编代码，可以看到有这样一段信息：</p>
<pre><code>...
go.string.&quot;abc&quot; SRODATA dupok size=3
        0x0000 61 62 63    abc
...
</code></pre><p>很直观的可以看到字符串被分配到了 RODATA 区段，也就是只读区段（Read Only），也就是说 <strong>Go 字符串是不可修改的</strong>。</p>
]]></content></item><item><title>https 为什么安全</title><link>https://kcode.icu/posts/https/</link><pubDate>Wed, 27 Jan 2021 15:57:50 +0000</pubDate><guid>https://kcode.icu/posts/https/</guid><description>截图均使用了 Wireshark 工具进行抓包分析。
HTTPS 并不是一种新的协议，而是 HTTP over SSL/TLS，也就是使用了 SSL/TLS 加密的 HTTP，解决了 HTTP 不安全的问题。SSL（Secure Sockets Layer） 是 TLS（Transport Layer Security） 的前身，它们都处在 OSI 七层模型中的会话层。SSL 经历了三个版本的变迁，后来升级为了 TLS，TLS 主要有 1.0、1.1、1.2 和 1.3，现在大部分正在从 1.1 到 1.2 的迁移，部分使用 1.3，我们可以使用 Wireshark 过滤一下进行简单查看。
需要注意的是，应用了 HTTPS 后通信效率会变低，毕竟需要进行额外的握手，加解密步骤。
SSL/TLS 加密手段本质就是进行若干次握手，协商出一个对称加密的密钥用于后续加密通信。主要可以分为两种方式，RSA 和 ECDH。RSA 方式也在 TLS/1.3 中正式被废除。下面我们分别来看。
证书 不管什么版本的 SSL/TLS，只使用对称加密和非对称加密也是不够的，因为无法解决 中间人攻击，都需要配合证书来完成整个验证过程。所以在说明各个阶段的 HTTPS 之前有必要介绍一下证书的几个概念。
证书的作用有两个：
确保通信目标的身份。 确认你的身份。 其实就是确认通信双方的身份，而不是中间某个第三者。再结合非对称加密与对称加密，就可以解决 HTTP 的三大问题：明文传输，消息篡改，窃听。证书的整个流程如下图：
加密与签名 这里有一点需要注意，非对称加密中 RSA 算法有一个非常好的特性，它的公私钥有两种用法，被称为 加密 和 签名 ，很多人容易搞混。不过需要记住不变的是 私钥永远需要保密，不能公布。</description><content type="html"><![CDATA[<blockquote>
<p>截图均使用了 <a href="https://www.wireshark.org/">Wireshark</a> 工具进行抓包分析。</p>
</blockquote>
<p>HTTPS  并不是一种新的协议，而是 <code>HTTP over SSL/TLS</code>，也就是使用了 SSL/TLS 加密的 HTTP，解决了 HTTP 不安全的问题。SSL（Secure Sockets Layer） 是 TLS（Transport Layer Security） 的前身，它们都处在 OSI 七层模型中的会话层。SSL 经历了三个版本的变迁，后来升级为了 TLS，TLS 主要有 1.0、1.1、1.2 和 1.3，现在大部分正在从 1.1 到 1.2 的迁移，部分使用 1.3，我们可以使用 Wireshark 过滤一下进行简单查看。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/640.png" alt="Wireshark截图"></p>
<p>需要注意的是，应用了 HTTPS 后通信效率会变低，毕竟需要进行额外的握手，加解密步骤。</p>
<p>SSL/TLS 加密手段本质就是进行若干次握手，协商出一个对称加密的密钥用于后续加密通信。主要可以分为两种方式，RSA 和 ECDH。RSA 方式也在 TLS/1.3 中正式被废除。下面我们分别来看。</p>
<h2 id="证书">证书</h2>
<p>不管什么版本的 SSL/TLS，只使用对称加密和非对称加密也是不够的，因为无法解决 <strong>中间人攻击</strong>，都需要配合证书来完成整个验证过程。所以在说明各个阶段的 HTTPS 之前有必要介绍一下证书的几个概念。</p>
<p>证书的作用有两个：</p>
<ul>
<li>确保通信目标的身份。</li>
<li>确认你的身份。</li>
</ul>
<p>其实就是确认通信双方的身份，而不是中间某个第三者。再结合非对称加密与对称加密，就可以解决 HTTP 的三大问题：明文传输，消息篡改，窃听。证书的整个流程如下图：</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/ca.png" alt="ca"></p>
<h3 id="加密与签名">加密与签名</h3>
<p>这里有一点需要注意，非对称加密中 RSA 算法有一个非常好的特性，它的公私钥有两种用法，被称为 <strong>加密</strong> 和 <strong>签名</strong> ，很多人容易搞混。不过需要记住不变的是 <strong>私钥永远需要保密</strong>，不能公布。</p>
<ul>
<li>前者是使用公钥加密，私钥解密。将公钥发布出去，只有自己才能获得加密信息，用于 <strong>保护信息</strong>。</li>
<li>后者是私钥加密，公钥解密。用于 <strong>判断信息是否被篡改</strong>。</li>
</ul>
<p>加密很好理解，签名可以这样理解：私钥加密的签名其他人无法伪造（其他人没有私钥），而你将经过私钥加密的信息和未加密明文还有公钥一起交付，对方就可以用公钥去解密（公钥是公开的），然后比对，如果一致了就说明信息没有被篡改，否则已经被改过了，抛弃。</p>
<p>整个过程可以参考上图，证书验证的过程就是使用了加密和签名两种手段。</p>
<h3 id="信任链">信任链</h3>
<p>在你申请到 CA 的证书并部署，在客户端请求时返回后，客户端的验证过程是有信任链验证的。你可以随便打开一个部署了 HTTPS 的站点，点击锁图标查看证书路径。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/image-20210129114612091.png" alt=""></p>
<p>可以看到你的证书是处于最下级，也就是三级证书，这个证书是由上一级证书机构 Secure Site CA G2 签发的，由于它不是根证书，无法认为它可靠，所以要再向上级寻找直到根证书。然后使用根证书公钥验证二级证书，依次向下，直到目标服务器的证书。</p>
<p>为什么要这样一步一步验证好多次呢？</p>
<p>因为我们只相信根证书，而根证书是部署在操作系统上的，是被我们信任的。Windows 10 系统可以通过</p>
<pre><code>控制面板 -&gt; 搜索证书 -&gt; 管理计算机证书 
</code></pre><p>方式之一来查看本地根证书。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/Snipaste_2021-01-28_21-32-27.png" alt=""></p>
<p>好了，你现在应该大致明白了证书的验证过程，再来一张图看总结一下。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/640%20(1).png" alt="640 (1)"></p>
<p>至此，我们已经利用证书机制确保了通信双方的身份，解决了不安全的问题之一。</p>
<h2 id="tls12ecdhe">TLS1.2/ECDHE</h2>
<p>先来看一下最常见的 ECDHE 方式握手步骤图：</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/tls-hs-ecdhe.png" alt="tls-hs-ecdhe"></p>
<p>TLS/1.2 的共需要 4 次握手，花费两个 RTT（Round-Trip Time，RTT），如果加上 TCP 握手就是一共 7 次握手，再加上 HTTP 的一次报文交换，一共需要 4.5 个 RTT。</p>
<p>握手过程较为麻烦，大致过程如下：</p>
<ol>
<li>
<p>客户端向服务端发送 <strong>Client Hello</strong> 消息，其中携带客户端支持的<strong>协议版本</strong>，<strong>加密套件</strong>，压缩算法、<strong>客户端生成的随机数</strong> 以及扩展列表，不过安全的客户端一般不允许压缩，会传递一个 null 作为唯一的压缩算法，来避免 <a href="https://en.wikipedia.org/wiki/CRIME">CRIME attack</a> 。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/client-hello.png" alt="client-hello"></p>
</li>
<li>
<p>服务端收到客户端发来的协议版本、加密算法等信息后：</p>
<ol>
<li>
<p>向客户端发送 <strong>Server Hello</strong> 消息，并选择其中一个协议版本、加密方法、会话 ID 以及 <strong>服务端生成的随机数</strong>；这里的加密方法格式非常规范：</p>
<pre><code>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
</code></pre><p>上面的加密套件的意思是：生成密钥所使用的算法为 ECDHE_RSA，后续通信使用的对称加密算法 128位的AES，分组模式是 GCM（对称加密的关键），哈希摘要算法 SHA256。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/server-hello.png" alt="server-hello"></p>
</li>
<li>
<p>向客户端发送 Certificate 消息，即服务端的证书链，其中包含证书支持的域名、发行方和有效期等信息；</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/server-certificate.png" alt=""></p>
</li>
<li>
<p>向客户端发送 Server Key Exchange 消息，传递 ECDHE 算法的参数，也被称为 server_params，还有签名等信息。这个过程还会被签名：</p>
<pre><code>SHA256(client_random + server_random + server_params)
</code></pre><p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/dhe-params.png" alt="dhe-params"></p>
</li>
<li>
<p>向客户端发送可选的消息 CertificateRequest，验证客户端的证书。因为 TLS 握手是一个双向认证的过程，所以服务端可以向客户端发送请求来验证客户端身份。这个验证的回复在客户端第三次握手阶段发出。</p>
</li>
<li>
<p>向客户端发送 Server Hello Done 消息，通知服务端已经发送了全部的相关信息；</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/server-hello-done.png" alt="server-hello-done"></p>
</li>
</ol>
</li>
<li>
<p>客户端收到服务端的协议版本、加密方法、会话 ID 以及证书等信息后，验证服务端的证书；</p>
<ol>
<li>
<p>向服务端发送 Client Key Exchange 消息，包含客户端生成的公钥字符串，然后计算得到预主密钥（Pre Master Secret），再利用之前在客户端和服务端分别产生的两个随机数，还有伪随机数函数也就是 SHA256 哈希摘要函数，最终计算得到最终的主密钥（Master Key）；</p>
<pre><code>master_secret = PRF(pre_master_secret, &quot;master secret&quot;, client_random + server_random)[0..47]
</code></pre><p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/client-dhe-key%20(1).png" alt="client-dhe-key (1)"></p>
</li>
<li>
<p>向服务端发送 Change Cipher Spec 消息，通知服务端后面的数据段会加密传输。</p>
</li>
<li>
<p>向服务端发送 Finished 消息，其中包含加密后的握手信息。这个消息包含之前通信的所有信息以及之前的两个随机字符串，求哈希值后再加密，确保服务端能正常解密并且确认无误，还能避免重放攻击。</p>
</li>
</ol>
</li>
<li>
<p>服务端收到 Change Cipher Spec 和 Finished 消息后计算得到预主密钥（Pre Master Secret），然后同样流程计算得到最终的主密钥；</p>
<ol>
<li>向客户端发送 Change Cipher Spec 消息，通知客户端后面的数据段会加密传输；</li>
<li>向客户端发送 Finished 消息，验证客户端的 Finished 消息并完成 TLS 握手；</li>
</ol>
</li>
</ol>
<p>TLS 握手的关键在于利用通信双方生成的随机字符串和服务端的公钥生成一个双方经过协商后的密钥，通信的双方可以使用这个对称的密钥加密消息防止中间人的监听和攻击，保证通信的安全。</p>
<p>这么多繁琐的步骤就是为了验证两方身份的情况下协商出一个对称加密的密钥。</p>
<p>你可能会问：</p>
<ul>
<li>非对称加密这么强什么都能干为啥还要再使用对称加密呢？
<ul>
<li>原因是<strong>对称加密效率高</strong>，是非对称加密的上百倍。你可以使用 openssl 工具的 speed 子命令来查看不同加密算法的性能测试。</li>
</ul>
</li>
<li>HTTPS 通信是一个双向的过程，服务端怎么确认客户端身份呢？
<ul>
<li>其实这是个可选项，比如网上银行这种场景，服务端会为客户端颁发证书，要求客户端在第三次握手时通过 <code>client certificate</code> 发送证书让服务端走一遍验证流程，确认客户端身份。</li>
</ul>
</li>
</ul>
<h2 id="传统rsa">传统RSA</h2>
<p>之所以说是传统 RSA，是因为使用了 RSA 公钥加密预主密钥（Pre-Master Key）。流程和 ECDH 的方式差不多，少了服务端的 <strong>Server Key Exchange</strong> 消息。这种方式的缺点是因为不具备 <strong>前向保密性</strong>，也就是说如果黑客一直收集你的加密信息，如果在未来某一个你的私钥泄露或者被计算出来了，你以前所有的加密信息都会被破解。</p>
<p>这也是为什么 ECDHE 算法最终在 TLS1.3 被保留，它在加密过程中使用临时产生的随机数作为椭圆曲线的参数来生成主密钥，这样就算私钥泄露，由于拿不到当时的随机密钥，也是没用的。主要流程如下：</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/rsa.png" alt="rsa"></p>
<h2 id="tls13">TLS1.3</h2>
<p>TLS1.3 为了解决向下兼容的问题，不能直接修改协议报文里的协议版本字段，这样会引起识别错误，导致 TLS 握手失败。所以就通过扩展字段来解决兼容问题：</p>
<pre><code>Handshake Protocol: Client Hello
    Version: TLS 1.2 (0x0303)
    Extension: supported_versions (len=11)
        Supported Version: TLS 1.3 (0x0304)
        Supported Version: TLS 1.2 (0x0303)
</code></pre><p>主要优化有两个方面。</p>
<h3 id="增强安全">增强安全</h3>
<p>TLS/1.3 精简了许多选项：</p>
<ul>
<li>只保留 AES、ChaCha20 对称加密算法</li>
<li>分组模式只能用 GCM、CCM 和 Poly1305</li>
<li>消息摘要算法只能用 SHA256、SHA384</li>
<li>密钥交换算法只有 ECDHE 和 DHE</li>
<li>椭圆曲线也只剩下 P-256（也称为 secp256r1，openssl 里叫 prime256v1） 和 x25519（最安全最快速） 等5种。</li>
</ul>
<blockquote>
<p>openssl 是知名的安全工具，几乎包含了所有公开的算法，你可以使用openssl speed命令来测试aes与rsa1024或rsa2048的速度，来直观的感受一下它们的速度差异。</p>
<p>我们平时在服务端需要生成一对公私要来交给 CA 或者其他用途的时候，一般也是使用 openssl 工具。</p>
</blockquote>
<p>加密套件只剩下 5 种了，看看之前的十几个套件。。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/new_suit.jpg" alt="new_suit"></p>
<h3 id="优化性能">优化性能</h3>
<p>客户端第一次握手：</p>
<pre><code>Handshake Protocol: Client Hello
    Version: TLS 1.2 (0x0303)
    Random: cebeb6c05403654d66c2329…
    Cipher Suites (18 suites)
        Cipher Suite: TLS_AES_128_GCM_SHA256 (0x1301)
        Cipher Suite: TLS_CHACHA20_POLY1305_SHA256 (0x1303)
        Cipher Suite: TLS_AES_256_GCM_SHA384 (0x1302)
    Extension: supported_versions (len=9)
        Supported Version: TLS 1.3 (0x0304)
        Supported Version: TLS 1.2 (0x0303)
    Extension: supported_groups (len=14)
        Supported Groups (6 groups)
            Supported Group: x25519 (0x001d)
            Supported Group: secp256r1 (0x0017)
    Extension: key_share (len=107)
        Key Share extension
            Client Key Share Length: 105
            Key Share Entry: Group: x25519
            Key Share Entry: Group: secp256r1
</code></pre><p>服务端第二次握手：</p>
<pre><code>Handshake Protocol: Server Hello
    Version: TLS 1.2 (0x0303)
    Random: 12d2bce6568b063d3dee2…
    Cipher Suite: TLS_AES_128_GCM_SHA256 (0x1301)
    Extension: supported_versions (len=2)
        Supported Version: TLS 1.3 (0x0304)
    Extension: key_share (len=36)
        Key Share extension
            Key Share Entry: Group: x25519, Key Exchange length: 32
</code></pre><p>TLS1.2 需要两个 RTT 完成握手，TLS1.3 优化为了一个 RTT。</p>
<p>具体的做法还是利用了扩展（因为要向下兼容，就像 HTTP 扩展可以无限增加首部字段一样）。</p>
<p>客户端第一次握手就发送自己这边的椭圆曲线参数，服务端也回复自己的参数。然后就可以生成主密钥了。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/tls13.png" alt="tls13"></p>
<p>TLS1.3 还多了一个 Vertificate Verify，也就是服务端用自己的私钥把以前的椭圆曲线参数等信息签名，确保消息没有被篡改。</p>
<h2 id="总结">总结</h2>
<p>说了这么多，我们回到最初的问题，https 为什么安全，我想可以大致总结如下：</p>
<p>整体上通过引入第三方 CA 和证书机制验证双方身份，加密确保消息不会被窃听，签名确保消息不会被篡改解决了 HTTP 三大不安全问题。</p>
<p>如果你从 HTTP -&gt; 传统RSA -&gt; TLS1.2 -&gt; TLS1.3 一路看过来就会发现，技术的变化也是需要时间的，有许多设计并不是一开始就完美无缺，<strong>方案总是需要实践的检验才能被人们认可</strong>。</p>
]]></content></item><item><title>深入理解 Go defer 版本差异与底层特性</title><link>https://kcode.icu/posts/go/2021-01-25-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3go-defer%E7%89%88%E6%9C%AC%E5%B7%AE%E5%BC%82%E4%B8%8E%E5%BA%95%E5%B1%82%E7%89%B9%E6%80%A7/</link><pubDate>Mon, 25 Jan 2021 23:35:20 +0000</pubDate><guid>https://kcode.icu/posts/go/2021-01-25-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3go-defer%E7%89%88%E6%9C%AC%E5%B7%AE%E5%BC%82%E4%B8%8E%E5%BA%95%E5%B1%82%E7%89%B9%E6%80%A7/</guid><description>defer 简介 defer 的作用是使某个/某些执行延时执行，常用在资源使用后的释放等场景，例如：
func DbInit() (sql.DB, error) { db, err := sql.Open() if err != nil { return nil, err } defer db.Close() ... } defer 有一些熟知的特性：
“先进后出”，也就是说如果使用了多个 defer，最先使用 的 defer 后的函数体 最后执行。 一定会执行，即 panic 后依然有效。 执行体参数在注册 defer 时确定。 &amp;hellip; 我们先来看看为什么。
结构定义 先来看看标准库中 runtime/runtime2.defer 的定义。
type _defer struct { siz int32 // 函数参数和返回值的大小 started bool heap bool // 是否分配在堆上 openDefer bool // 是否经过开放编码的优化 sp uintptr // defer函数体的栈顶指针 pc uintptr // 下一条指令地址 fn *funcval // 执行函数地址，如果是开放编码可以为空 _panic *_panic // 与之相关的panic链表 link *_defer // defer链表 .</description><content type="html"><![CDATA[<h2 id="defer-简介">defer 简介</h2>
<p>defer 的作用是使某个/某些执行延时执行，常用在资源使用后的释放等场景，例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">DbInit</span><span class="p">()</span> <span class="p">(</span><span class="nx">sql</span><span class="p">.</span><span class="nx">DB</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">sql</span><span class="p">.</span><span class="nf">Open</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p>defer 有一些熟知的特性：</p>
<ul>
<li>“先进后出”，也就是说如果使用了多个 defer，<strong>最先使用</strong> 的 defer 后的函数体 <strong>最后执行</strong>。</li>
<li>一定会执行，即 panic 后依然有效。</li>
<li>执行体参数在注册 defer 时确定。</li>
<li>&hellip;</li>
</ul>
<p>我们先来看看为什么。</p>
<h3 id="结构定义">结构定义</h3>
<p>先来看看标准库中 <a href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/runtime2.go#L907">runtime/runtime2.defer</a> 的定义。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">_defer</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">siz</span>     <span class="kt">int32</span>	<span class="c1">// 函数参数和返回值的大小
</span><span class="c1"></span>	<span class="nx">started</span> <span class="kt">bool</span>
	<span class="nx">heap</span>    <span class="kt">bool</span>	<span class="c1">// 是否分配在堆上
</span><span class="c1"></span>
	<span class="nx">openDefer</span> <span class="kt">bool</span>	<span class="c1">// 是否经过开放编码的优化
</span><span class="c1"></span>	<span class="nx">sp</span>        <span class="kt">uintptr</span>  <span class="c1">// defer函数体的栈顶指针
</span><span class="c1"></span>	<span class="nx">pc</span>        <span class="kt">uintptr</span>  <span class="c1">// 下一条指令地址
</span><span class="c1"></span>	<span class="nx">fn</span>        <span class="o">*</span><span class="nx">funcval</span> <span class="c1">// 执行函数地址，如果是开放编码可以为空
</span><span class="c1"></span>	<span class="nx">_panic</span>    <span class="o">*</span><span class="nx">_panic</span>  <span class="c1">// 与之相关的panic链表
</span><span class="c1"></span>	<span class="nx">link</span>      <span class="o">*</span><span class="nx">_defer</span>	<span class="c1">// defer链表
</span><span class="c1"></span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p>除堆分配和开放编码相关字段之外，其余字段很容易理解。这两个特性是在 1.13 与 1.14 引入的，重点解决 defer 性能问题，放在下文。还有一些字段是关于 gc 的，理解较为复杂，暂不讨论。</p>
<p>除此之外，有两个字段比较重要，<code>link</code> 与 <code>_panic</code>。前者将注册的许多 defer 串成链表，在执行的时候按预先定义的顺序访问，先恢复执行体函数所需的栈信息等操作，跳转到函数地址处执行；后者将 defer 与 panic 进行关联，确保发生 panic 后按序执行所有注册过的 defer 函数。</p>
<p>编译阶段会把 defer 关键字分为三种状态，分别是开放编码，栈分配，堆分配。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">state</span><span class="p">)</span> <span class="nf">stmt</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="k">switch</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Op</span> <span class="p">{</span>
        <span class="o">...</span>
        <span class="k">case</span> <span class="nx">ODEFER</span><span class="p">:</span>
			<span class="o">...</span>
			<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">hasOpenDefers</span> <span class="p">{</span>
				<span class="nx">s</span><span class="p">.</span><span class="nf">openDeferRecord</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>	<span class="c1">// 开放编码
</span><span class="c1"></span>			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">d</span> <span class="o">:=</span> <span class="nx">callDefer</span>	<span class="c1">// 堆分配
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Esc</span> <span class="o">==</span> <span class="nx">EscNever</span> <span class="p">{</span>
					<span class="nx">d</span> <span class="p">=</span> <span class="nx">callDeferStack</span>	<span class="c1">// 栈分配
</span><span class="c1"></span>				<span class="p">}</span>
				<span class="nx">s</span><span class="p">.</span><span class="nf">callResult</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span>
			<span class="p">}</span>
        <span class="o">...</span>
    <span class="p">}</span>
    <span class="o">...</span>
<span class="p">}</span>

</code></pre></div><p>早起的 Go （1.13 之前）会把 defer 所需内存全部分配在堆上，性能较差，在 1.13 时通过调用分析可选择分配在栈上以增加性能，提升了大约 30%，1.14 又增加了开放编码方式，使 defer 的调用损耗可以忽略不计（&lt;10ms）。</p>
<h3 id="现象背后的原因">现象背后的原因</h3>
<p>先讨论表象背后的底层原理，即</p>
<h2 id="版本差异">版本差异</h2>
<h2 id="总结">总结</h2>
]]></content></item><item><title>深入理解 Go map</title><link>https://kcode.icu/posts/go/2021-02-22-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3go-map/</link><pubDate>Fri, 22 Jan 2021 23:35:20 +0000</pubDate><guid>https://kcode.icu/posts/go/2021-02-22-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3go-map/</guid><description>哈希表 几乎所有语言都有 哈希表 这个数据结构，能够在平均 O(1)，最差 O(n) 的时间复杂度内增删改查元素，Go 语言哈希表的精妙设计使得它几乎不会出现 O(n) 的糟糕情况。这篇文章我就带你从使用到底层由浅入深地探究 Go map 的奥秘，一起作一个不只是会用的 ”大神“。
问题来源于实际，我们先看看这些实际问题 ：
声明。当我使用 :=，var，make，甚至 new 声明 map 的时候，编译器帮我们做了什么事情，它们有什么区别？ 增删改查。使用 数组+链表 的情况下如何设计才能避免 O(n) 的最差情况？ 注意事项。map 的键有什么要求？map 是值类型还是引用类型，函数传参时会有上层影响吗？是并发安全的吗？ 还有一个常识是 Go map 的 遍历是随机的，即多次遍历输出的结果不同，这个的原因会在后面提到。
设计方式/数据结构 Go map 实现哈希表使用的是 数组+链表 的形式，也就是使用链地址法解决的哈希冲突。这种方式桶的大小和元素个数之间没有关系，另外还有开放定址法，这是个宽泛的名字，具体包含线性探测法，再哈希法，平方探测法等等。
为了降低 map 操作的时间复杂度，引入了一个 负载因子 的概念，这个概念在其他实现哈希表这个数据结构的语言里也都有，比如 python 中这个值被定义为 2/3，Java 中是 0.75，这个值评估了哈希表里 实际上最好只存 多少比例的元素，而不是一直等到满载再处理，因为多到一定程度效率 可能 就低了。在 Go 语言里这个值被定义为 6.5，即每个桶里最多存 6.5 个，包括溢出桶。
当我们在 Go 语言中声明一个 map 的时候，实际上就是创建了一个 hmap 的结构体，它定义在 runtime/map.go 文件下，这个结构体包含了许多信息：map 的大小，桶数量、地址，溢出桶数量、地址等等。 哈希表就是实现一个映射关系，给出自变量 x，能够通过 平均 O(1) 的时间复杂度方法找到这个元素所对应的因变量 y=f(x) 来对它进行操作。</description><content type="html"><![CDATA[<h2 id="哈希表">哈希表</h2>
<p>几乎所有语言都有 <a href="https://en.wikipedia.org/wiki/Hash_table">哈希表</a> 这个数据结构，能够在平均 O(1)，最差 O(n) 的时间复杂度内增删改查元素，Go 语言哈希表的精妙设计使得它几乎不会出现 O(n) 的糟糕情况。这篇文章我就带你从使用到底层由浅入深地探究 Go map 的奥秘，一起作一个不只是会用的 ”大神“。</p>
<p>问题来源于实际，我们先看看这些实际问题 ：</p>
<ul>
<li><strong>声明</strong>。当我使用 <code>:=</code>，<code>var</code>，<code>make</code>，甚至 <code>new</code> 声明 map 的时候，编译器帮我们做了什么事情，它们有什么区别？</li>
<li><strong>增删改查</strong>。使用 数组+链表 的情况下如何设计才能避免 O(n) 的最差情况？</li>
<li><strong>注意事项</strong>。map 的键有什么要求？map 是值类型还是引用类型，函数传参时会有上层影响吗？是并发安全的吗？</li>
</ul>
<p>还有一个常识是 Go map 的 <strong>遍历是随机的</strong>，即多次遍历输出的结果不同，这个的原因会在后面提到。</p>
<h3 id="设计方式数据结构">设计方式/数据结构</h3>
<p>Go map 实现哈希表使用的是 <strong>数组+链表</strong> 的形式，也就是使用链地址法解决的哈希冲突。这种方式桶的大小和元素个数之间没有关系，另外还有开放定址法，这是个宽泛的名字，具体包含线性探测法，再哈希法，平方探测法等等。</p>
<p>为了降低 map 操作的时间复杂度，引入了一个 <a href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/map.go#L70">负载因子</a> 的概念，这个概念在其他实现哈希表这个数据结构的语言里也都有，比如 python 中这个值被定义为 2/3，Java 中是 0.75，这个值评估了哈希表里 <strong>实际上最好只存</strong> 多少比例的元素，而不是一直等到满载再处理，因为多到一定程度效率 <strong>可能</strong> 就低了。在 Go 语言里这个值被定义为 6.5，即每个桶里最多存 6.5 个，包括溢出桶。</p>
<p>当我们在 Go 语言中声明一个 map 的时候，实际上就是创建了一个 <a href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/map.go#L115">hmap</a> 的结构体，它定义在 <code>runtime/map.go</code> 文件下，这个结构体包含了许多信息：map 的大小，桶数量、地址，溢出桶数量、地址等等。 哈希表就是实现一个映射关系，给出自变量 x，能够通过 <strong>平均</strong> O(1) 的时间复杂度方法找到这个元素所对应的因变量 y=f(x) 来对它进行操作。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">hmap</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">count</span>     <span class="kt">int</span> 		<span class="c1">// map的大小，len()的结果就是这个字段值
</span><span class="c1"></span>	<span class="nx">flags</span>     <span class="kt">uint8</span>		<span class="c1">// map的状态，有四个
</span><span class="c1"></span>	<span class="nx">B</span>         <span class="kt">uint8</span>  	<span class="c1">// 桶数量的log_2对数，如B=5，桶数量就是2^5=32
</span><span class="c1"></span>	<span class="nx">noverflow</span> <span class="kt">uint16</span> 	<span class="c1">// 溢出桶的数量
</span><span class="c1"></span>	<span class="nx">hash0</span>     <span class="kt">uint32</span> 	<span class="c1">// 哈希种子
</span><span class="c1"></span>
	<span class="nx">buckets</span>    <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 桶数组的底层地址
</span><span class="c1"></span>	<span class="nx">oldbuckets</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 旧桶数组的底层地址
</span><span class="c1"></span>	<span class="nx">nevacuate</span>  <span class="kt">uintptr</span>        <span class="c1">// 迁移进度
</span><span class="c1"></span>
	<span class="nx">extra</span> <span class="o">*</span><span class="nx">mapextra</span> <span class="c1">// 溢出桶
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">mapextra</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">overflow</span>    <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>
	<span class="nx">oldoverflow</span> <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>

	<span class="c1">// 指向下一个空闲溢出桶
</span><span class="c1"></span>	<span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span>
<span class="p">}</span>
</code></pre></div><p>需要注意的是，如果 map 的键值都不包含指针并且是内联的，那么我们就会标注 map 为 ”不含指针类型“，这样就可以避免 GC 扫描 map，从而避免在 map 在过大时由于指针过多造成的 GC 扫描对象过多而缓慢的问题。所以将所有关于溢出桶的指针都放在了 extra 字段中。mapextra 字段保存了与溢出桶相关的信息，<code>overflow</code> 指向当前桶 <code>hmap.buckets</code> 的溢出桶，<code>oldoverflow</code> 指向旧桶 <code>hmap.oldbuckets</code> 的溢出桶。</p>
<p>真正存储数据的地方是 <a href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L149">bmap</a>，map 有 2^B 个 bmap，但是每个 bmap 只能存储 8 个键值对，多出来的就要找到一个溢出桶放进去，每个桶的数据结构都是一样的，bmap 结构只有 tophash 字段是因为 map 的 key 和 value 是需要 <strong>在编译时计算确定</strong>，所以需要在编译时动态构造桶结构。唯一的 tophash 字段是键值经过哈希函数计算后的值高八位。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">bmap</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">tophash</span> <span class="p">[</span><span class="nx">bucketCnt</span><span class="p">]</span><span class="kt">uint8</span>
<span class="p">}</span>
</code></pre></div><p>此外，动态运行时构造的 key 和 value 键值对并没有按照 key1/value1、key2/value2、&hellip;、keyN/valueN 的方式存储，而是如图形式，是为了避免因为字节对齐造成的内存浪费，也是因为 CPU 从内存中读取数据是每次读取固定大小的块（因为数据总线条数固定），这块内存也并不是连续的，这里不展开说了，总之，如果采用 key1/value1、key2/value2、&hellip;、keyN/valueN 的方式，如果 map 是 map[int64]int8 的时候，每个键值对就会由于内存不对齐造成 7 字节的内存浪费，其实也并不一定浪费，现在很多 CPU 也可以读取多块内存然后拼接组合成最终的数据，但是这样性能并不好。这一点在官方源代码里的 <a href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/map.go#L148">bmap</a> 结构体注释中有说明。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/map_zipper.svg" alt=""></p>
<h3 id="初始化">初始化</h3>
<p>Go 语言初始化 map 的方式有两种，字面量和运行时。</p>
<h4 id="字面量-">字面量 &ldquo;:=&rdquo;</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">m</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span> <span class="p">{</span>
    <span class="mi">1</span><span class="p">:</span> <span class="s">&#34;go&#34;</span><span class="p">,</span>
    <span class="mi">2</span><span class="p">:</span> <span class="s">&#34;lang&#34;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div><p>几乎所有语言都会提供字面量的方式进行初始化，Go 语言里的字面量初始化是使用了 &ldquo;:=&rdquo; 符号，这样来代表创建一个局部变量。Go 语言里的 map 也可以通过这种方式初始化，但是需要注意的是，还有一种初始化方式 <code>var m map[Type]Type</code> ，如果仅仅这样声明后就直接使用 <code>m[key] = value</code> 来写入是会 panic 的，因为没有分配实际内存。</p>
<p>通过这种方式初始化的 map 会调用 <a href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/cmd/compile/internal/gc/sinit.go#L753">maplit</a> 函数来执行具体的创建逻辑：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">maplit</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">m</span> <span class="o">*</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">init</span> <span class="o">*</span><span class="nx">Nodes</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="nf">nod</span><span class="p">(</span><span class="nx">OMAKE</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="nx">a</span><span class="p">.</span><span class="nx">Esc</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Esc</span>
	<span class="nx">a</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="nf">Set2</span><span class="p">(</span><span class="nf">typenod</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Type</span><span class="p">),</span> <span class="nf">nodintconst</span><span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="nf">Len</span><span class="p">())))</span>
	<span class="nf">litas</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">init</span><span class="p">)</span>

	<span class="nx">entries</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="nf">Slice</span><span class="p">()</span>

    <span class="c1">// ...
</span><span class="c1"></span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">entries</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">25</span> <span class="p">{</span>
		<span class="c1">// 如果数量非常多（指大于25个），就放进数组中循环处理。
</span><span class="c1"></span>
		<span class="c1">// 构建 [count]Tindex 和 [count]Tvalue
</span><span class="c1"></span>		<span class="nx">tk</span> <span class="o">:=</span> <span class="nx">types</span><span class="p">.</span><span class="nf">NewArray</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Type</span><span class="p">.</span><span class="nf">Key</span><span class="p">(),</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">entries</span><span class="p">)))</span>
		<span class="nx">te</span> <span class="o">:=</span> <span class="nx">types</span><span class="p">.</span><span class="nf">NewArray</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Type</span><span class="p">.</span><span class="nf">Elem</span><span class="p">(),</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">entries</span><span class="p">)))</span>
        
        <span class="c1">// 后续循环插入，类似
</span><span class="c1"></span>        <span class="c1">// for i = 0; i &lt; len(vstatk); i++ {
</span><span class="c1"></span>		<span class="c1">//	 map[vstatk[i]] = vstate[i]
</span><span class="c1"></span>		<span class="c1">// }
</span><span class="c1"></span>        
        <span class="o">...</span>
    <span class="p">}</span>
</code></pre></div><p>不管是哪种情况，最终都会通过 make 来创建哈希表数据结构并且通过 map[key] = value 的形式插入数据。</p>
<h4 id="运行时-make">运行时 &ldquo;make&rdquo;</h4>
<p>使用 make 创建 map 时有两种情况，一种是不给出大小，或者大小小于 8 的时候，会调用 <a href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L292">makemap_small</a> 来快速初始化一个 map：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">makemap_small</span><span class="p">()</span> <span class="o">*</span><span class="nx">hmap</span> <span class="p">{</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">hmap</span><span class="p">)</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span> <span class="p">=</span> <span class="nf">fastrand</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">h</span>
<span class="p">}</span>
</code></pre></div><p>显而易见，这种的方式的 map 是声明在堆上的。除了这种方式之外，map 会通过 <a href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L282">makemap64</a> 来将 map 的大小设置为 int32 后再调用 makemap 函数进行创建的主要逻辑：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">makemap</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">hint</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="o">*</span><span class="nx">hmap</span> <span class="p">{</span>
	<span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">hint</span><span class="p">),</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span> <span class="p">{</span>
		<span class="nx">hint</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">h</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">hmap</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span> <span class="p">=</span> <span class="nf">fastrand</span><span class="p">()</span>

	<span class="nx">B</span> <span class="o">:=</span> <span class="nb">uint8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">hint</span><span class="p">,</span> <span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">B</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="p">=</span> <span class="nx">B</span>

	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">nextOverflow</span> <span class="p">=</span> <span class="nf">makeBucketArray</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">nextOverflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">mapextra</span><span class="p">)</span>
			<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">nextOverflow</span> <span class="p">=</span> <span class="nx">nextOverflow</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">h</span>
<span class="p">}</span>
</code></pre></div><p><a href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L303">makemap</a> 函数做了这几件事：</p>
<ul>
<li>
<p>用桶的个数*8，判断内存是否足够分配，会不会溢出，如果会的话就置 0。</p>
</li>
<li>
<p>声明一个 map 结构体变量，初始化一个随机数用于哈希函数的计算。</p>
</li>
<li>
<p>用 make 内置函数的第二个参数 hint 判断出需要多少个桶，转换为对数存到 B 中。</p>
</li>
<li>
<p>如果 B 是 0 的话，就不分配内存，后续用的时候懒加载分配，所以从这里我们也能明白为什么平时说提前给出 map 的大小后续使用速度更快了。如果不是 0，就调用 <a href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L344">makeBucketArray</a> 分配底层的桶内存和溢出桶内存。</p>
</li>
</ul>
<p>这里会有一个判断 <code>nextOverflow != nil</code> ，这里就涉及在什么情况下初始化时要提前分配溢出桶，Go 语言是这样解决的：如果 B 大于 4，那么就认为后续使用溢出桶的概率比较大，就会预先分配 <code>2^(B-4)</code> 个溢出桶。然后分配专门用来描述溢出桶的结构 <code>hmap.extra</code>，其中指向下一个溢出桶地址的  <code>nextOverflow </code> 字段就指向分配好的溢出桶首地址。</p>
<p>正常桶和溢出桶的地址是连续的，只是被不同的字段引用而已，如果溢出桶不够用，会调用 <a href="runtime/newobject">runtime/newobject</a> 分配新的溢出桶。直到达到元素数量过多需要全量扩容或者重新哈希等量扩容，这个问题下文会详说。</p>
<h3 id="读写操作">读写操作</h3>
<p>Go 内置数据类型 map 是并发不安全的，也就是说多个 goroutine 同时对 map 执行写入操作会导致程序发生 panic 中断。官方解释说这是因为大多数情况下 map 并不需要并发安全，如果为所有 map 都加上并发操作的特性会使得大多数场景性能下降，为此 Go 在 1.9 版本引入了一种并发安全的 map 类型 <a href="https://github.com/golang/go/blob/41d8e61a6b/src/sync/map.go#L27">sync/map</a> ，留给读者自行探索。</p>
<h4 id="访问">访问</h4>
<p>map 的访问有两种形式：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">value</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">[</span><span class="s">&#34;I&#39;m a Key&#34;</span><span class="p">]</span>
</code></pre></div><p>Or</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">value</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">[</span><span class="s">&#34;I&#39;m a Key&#34;</span><span class="p">]</span>
</code></pre></div><p>第二种方式的第二个返回值是个布尔类型，代表该键在 map 中是否存在，类似于数据库或者其他概念中的 NULL 值，目的是为了不和所有该类型值冲突。两种方式的底层调用分别对应着 <a href="https://github.com/golang/go/blob/ac0ba6707c/src/runtime/map.go#L389">runtime/mapaccess1</a> 和 <a href="https://github.com/golang/go/blob/ac0ba6707c/src/runtime/map.go#L452">runtime/mapaccess2</a> ，Go 语言会在 <strong>运行时决定</strong> 使用哪种方式。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mapaccess1</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span>	<span class="nx">hash</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>
	<span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="p">(</span><span class="nx">hash</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
    <span class="c1">// ...
</span><span class="c1"></span>	<span class="nx">top</span> <span class="o">:=</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>
<span class="nx">bucketloop</span><span class="p">:</span>
	<span class="k">for</span> <span class="p">;</span> <span class="nx">b</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">top</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">emptyRest</span> <span class="p">{</span>
					<span class="k">break</span> <span class="nx">bucketloop</span>
				<span class="p">}</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">k</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">e</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
				<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
					<span class="nx">e</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">e</span><span class="p">))</span>
				<span class="p">}</span>
				<span class="k">return</span> <span class="nx">e</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zeroVal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></div><p>mapaccess1 的返回值是一个指向目标值的指针，如果不存在的话会返回该类型的零值而不会返回 nil。</p>
<p>依次做了这些事：</p>
<ul>
<li>通过 map 最开始初始化的哈希种子，用哈希函数计算出该键的哈希值 <code>hash</code>，这里的哈希函数使用了依赖注入的方式，并不固定。</li>
<li>计算桶的位掩码 <code>m</code>，也就是 B-1，用于后续做与运算确定该键位于哪个桶中。</li>
<li>与运算找到桶，桶的首地址+桶序号*桶大小动态计算出目标桶地址 <code>b</code>，取高八位哈希值 <code>tophash</code>，这里是通过位运算的方式取高位的，因为除法代价太高。</li>
<li>最后从桶的第一个 cell 开始，到最后一个溢出桶的最后一个 cell 为止遍历，先比较 tophash，如果一致了就用 tophash 值的下标和 map key 的大小计算出该 key 的偏移，再比较一次，这样可以加速查找，</li>
</ul>
<p>第二种形式的底层调用是 <a href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L452">mapaccess2</a> ，过程和第一种类似，只是在最后的两个 return 处多返回了一个布尔值：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">				<span class="c1">// ...
</span><span class="c1"></span>				<span class="k">return</span> <span class="nx">e</span><span class="p">,</span> <span class="kc">true</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zeroVal</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="kc">false</span>
</code></pre></div><p>还有一个函数 <a href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L511">mapaccessK</a> ，返回的是 map 的 key 和 value，用于 map 的 range 函数遍历，过程类似，不赘述了。</p>
<h4 id="写入">写入</h4>
<p>map 的写入操作对应底层 <a href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L571">runtime/map.go.mapassign</a> 函数。这个函数的签名如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mapassign</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
</code></pre></div><p>签名中并没有看到写入 key 所对应的 value 值表达式，唯一相关的返回值是一个指向任意类型的指针类型，可能有人就迷惑了，map 写入是依靠这个函数，我都没传 value 怎么写入呢？</p>
<p>答案是写入操作并没有写在标准库源码中，而是在汇编代码中。</p>
<pre><code class="language-assembly" data-lang="assembly">...
0x008e 00142 (notify.go:5)      CALL    runtime.mapassign_fast64(SB)
0x0093 00147 (notify.go:5)      MOVQ    24(SP), AX
0x0098 00152 (notify.go:5)      MOVQ    $666, (AX)
...
</code></pre><blockquote>
<p>学习 Go 底层原理时，时常要借助汇编代码一起分析，Go 官方也为我们提供了完整的工具包，其中 <code>go tool compile -S</code> 就十分有用，上面这些信息就是通过这个工具得到的。</p>
</blockquote>
<p><code>mapassign_fast64</code> 是针对不同类型的 key 做出的编译时优化，为了增加效率。</p>
<p>下面看一下这个函数的源码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mapassign</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
    <span class="c1">// 向空map中写入会panic，比如仅仅通过
</span><span class="c1"></span>    <span class="c1">// var mp map[int]int
</span><span class="c1"></span>    <span class="c1">// mp[1] = 2 // panic!
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;assignment to entry in nil map&#34;</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="o">...</span>
    <span class="c1">// 写map时会把flags标志位写位置1，写入时如果检测到已经置1，
</span><span class="c1"></span>    <span class="c1">// 说明并发写入，语言不支持，会panic
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;concurrent map writes&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">hash</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">hasher</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>

    <span class="c1">// 这个要在t.hasher之后，因为hasher调用可能panic，导致写入失败，没必要把写入位置1
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="p">^=</span> <span class="nx">hashWriting</span>

    <span class="c1">// 如果还没有桶就new一个
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span> <span class="p">=</span> <span class="nf">newobject</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">)</span> <span class="c1">// newarray(t.bucket, 1)
</span><span class="c1"></span>	<span class="p">}</span>

<span class="nx">again</span><span class="p">:</span>
	<span class="nx">bucket</span> <span class="o">:=</span> <span class="nx">hash</span> <span class="o">&amp;</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>	<span class="c1">// 与低B位确定在哪个桶
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="p">{</span>	<span class="c1">// 这个函数只有一行代码，h.oldbuckets != nil，判断是否迁移完毕
</span><span class="c1"></span>		<span class="nf">growWork</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">bucket</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">bucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span><span class="c1">// 用首地址+桶编号*单个桶大小定位到目标桶的地址
</span><span class="c1"></span>	<span class="nx">top</span> <span class="o">:=</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span> <span class="c1">// 计算tophash哈希值，用于找到key value
</span><span class="c1"></span>
    <span class="c1">// 完成了上面的各种判断，才会进行下面双重循环的判断，按照所有桶，每个桶里的8个位，按顺序遍历
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">inserti</span> <span class="o">*</span><span class="kt">uint8</span>
	<span class="kd">var</span> <span class="nx">insertk</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="kd">var</span> <span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="nx">bucketloop</span><span class="p">:</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">top</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="nx">inserti</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">inserti</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
					<span class="nx">insertk</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
					<span class="nx">elem</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">emptyRest</span> <span class="p">{</span>
					<span class="k">break</span> <span class="nx">bucketloop</span>
				<span class="p">}</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">k</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="c1">// already have a mapping for key. Update it.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">needkeyupdate</span><span class="p">()</span> <span class="p">{</span>
				<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">elem</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
			<span class="k">goto</span> <span class="nx">done</span>
		<span class="p">}</span>
		<span class="nx">ovf</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">ovf</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">b</span> <span class="p">=</span> <span class="nx">ovf</span>
	<span class="p">}</span>

	<span class="c1">// Did not find mapping for key. Allocate new cell &amp; add entry.
</span><span class="c1"></span>
	<span class="c1">// If we hit the max load factor or we have too many overflow buckets,
</span><span class="c1"></span>	<span class="c1">// and we&#39;re not already in the middle of growing, start growing.
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="o">||</span> <span class="nf">tooManyOverflowBuckets</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">noverflow</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">))</span> <span class="p">{</span>
		<span class="nf">hashGrow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">)</span>
		<span class="k">goto</span> <span class="nx">again</span> <span class="c1">// Growing the table invalidates everything, so try again
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">inserti</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// The current bucket and all the overflow buckets connected to it are full, allocate a new one.
</span><span class="c1"></span>		<span class="nx">newb</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">newoverflow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
		<span class="nx">inserti</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">newb</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="nx">insertk</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">newb</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span>
		<span class="nx">elem</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">insertk</span><span class="p">,</span> <span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="c1">// store new key/elem at insert position
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectkey</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">kmem</span> <span class="o">:=</span> <span class="nf">newobject</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span>
		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">insertk</span><span class="p">)</span> <span class="p">=</span> <span class="nx">kmem</span>
		<span class="nx">insertk</span> <span class="p">=</span> <span class="nx">kmem</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">vmem</span> <span class="o">:=</span> <span class="nf">newobject</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">)</span>
		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">elem</span><span class="p">)</span> <span class="p">=</span> <span class="nx">vmem</span>
	<span class="p">}</span>
	<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">insertk</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
	<span class="o">*</span><span class="nx">inserti</span> <span class="p">=</span> <span class="nx">top</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span>

<span class="nx">done</span><span class="p">:</span>
	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;concurrent map writes&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;^=</span> <span class="nx">hashWriting</span>
	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">indirectelem</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">elem</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">elem</span><span class="p">))</span>
	<span class="p">}</span>
    
    <span class="c1">// 返回elem地址，由汇编代码负责执行真正的写入操作
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">elem</span>
<span class="p">}</span>
</code></pre></div><h4 id="删除">删除</h4>
<p>删除对应的底层函数是 <a href="https://github.com/golang/go/blob/ac0ba6707c/src/runtime/map.go#L685">runtime/map.mapdelete</a> ，处理的思路非常相似，也是先判断各种情况，最后进行双重循环定位目标 cell，不再赘述了。</p>
<h4 id="扩容">扩容</h4>
<p>扩容过程较为复杂，总的来说，扩容分为 增量扩容 与 等量扩容，前者有两种情况触发，一是在桶不够用时，即容量到达扩容因子时，二是在，后者是在桶空间较为稀疏时触发，作用不同。</p>
<p>需要注意的一点是，扩容并不是一次性完成的，而是渐进式的，在每次进行写入操作时搬运一部分元素，主要目的也是为了防止瞬时的性能抖动对整个应用造成影响。</p>
<h5 id="等量扩容">等量扩容</h5>
<p>等量扩容的目的是使得桶的数据密度不至于过小，想象一种极端场景，一个哈希表有1个位置，拉链出了100个bucket，但只有一个元素，它在最后一个桶（正常桶+溢出桶）的最后一个位置上，我们每次访问这个元素，都需要从头到尾扫描这n个桶，直到找到这个元素，显而易见，这样效率非常低，所以go语言运行时会动态修改这个大小，进行数据的紧缩，使得数据密度增大增大，既增加了效率，也减少了所需空间。</p>
<p>等量扩容的代码在 xxxxx，</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
</code></pre></div><p>主要做了这些事：</p>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h5 id="增量扩容">增量扩容</h5>
<p>增量扩容的出现场景就是桶不够用，即容量到达了负载因子的限制大小，需要进行扩大，具体与hmap。b的大小有关：</p>
<ul>
<li>当b《=15时，如果桶大小一旦超过这个值扩容</li>
<li>当b》15，如果桶大小大于2…………15次方就扩容</li>
</ul>
<p>扩容时由于b的大小+1，所以掩码的低位位数会+1，最高位的0和1会把所有元素分到两个部分，在go中这两部分被命名为 evaluatex，evaluatey，</p>
<p>具体代码放在 xxxx，</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
</code></pre></div><h3 id="总结">总结</h3>
<p>Go 语言的 map 使用了数组+链表实现的哈希表，引入了溢出桶的概念以及触发扩容的条件机制来减少桶的扩容，实现了平均 O(1) 的时间复杂度内访问元素，基本不会出现最坏的情况。</p>
<p>访问元素的大致流程时：经过哈希计算后，用低 B 位确定桶位置，高 8 位比对 tophash 找到偏移，再通过偏移找到 key/value，或者执行插入或者新增溢出桶等等逻辑。</p>
<p>不管你使用字面量的方式还是 make 的方式声明 map，都是对应底层的 hmap 结构，获得了一个指向 hmap 的指针，并且 Go 语言针对不给出初始大小的 map 还进行了快速初始化的优化，针对 map 的大小过大（hmap.B 大于4），提前建立溢出桶的优化。</p>
<p>Go 提供了两种方式访问 map 中的元素，可以获得两个返回值，第二个返回值可以忽略，这用于空键值对的判断，类似于数据库中的 NULL，不和任何值冲突。并且 map 的遍历访问是随机的，这是因为每次遍历时会通过 fastrand 生成一个随机数，随机选择一个桶，再随机选择桶中的一个元素，先遍历完该桶，再顺次遍历后续的桶。map 是可以并发访问（指读）的，因为这并不会有任何冲突发生。</p>
]]></content></item><item><title>在线博客的图床解决方案</title><link>https://kcode.icu/posts/chore/blog_imgs/</link><pubDate>Wed, 20 Jan 2021 15:45:13 +0000</pubDate><guid>https://kcode.icu/posts/chore/blog_imgs/</guid><description>很多人应该都听说过来人说过要写博客进行总结记录，一是说自己学习过程的复盘，二是在某些时候向不认识自己的人间接显示自己的大致水平。不过如果没有人“手把手”教的话我相信还会遇到各种各样的问题的，这篇文章就介绍一下在博客中必不可少的图片网络地址解决方法，也就是图床。它的目标是在你写文章的过程中可以一键插入目标图片并自动上传到网络，就像你使用本地图片一样快捷。
图床的目的就是把你的本地图片上传上去，从而能获得它的网络地址。当然了，只使用图床也是可以的，但是需要配合对应的工具上传拿 URL（比如 OSS）或者纯手动（GitHub/Gitee），非常不方便 一点也不极客，所以需要配合其他工具一键快速拿到它对应的网络地址（URL），所以我在下面介绍了我使用到的工具，仅供参考。
评估用的稳定性指你上传的图片会不会在某个不确定的时间突然挂掉，让你的文章出现大量图片 404 丢失的情况。
图床 这里我介绍三种图床，列出优缺点。可以根据需要进行选择。
GitHub/Gitee GitHub 和 Gitee 是干什么的我就不多说了，它们也是可以作为图床使用的，前者境内访问较慢，后者较快。没有账号可以免费注册一个，然后随便创建一个公开仓库，把图片上传上去就可以获取它的 URL 了，比较简单粗暴。
优点：稳定性较好，空间无限，上手难度较简单
缺点：无法阻止盗链，无法管理（原本目的就不是作为图床，没有统计流量等功能）。
总结，如果你是新手，不担心自己的图片被别人轻易获取 ，随缘使用图床，这个是首选。
OSS OSS （Object Storage Service）即对象存储服务，用来做个人博客的图床有点小题大做，腾讯云、阿里云等等提供 OSS 的平台都可以，一般需要续费，一年 50G 左右话 10 块钱左右。
优点：可控性比较强，提供了专业的平台，你能想到的各种需求基本都有，包括防盗链，流量统计与分析等。
缺点：对新手不友好，根据流量付费。
总结，如果你未来博客流量会不断增大，出于可控考虑选这个，流量较小的新人不考虑。
不稳定第三方 也可以使用这种第三方的图床，没有任何操作步骤，上传完就拿到 URL，当然事物都有两面性，这种极致快捷带来的就是不稳定，就跟当年的新浪图床一样，你不知道什么时候它就没了。。
优点：简单快捷打开一键就用，免费
缺点：不知道什么时候你的图片就被人家清了。。然后你的文章里的图片就全部 404 了。。
总结，随缘党首选不解释，懂得都懂。
工具 这里就介绍我使用的两个配合工具，其他的可以自行搜索。
typora typora 是一款 Markdown 文本编辑软件，我相信写过 Markdown 的都听说过，它的特点是真正的实时显示，不左右分栏，扩展性强，灵活可配置。我个人平时写 Markdown 文本都是使用这个软件，具体可以去它的官网首页看，十分推荐。
PicGo PicGo 是一款使用 Node + Electron 开发的跨平台可视化图片上传开源软件，支持 N 种图床平台，配置灵活简单，最重要的是它支持插件功能，理论上支持任意图床平台的使用（需要提供相应上传下载的 API），可以自行开发插件。操作也比较简单，把图片拖到框里就可以拿到 URL。这张图是 gitee 相关配置，其他平台类似，只需若干个必要参数即可：
配合使用 前面说的这两种工具可以结合使用快速进行写作，在 typora 主界面上方，文件-&amp;gt;偏好设置-&amp;gt;图像，修改 PicGo 路径为你安装的路径下的 exe 地址。这样就可以做到你在 typora 里编辑时直接粘贴图片到文档里一键点击上传，非常方便。当然了，如果你不需要 typora，或者使用的是别的 Markdown 编辑器，也可以只使用 PicGo。</description><content type="html"><![CDATA[<p>很多人应该都听说过来人说过要写博客进行总结记录，一是说自己学习过程的复盘，二是在某些时候向不认识自己的人间接显示自己的大致水平。不过如果没有人“手把手”教的话我相信还会遇到各种各样的问题的，这篇文章就介绍一下在博客中必不可少的图片网络地址解决方法，也就是图床。它的目标是<strong>在你写文章的过程中可以一键插入目标图片并自动上传到网络，就像你使用本地图片一样快捷。</strong></p>
<p>图床的目的就是把你的本地图片上传上去，从而能获得它的网络地址。当然了，只使用图床也是可以的，但是需要配合对应的工具上传拿 URL（比如 OSS）或者纯手动（GitHub/Gitee），<del>非常不方便</del> 一点也不极客，所以需要配合其他工具一键快速拿到它对应的网络地址（URL），所以我在下面介绍了我使用到的工具，仅供参考。</p>
<blockquote>
<p>评估用的稳定性指你上传的图片会不会在某个不确定的时间突然挂掉，让你的文章出现大量图片 404 丢失的情况。</p>
</blockquote>
<h1 id="图床">图床</h1>
<p>这里我介绍三种图床，列出优缺点。可以根据需要进行选择。</p>
<h2 id="githubgitee">GitHub/Gitee</h2>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/123.png" alt="Gitee"></p>
<p><a href="https://github.com/">GitHub</a> 和 <a href="https://gitee.com/">Gitee</a> 是干什么的我就不多说了，它们也是可以作为图床使用的，前者境内访问较慢，后者较快。没有账号可以免费注册一个，然后随便创建一个公开仓库，把图片上传上去就可以获取它的 URL 了，比较简单粗暴。</p>
<p>优点：稳定性较好，空间无限，上手难度较简单</p>
<p>缺点：无法阻止盗链，无法管理（原本目的就不是作为图床，没有统计流量等功能）。</p>
<p>总结，如果你是新手，不担心自己的图片被别人<strong>轻易获取</strong> ，随缘使用图床，这个是首选。</p>
<h2 id="oss">OSS</h2>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/image-20210120131946016.png" alt="aliyun OSS"></p>
<p>OSS （Object Storage Service）即对象存储服务，用来做个人博客的图床有点小题大做，腾讯云、阿里云等等提供 OSS 的平台都可以，一般需要续费，一年 50G 左右话 10 块钱左右。</p>
<p>优点：可控性比较强，提供了专业的平台，你能想到的各种需求基本都有，包括防盗链，流量统计与分析等。</p>
<p>缺点：对新手不友好，根据流量付费。</p>
<p>总结，如果你未来博客流量会不断增大，出于可控考虑选这个，流量较小的新人不考虑。</p>
<h2 id="不稳定第三方">不稳定第三方</h2>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/image-20210120132728890.png" alt="SM.MS"></p>
<p>也可以使用这种第三方的图床，没有任何操作步骤，上传完就拿到 URL，当然事物都有两面性，这种极致快捷带来的就是不稳定，就跟当年的新浪图床一样，你不知道什么时候它就没了。。</p>
<p>优点：简单快捷打开一键就用，免费</p>
<p>缺点：不知道什么时候你的图片就被人家清了。。然后你的文章里的图片就全部 404 了。。</p>
<p>总结，随缘党首选不解释，懂得都懂。</p>
<h1 id="工具">工具</h1>
<p>这里就介绍我使用的两个配合工具，其他的可以自行搜索。</p>
<h2 id="typora">typora</h2>
<p><a href="https://typora.io/">typora</a> 是一款 Markdown 文本编辑软件，我相信写过 Markdown 的都听说过，它的特点是真正的实时显示，不左右分栏，扩展性强，灵活可配置。我个人平时写 Markdown 文本都是使用这个软件，具体可以去它的官网首页看，十分推荐。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/GIF%202021-1-20%2018-44-01.gif" alt="实时转换"></p>
<h2 id="picgo">PicGo</h2>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/image-20210120134735352.png" alt=""></p>
<p><a href="https://github.com/Molunerfinn/PicGo">PicGo</a> 是一款使用 Node + Electron 开发的跨平台可视化图片上传开源软件，支持 N 种图床平台，配置灵活简单，最重要的是它支持插件功能，理论上支持任意图床平台的使用（需要提供相应上传下载的 API），可以自行开发插件。操作也比较简单，把图片拖到框里就可以拿到 URL。这张图是 gitee 相关配置，其他平台类似，只需若干个必要参数即可：</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/image-20210120135009612.png" alt="配置"></p>
<h2 id="配合使用">配合使用</h2>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/test.png" alt="PicGo配置"></p>
<p>前面说的这两种工具可以结合使用快速进行写作，在 typora 主界面上方，文件-&gt;偏好设置-&gt;图像，修改 PicGo 路径为你安装的路径下的 exe 地址。这样就可以做到你在 typora 里编辑时直接粘贴图片到文档里一键点击上传，非常方便。当然了，如果你不需要 typora，或者使用的是别的 Markdown 编辑器，也可以只使用 PicGo。</p>
<p>而且它是开源的，如果你有任何建议可以提 Issue 或者自己为它增加特性 :)</p>
<p>我这里就有一个相关需求，自定义重命名上传文件，我想将所有图片按照我自己的规则自动重命名后再上传，比如统一按照格式 <code>year-month-day-imgID</code> 这种格式，方便后续整理图片。当然了，这里只是抛砖引玉，更多的留给大家去探索 :)</p>
<p>最后配一个最终的成品 GIF 图给大家看一下效果：</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/dddd.gif" alt="dddd"></p>
<p>如果你有什么问题欢迎来找我玩，一起交流。</p>
]]></content></item><item><title>谈谈最常见的 HTTP</title><link>https://kcode.icu/posts/http/</link><pubDate>Fri, 15 Jan 2021 23:10:22 +0000</pubDate><guid>https://kcode.icu/posts/http/</guid><description>标题的”最常见“我想应该没有什么争议，对大多数人来说日常生活中接触到最多的应用层协议就是 HTTP了，从聊天软件、浏览器页面再到各种游戏实现，它们无处不在。这篇文章我就带你来看一看这个处于 OSI 标准最上层、最常用也是最普通的 HTTP 它究竟有什么“东西”，一起作为一个不只是听说过的“大神”。
这篇博客我想阐述除书本概念之外的一些可能你 理解不深刻 的问题的 个人理解，希望对你有所帮助。
HTTP是什么 超文本传输协议（Hypertext Transfer Protocol，HTTP），是一个应用层面上的，也就是软件双方通信的数据规则，是通信的基石。不然你发给我一串 @#$%$%^$%^，只有你能看懂，我怎么知道你说的是什么玩意？双方按照这个规则去通信，有什么需求都在这个规范里写好了发给对方，对方就知道你想干什么，就可以也按照这个规范给你回过去，就是这么简单。只是因为随着技术的发展，所遇到的问题越来越多，从功能需求，再到安全、效率、可读性等等，不得不提出一系列的解决方案去完善，最终变得很 ”臃肿“ 罢了。但是你应该明白，这就是一个为应用程序通信所提出来的一个基础通信协议。
HTTP方法有什么“实际区别” 你可能听说过类似 “GET 和 POST 有什么区别” 这种问题，其实说到底从底层上来说，它们之间 没有任何区别，仅仅是约定、规范。 也就是说 按照约定，GET 方法的请求 不应该 携带请求体，并且在以前 Postman 这类客户端模拟软件也是不允许构造这类请求的，但是后来也是支持了。
但是，如果你强行带了请求体，是没有任何问题的。你甚至可以把 GET 方法携带上请求体用来登录，使用 POST 请求用来获取 HTML 等静态资源，用 DELETE 方法来为数据库增加一条记录，只要你后端程序员老哥不把你捶死（手动狗头） 🤣🤣🤣
各个版本之间的发展史 HTTP 比较重要的几个发展时间节点是 0.9、1.0、1.1、2.0 和 3.0，每一次的版本变迁都是为了解决前一个版本的性能不足或者功能不完善，我不推荐死记硬背，即使它被称为计算机八股文。
http 0.9和1.1 在 HTTP 0.9 的时候只有 GET 方法，1.0 补充了 POST，DEL 方法完善语义，还添加了几个首部，这个阶段的 HTTP 主要就是完善功能。
1.0 和 1.1 的最大区别就是长短连接了。在 HTTP 1.1 将长连接设置为了默认，也就是：
Connection: keep-alive 在这之前这个字段的默认是 close，长连接的好处是显而易见的，由于 HTTP 是基于 tcp，如果总共传输三个文件，1.</description><content type="html"><![CDATA[<p>标题的”最常见“我想应该没有什么争议，对大多数人来说日常生活中接触到最多的应用层协议就是 HTTP了，从聊天软件、浏览器页面再到各种游戏实现，它们无处不在。这篇文章我就带你来看一看这个处于 OSI 标准最上层、最常用也是最普通的 HTTP 它究竟有什么“东西”，一起作为一个不只是听说过的“大神”。</p>
<p>这篇博客我想阐述除书本概念之外的一些可能你 <strong>理解不深刻</strong> 的问题的 <strong>个人理解</strong>，希望对你有所帮助。</p>
<h2 id="http是什么">HTTP是什么</h2>
<p>超文本传输协议（Hypertext Transfer Protocol，HTTP），是一个应用层面上的，也就是软件双方通信的数据规则，是通信的基石。不然你发给我一串 @#$%$%^$%^，只有你能看懂，我怎么知道你说的是什么玩意？双方按照这个规则去通信，有什么需求都在这个规范里写好了发给对方，对方就知道你想干什么，就可以也按照这个规范给你回过去，就是这么简单。只是因为随着技术的发展，所遇到的问题越来越多，从功能需求，再到安全、效率、可读性等等，不得不提出一系列的解决方案去完善，最终变得很 ”臃肿“ 罢了。但是你应该明白，这就是一个为应用程序通信所提出来的一个基础通信协议。</p>
<h2 id="http方法有什么实际区别">HTTP方法有什么“实际区别”</h2>
<p>你可能听说过类似 “GET 和 POST 有什么区别” 这种问题，其实说到底从底层上来说，它们之间 <strong>没有任何区别，仅仅是约定、规范。</strong> 也就是说 <strong>按照约定</strong>，GET 方法的请求 <strong>不应该</strong> 携带请求体，并且在以前 <a href="https://www.postman.com/">Postman</a> 这类客户端模拟软件也是不允许构造这类请求的，但是后来也是支持了。</p>
<p>但是，如果你强行带了请求体，是没有任何问题的。你甚至可以把 GET 方法携带上请求体用来登录，使用 POST 请求用来获取 HTML 等静态资源，用 DELETE 方法来为数据库增加一条记录，只要你后端程序员老哥不把你捶死（手动狗头） 🤣🤣🤣</p>
<h2 id="各个版本之间的发展史">各个版本之间的发展史</h2>
<p>HTTP 比较重要的几个发展时间节点是 0.9、1.0、1.1、2.0 和 3.0，每一次的版本变迁都是为了解决前一个版本的性能不足或者功能不完善，我不推荐死记硬背，即使它被称为计算机八股文。</p>
<h3 id="http-09和11">http 0.9和1.1</h3>
<p>在 HTTP 0.9 的时候只有 GET 方法，1.0 补充了 POST，DEL 方法完善语义，还添加了几个首部，这个阶段的 HTTP 主要就是完善功能。</p>
<p>1.0 和 1.1 的最大区别就是长短连接了。在 HTTP 1.1 将长连接设置为了默认，也就是：</p>
<pre><code>Connection: keep-alive
</code></pre><p>在这之前这个字段的默认是 <code>close</code>，长连接的好处是显而易见的，由于 HTTP 是基于 tcp，如果总共传输三个文件，1.0 的时候需要建立和断开三次连接，1.1 的时候就只需要一次了。但是现在的问题还很明显，客户端想拿这三个文件，还是要三次请求，显然不合理。而且如果你打开开发者工具查看过 HTTP 的报文不难发现，即使你就需要几十个字节的 json 返回数据，服务端也要给你回那么长的 HTTP 报文，冗余信息的大小都超过了你的需要信息大小，这显然也不河里。所以这些问题就在 HTTP 2.0 版本里解决了。</p>
<h3 id="http-2">http 2</h3>
<p>HTTP 2.0 主要有这些特色：</p>
<ul>
<li>协议协商机制，可以选择使用 HTTP/1.1 还是 HTTP/2 或者其他。</li>
<li>高度向下兼容，原来 HTTP/1.1 的方法，状态码，URI和首部都不用改变。</li>
<li>首部压缩，通过双方都保存一份静态和动态表，通过发送双方都知道的 Index 来表明使用的是哪个首部字段。</li>
<li>服务端推送，解决只能客户端请求，无法服务端主动返回的问题。</li>
<li>二进制分帧，请求的流水线形式等等。</li>
</ul>
<h4 id="多路复用">多路复用</h4>
<p>如果你想请求 100 个文件，在之前你可能想要建立 100 个 TCP 连接同时请求，但是实际上浏览器会限制数量为 2~6 个，总之还是需要至少 2 个 TCP 连接。但是 HTTP/2 可以复用一个连接，这就减少了建立连接所需的时间。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/multiplexing.png" alt="multiplexing"></p>
<h4 id="首部压缩">首部压缩</h4>
<h3 id="在线体验">在线体验</h3>
<h4 id="demo1">demo1</h4>
<p>看到这里，你应该对 HTTP 2 的优势有了一个理性的认知了，你可以点一下这个 <a href="https://http2.akamai.com/demo">在线链接</a> 来<strong>直观地感受</strong>它们的速度差异。</p>
<h4 id="demo2">demo2</h4>
<h2 id="小结">小结</h2>
]]></content></item><item><title>一些常见 Go 语言及面试问题的整理</title><link>https://kcode.icu/posts/interview/somequestions/</link><pubDate>Fri, 15 Jan 2021 21:10:55 +0000</pubDate><guid>https://kcode.icu/posts/interview/somequestions/</guid><description>这篇博客记录一些关于面试常见的 Go 语言方面的问题，希望能帮到大家。
待完成
Go make和new的区别，使用和底层？ 两者都可以声明变量，例如 map，channelchannel，slice，以及结构体等等，我们常用make来初始化map，channel，而常用new 来初始化普通类型变量和结构体。
区别是make会分配底层所需的空间，而new只会分配该结构头部的空间。如果首部中并没有引用其他内存地址，那么new 和make是一样。
举个例子，当我们声明 map 时，实际上说获得了一个 hmap 类型的指针，指向 hmap结构体：
如果我们使用make（map[type]type, 10），就会为map底层所使用的空间分配足够使用的bucket，如果使用new，则只分配hmap结构体所需内存，并不会分配底层所使用的空间，使用map也就无从谈起了。常见的一个错误示范就是通过 var m map[int]int 声明，然后直接 m[1]=1 来使用，这样就会直接因为空指针引用而panic！
Go内存管理 goroutine 什么时候会阻塞？ goroutine有几种状态？ m操作g的时候有自旋与非自旋状态？
线程有哪些状态 注册中心挂了怎么办？ N节点，raft一致性？
反射底层原理？ 通过反射执行函数，拿结构体tag？ 锁机制？饥饿模式正常模式？锁底层原理？ channel使用，坑，底层原理？</description><content type="html"><![CDATA[<p>这篇博客记录一些关于面试常见的 Go 语言方面的问题，希望能帮到大家。</p>
<blockquote>
<p>待完成</p>
</blockquote>
<h2 id="go-make和new的区别使用和底层">Go make和new的区别，使用和底层？</h2>
<p>两者都可以声明变量，例如 map，channelchannel，slice，以及结构体等等，我们常用make来初始化map，channel，而常用new 来初始化普通类型变量和结构体。</p>
<p>区别是make会分配底层所需的空间，而new只会分配该结构头部的空间。如果首部中并没有引用其他内存地址，那么new 和make是一样。</p>
<p>举个例子，当我们声明 map 时，实际上说获得了一个 hmap 类型的指针，指向 hmap结构体：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">

</code></pre></div><p>如果我们使用make（map[type]type, 10），就会为map底层所使用的空间分配足够使用的bucket，如果使用new，则只分配hmap结构体所需内存，并不会分配底层所使用的空间，使用map也就无从谈起了。常见的一个错误示范就是通过 <code>var m map[int]int</code> 声明，然后直接 <code>m[1]=1</code> 来使用，这样就会直接因为空指针引用而panic！</p>
<h2 id="go内存管理">Go内存管理</h2>
<h2 id="goroutine-什么时候会阻塞">goroutine 什么时候会阻塞？</h2>
<h2 id="goroutine有几种状态">goroutine有几种状态？</h2>
<p>m操作g的时候有自旋与非自旋状态？</p>
<h2 id="线程有哪些状态">线程有哪些状态</h2>
<h2 id="注册中心挂了怎么办">注册中心挂了怎么办？</h2>
<p>N节点，raft一致性？</p>
<h2 id="反射底层原理">反射底层原理？</h2>
<h2 id="通过反射执行函数拿结构体tag">通过反射执行函数，拿结构体tag？</h2>
<h2 id="锁机制饥饿模式正常模式锁底层原理">锁机制？饥饿模式正常模式？锁底层原理？</h2>
<h2 id="channel使用坑底层原理">channel使用，坑，底层原理？</h2>
]]></content></item><item><title>几经周折的博客变迁史</title><link>https://kcode.icu/posts/chore/blog_journey/</link><pubDate>Wed, 06 Jan 2021 21:13:13 +0000</pubDate><guid>https://kcode.icu/posts/chore/blog_journey/</guid><description>仔细想起来我的博客旅程也有好多年了，兜兜转转地走了不少弯路，也确实在这个过程中学到了很多东西，大致有这些时间节点：
尝试购买了国内域名和学生机服务器，看到自己写的内容能在公网上让全世界的人看到就高兴了好久，内容很随意，自己管理。 使用 hexo 框架系统化内容，并部署到 GitHub Page 上交给 GitHub 管理。 发现了国内访问速度更快的 Gitee Page。 再次购买域名，使用 CDN 加速国外空间，未果（下文说）&amp;hellip;&amp;hellip; 前前后后也折腾了好几年，技术上的提升我倒觉得不太大，因为折腾地挺多但是都是应用层面上的，对我来说更多的是动手能力的提高，有好多东西不经过自己亲手尝试是根本理解不了的，我前面很多东西就是别人远程或者一步一步告诉我让我去点这个点那个就可以了，但是回过头来问你，你根本不知道发生了什么，甚至隔天就忘，这是典型的不理解、死记硬背式学习方法。
当时配置那个 A 记录，CNAME 记录啥的根本不知道是什么东西，也不知道 DNS 是什么，就是配，成功了就行，不成功就猜，一个个试呗。现在想想，真的是走了不少弯路，如果能系统地学一下多好。不过这些问题也都在我后来的实践以及学习过程中逐一解决了，现在遇到问题也不用像没头苍蝇一样乱撞了，这种感觉很不错 :)
这件事也让我大致理解了一句老话，大致是这么说的：真正厉害的技术人员不是说他写程序一定要多么多么厉害，而是他有非常强悍的问题定位能力（trouble shooting），能解决别人解决不了的问题，而这一切都源自于无数经验的积累以及深度的思考。
下面说我的最后一次迁移：)
之所以有两个部分是因为买了域名后才发现必须要国内域名并且备案，才能加速国内。我买的是国外域名所以没办法，最后就用 GitHub Page + 自定义域名了。
GitHub Page+自定义域名 这种方案比较简单（因为GitHub 都帮我们做了），这也是我现在的方式，只不过我的域名是国外的，所以没办法使用 CDN 加速。
你首先需要创建一个名为 &amp;lt;YourGitHubName&amp;gt;.github.io 的仓库，比如 sh1luo.github.io，然后购买一个域名（国内国外都行，国内要备案），因为我们是要使用 GitHub 的自定义域名，所以需要使用 CNAME 记录，在域名服务器处添加两条CNAME 记录 ，就像这样
我是国外的域名，不能使用国内 CDN 加速，正好 CloudFlare 提供免费全球 CDN，虽然效果一般，但是它提供的免费功能也是非常的多，包括各种流量统计分析，也是很良心了。想使用 CloudFlare 当 DNS 服务器做法也非常简单。注册一个账号填上域名信息，然后会提供给我们两个 DNS 服务器域名，我们把原域名服务器商的 NameServers 改成新解析服务器提供的就好了。
当然，如果你本来就是国内域名，就不用这么麻烦了，直接添加两条 CNAME 记录，然后在 GitHub Pages 仓库的发布分支放一个 CNAME 文件，文件内容就是你的 CNAME 地址就可以了，它会自动帮你设置为这个域名并搞定一切的:)</description><content type="html"><![CDATA[<p>仔细想起来我的博客旅程也有好多年了，兜兜转转地走了不少弯路，也确实在这个过程中学到了很多东西，大致有这些时间节点：</p>
<ul>
<li>尝试购买了国内域名和学生机服务器，看到自己写的内容能在公网上让全世界的人看到就高兴了好久，内容很随意，自己管理。</li>
<li>使用 hexo 框架系统化内容，并部署到 GitHub Page 上交给 GitHub 管理。</li>
<li>发现了国内访问速度更快的 Gitee Page。</li>
<li>再次购买域名，使用 CDN 加速国外空间，未果（下文说）&hellip;&hellip;</li>
</ul>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/image-20210118174633253.png" alt="现在的博客"></p>
<p>前前后后也折腾了好几年，技术上的提升我倒觉得不太大，因为折腾地挺多但是都是应用层面上的，对我来说更多的是动手能力的提高，有好多东西不经过自己亲手尝试是根本理解不了的，我前面很多东西就是别人远程或者一步一步告诉我让我去点这个点那个就可以了，但是回过头来问你，你根本不知道发生了什么，甚至隔天就忘，这是典型的不理解、死记硬背式学习方法。</p>
<p>当时配置那个 A 记录，CNAME 记录啥的根本不知道是什么东西，也不知道 DNS 是什么，就是配，成功了就行，不成功就猜，一个个试呗。现在想想，真的是走了不少弯路，如果能系统地学一下多好。不过这些问题也都在我后来的实践以及学习过程中逐一解决了，现在遇到问题也不用像没头苍蝇一样乱撞了，这种感觉很不错 :)</p>
<p>这件事也让我大致理解了一句老话，大致是这么说的：真正厉害的技术人员不是说他写程序一定要多么多么厉害，而是他有非常强悍的问题定位能力（trouble shooting），能解决别人解决不了的问题，而这一切都源自于无数经验的积累以及深度的思考。</p>
<p>下面说我的最后一次迁移：)</p>
<blockquote>
<p>之所以有两个部分是因为买了域名后才发现必须要国内域名并且备案，才能加速国内。我买的是国外域名所以没办法，最后就用 GitHub Page + 自定义域名了。</p>
</blockquote>
<h2 id="github-page自定义域名">GitHub Page+自定义域名</h2>
<p>这种方案比较简单（因为GitHub 都帮我们做了），这也是我现在的方式，只不过我的域名是国外的，所以没办法使用 CDN 加速。</p>
<p>你首先需要创建一个名为 <code>&lt;YourGitHubName&gt;.github.io</code> 的仓库，比如 <code>sh1luo.github.io</code>，然后购买一个域名（国内国外都行，国内要备案），因为我们是要使用 GitHub 的自定义域名，所以需要使用 <a href="https://baike.baidu.com/item/CNAME/9845877?fr=aladdin">CNAME</a> 记录，在域名服务器处添加两条CNAME 记录 ，就像这样</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/image-20210126230446099.png" alt="DNS记录"></p>
<p>我是国外的域名，不能使用国内 CDN 加速，正好 CloudFlare 提供免费全球 CDN，虽然效果一般，但是它提供的免费功能也是非常的多，包括各种流量统计分析，也是很良心了。想使用 CloudFlare 当 DNS 服务器做法也非常简单。注册一个账号填上域名信息，然后会提供给我们两个 DNS 服务器域名，我们把原域名服务器商的 NameServers 改成新解析服务器提供的就好了。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/image-20210126231932450.png" alt=""></p>
<p>当然，如果你本来就是国内域名，就不用这么麻烦了，直接添加两条 CNAME 记录，然后在 GitHub Pages 仓库的发布分支放一个 CNAME 文件，文件内容就是你的 CNAME 地址就可以了，它会自动帮你设置为这个域名并搞定一切的:)</p>
<p>最终应该是这样：</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/image-20210126232019604.png" alt=""></p>
<h2 id="cdn加速">CDN加速</h2>
<p>如果你是国内的域名但是是国外的空间，就可以使用 CDN 加速了，加速区域选国内。这里需要注意源站地址由于是 GitHub Pages ，而 GitHub Pages 有 4 个 IP。都写上一行一个，回源 HOST 写你自己地址就可以了。这个回源 HOST 实际上就是 HTTP 头里的 host 字段，如果同一台机器上有多个服务的话，用来标识是哪一个服务，比较常见就是一个 IP 地址上配置了多个域名，就是通过这种给 host 首部字段的方式区分的不同 Web 站点。</p>
<p>配置完源站信息后，会生成一个 CDN 域名，比如我的是 <code>kcode.icu.cdn.dnsv1.com</code> ，然后再添加一条 CNAME 记录指向这个域名就搞定。这样配置过，你的网站经过缓存后国内访问速度能达到非常恐怖的速度，可以试着 ping 一下哦。</p>
<p>不过我这里是尝试了一下，发现国内都是不支持加速国外域名，所以放弃了。</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/image-20210118184423991.png" alt=""></p>
<h2 id="自动化构建">自动化构建</h2>
<p>自动化构建意思是说你只需要完成博客内容部分，其他生成静态页面，打包，发布部署等功能都交给一套脚本去完成。这里介绍我曾经体验过的几种。</p>
<h3 id="github-actions">Github Actions</h3>
<p>这是 Github 提供的功能较为全面的自动化部署解决方案，使用方法有两种，一是在 <code>.git</code> 文件的同级目录下创建一个 <code>.github/workflow</code> 目录，然后新建 <code>gh-pages.yaml</code> 文件，另一个是在 Web端登录进入你 <code>yourname.github.io</code> 仓库， <code>Code</code> 栏右侧的 <code>Action</code> ，点进去图形化创建并编辑文件即可，这里展示我的 action 脚本：</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Deploy Hugo</span><span class="w">
</span><span class="w"></span><span class="nt">on</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">push</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">branches</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">master</span><span class="w">
</span><span class="w"></span><span class="nt">jobs</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">build-deploy</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">runs-on</span><span class="p">:</span><span class="w"> </span><span class="l">ubuntu-18.04</span><span class="w">
</span><span class="w">    </span><span class="nt">steps</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l">actions/checkout@v2</span><span class="w">
</span><span class="w">        </span><span class="nt">with</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="nt">submodules</span><span class="p">:</span><span class="w"> </span><span class="l">recursive</span><span class="w"> </span><span class="c"># Fetch Hugo themes (true OR recursive)</span><span class="w">
</span><span class="w">          </span><span class="nt">fetch-depth</span><span class="p">:</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="c"># Fetch all history for .GitInfo and .Lastmod</span><span class="w">
</span><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Setup Hugo</span><span class="w">
</span><span class="w">        </span><span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l">peaceiris/actions-hugo@v2</span><span class="w">
</span><span class="w">        </span><span class="nt">with</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="nt">hugo-version</span><span class="p">:</span><span class="w"> </span><span class="l">latest</span><span class="w">
</span><span class="w">          </span><span class="nt">extended</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Build</span><span class="w">
</span><span class="w">        </span><span class="nt">run</span><span class="p">:</span><span class="w"> </span><span class="l">hugo &amp;&amp; echo www.kcode.icu &gt; ./public/CNAME</span><span class="w">
</span><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Deploy</span><span class="w">
</span><span class="w">        </span><span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l">peaceiris/actions-gh-pages@v3</span><span class="w">
</span><span class="w">        </span><span class="nt">with</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="nt">personal_token</span><span class="p">:</span><span class="w"> </span><span class="l">${{ secrets.personal_token }}</span><span class="w"> </span><span class="c"># personal_token 这里新建一个 https://github.com/settings/tokens</span><span class="w">
</span><span class="w">          </span><span class="nt">PUBLISH_BRANCH</span><span class="p">:</span><span class="w"> </span><span class="l">gh-pages</span><span class="w"> </span><span class="c"># 推送到当前 gh-pages 分支</span><span class="w">
</span><span class="w">          </span><span class="nt">PUBLISH_DIR</span><span class="p">:</span><span class="w"> </span><span class="l">./public</span><span class="w"> </span><span class="c"># hugo 生成到 public 作为跟目录</span><span class="w">
</span><span class="w">          </span><span class="nt">commit_message</span><span class="p">:</span><span class="w"> </span><span class="l">${{ github.event.head_commit.message }}</span><span class="w">
</span></code></pre></div><p>也比较好理解，就是执行 <code>hugo</code> 命令然后创建一个 CNAME 文件用于自动设置一个自定义域名，然后推到 <code>gh-pages</code> 分支。</p>
<p>这种方案的优点是自定义程度高，缺点相对就是需要自己全权控制写一个控制脚本，有一定学习成本。</p>
<p>这是我的自动化构建执行结果：</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/image-20210331160251498.png" alt="image-20210331160251498"></p>
<h3 id="gitee-page">Gitee Page</h3>
<p>Gitee 提供了常见的几个博客框架的自动化部署功能，Hugo，Hexo 和 Jekyll。也就是说，只要你根目录下有对应框架的 <code>yaml</code> 配置文件，在你每次将最新内容推至仓库时就会自动执行自动化构建，并把最新页面推到前端页面上，比较省心。</p>
<p>优点是国内速度比 Github 快，毕竟服务器近，缺点是每次推完还要手动点更新，自动的一年 99RMB。</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/image-20210331155953211.png" alt="image-20210331155953211"></p>
<h2 id="画图工具">画图工具</h2>
<p>这里主要介绍我使用的两个画图软件。</p>
<blockquote>
<p>2021-06-19 16:44:13 更新</p>
</blockquote>
<h3 id="diagram">Diagram</h3>
<p>原来这个软件叫 draw.io，后来改名为 <a href="https://www.diagrams.net/">Diagram</a>。</p>
<p>我之前一直使用这个工具画图，优点是免费，功能丰富，暂无发现缺点 😂 推荐给要求较高的同学使用，画彩色图，花里胡哨图。</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/image-20210619170357266.png" alt="image-20210619170357266"></p>
<h3 id="ascii">Ascii</h3>
<p>Ascii 图是我看 <a href="https://xargin.com/diagram-tools-intro/">曹大博客</a> 了解到的，可以说是一见面就夺走了我的所有抵抗力，我曾经还觉得在画编程方面的图这一块，Diagram 完全够用了，就好比 “任何比 C语言复杂的语言都能用 C语言实现” 😎</p>
<p>但是当我看到这种风格的图我再也不想用其他工具了，因为它完全够用了（装逼完美</p>
<p>毕竟曹大在讲 plan9 汇编时说过，学习的最大动力就是装逼，不服可以去线下面基他 😄，这种风格的图真的 geek 风拉满，“程序员味”十足。</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/image-20210619170049500.png" alt="image-20210619170049500"></p>
<p>说点正经的，我喜欢这种图最大的优点是 <strong>简洁</strong>，无他。我不用操心颜色搭配，字体大小，迁移存储等一切问题，只专心图所能表达出的含义就 OK 了。这里推荐两个站点：</p>
<ul>
<li>asciiflow（<a href="https://asciiflow.com/">https://asciiflow.com/</a>）</li>
<li>Textik（<a href="https://textik.com/">https://textik.com/</a>）</li>
</ul>
<h3 id="sketch">Sketch</h3>
<p>这个软件是比较专业的设计师使用的，也可以用来画一般的文章插图，缺点是收费，只能在 Mac 下使用。我没有使用过，可以自行搜索。</p>
<h2 id="说在最后">说在最后</h2>
<p>这里说几点我个人看法。</p>
<ul>
<li>博客要<strong>注重内容</strong>，我看好多人把界面弄的 <strong>过于花哨</strong> 不注重实际内容，我觉得如果你内容很丰富的情况下可以适当美化，但是弄个 BGM 或者动态换图什么的还是不要了。</li>
<li>多踩坑不一定是坏事，在大学这个试错成本很低的环境里就要多尝试，在踩坑的过程中把基础打牢，锻炼问题定位能力，多思考，多总结，日积月累肯定有所提升。</li>
<li>写博客给别人看的同时要多去看别人的成果，尤其是大佬们的，进步很快。</li>
<li>最后一点也是最重要的，不要主要依靠别人的博客学习，大部分博客不系统，甚至有的博主不理解就生搬硬套，很容易给新人带来误解。努力学习一手资料，官方文档、书籍都是不错的选择，其次才是较为系统阐述的博客、零散的博客。</li>
</ul>
]]></content></item><item><title>记人生中前几次面试及思考</title><link>https://kcode.icu/posts/interview/2020-12-interview/</link><pubDate>Sun, 03 Jan 2021 21:18:13 +0000</pubDate><guid>https://kcode.icu/posts/interview/2020-12-interview/</guid><description>写作背景 由于早早有了就业的想法，于是我在大三上学期快要结束的时候便早早地”物色“各大公司的实习了，也是希望能在就业前增加段实习经历，丰富一下经验。这也是人生中我的第一次面试，感触颇多。特别记录下来自己的总结以及对于假期自己的学习规划。
面试总结 这次我面试的总共有三家公司，跟谁学、字节跳动和腾讯，对我印象最深也是帮助最大的就是”字节跳动“。关于面试的准备大致有三块，简历、技术口述和手撕代码，下面分开说。
简历 这里使用的简历风格是参考了 @帅地玩编程 和 @码农桃花源 两位大佬，一个是本科腾讯大学时期年入几十万的，第二个是 Go 圈的全成大佬，推荐大家关注。
总体是简约并且色调一致，简历也是需要一点点迭代的，不断完善用词，前面挂了也是没有办法的事情。这里需要确保这么几点：
不要造假，实事求是 。如果你写熟悉甚至精通，你躲过了 HR，但是人家面试官上来问了一个很简单的问题你答不上来，人家可能没兴趣继续问了。。在面试官心里你的这项技术等于没写，并且有了吹牛的成分，众所周知，搞技术的都不喜欢这种人。 拿出有说服力的证据。 举个简单的例子，你在个人相关那栏里写英语能力强，学习能力不错，热爱并常学习新技术，人家让你现场看个英文技术文，或者跟你聊两句看法，你蒙蔽了，尴尬不。问你平时咋学习的，你磕磕巴巴说不出个所以然，或者一点逻辑没有，东一头看书，西一头看视频，再来一手看野生技术文章，你说尴尬不。 注意行业基础。 我拿技术来说，搞技术的，你说你写了个热爱技术，结果写个 GitHub ，都能拼错，写成 Github 等等，写个 CSDN 写成 Csdn ，虽说这不是什么大事，但是这些书面东西，我们搞技术的不能犯错的，这给人的印象就是你很不专业，或者说你接触的很少以至于记不清楚。假如说你说热爱开源，整天 GitHub 排行榜逛个遍，你告诉我你不知道 GitHub 怎么拼，不合适吧？我曾经见过一个人说他懂这懂那，结果拿来简历一看，关于技术的名字错了好几个，还说自己热爱这些。 技术口述 这部分是面试重头戏，除去手撕代码部分其余就是这个了（还可能有项目环节），对于这部分我感触最多。
感触最大的就是一定要有自己的理解，并有深度。什么叫有自己的理解，就是如果换个方式问你，或者从另一个问题引申过来你能不能想到。有经验的面试官很喜欢这样问，如果你对知识没有形成体系，很容易造成一问就脑子一片空白的情况。
有深度指的是要能从使用到原理再到理解讲出一系列成体系的知识点，不是仅仅说一点应用层面的东西。我觉得这点我们平时很容易忽视，常常说个 10 秒就没了，谈不上熟悉。
手撕 这个环节部分大厂面试其实做的不错的，如果你上来没思路没见过，他会引导你让你一步一步去解决，看你思维和反应能力，要平时多思考，不能无脑刷，没啥说的。
假期规划 早些面试还是有好处的，确实能认识到自己的不足，我总结有这些点：
自我介绍说重点，这会作为后续提问参考。 项目要有难点，解决方法，思考。 知识理解要有深度。 每一条都是实战出来的教训。。你可以比对自己成长，希望对你有所帮助。</description><content type="html"><![CDATA[<h2 id="写作背景">写作背景</h2>
<p>由于早早有了就业的想法，于是我在大三上学期快要结束的时候便早早地”物色“各大公司的实习了，也是希望能在就业前增加段实习经历，丰富一下经验。这也是人生中我的第一次面试，感触颇多。特别记录下来自己的总结以及对于假期自己的学习规划。</p>
<h2 id="面试总结">面试总结</h2>
<p>这次我面试的总共有三家公司，跟谁学、字节跳动和腾讯，对我印象最深也是帮助最大的就是”字节跳动“。关于面试的准备大致有三块，简历、技术口述和手撕代码，下面分开说。</p>
<h3 id="简历">简历</h3>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/image-20210103221551405.png" alt=""></p>
<p>这里使用的简历风格是参考了 @帅地玩编程 和 @码农桃花源 两位大佬，一个是本科腾讯大学时期年入几十万的，第二个是 Go 圈的全成大佬，推荐大家关注。</p>
<p>总体是简约并且色调一致，简历也是需要一点点迭代的，不断完善用词，前面挂了也是没有办法的事情。这里需要确保这么几点：</p>
<ul>
<li><strong>不要造假，实事求是</strong> 。如果你写熟悉甚至精通，你躲过了 HR，但是人家面试官上来问了一个很简单的问题你答不上来，人家可能没兴趣继续问了。。在面试官心里你的这项技术等于没写，并且有了吹牛的成分，众所周知，搞技术的都不喜欢这种人。</li>
<li><strong>拿出有说服力的证据。</strong> 举个简单的例子，你在个人相关那栏里写英语能力强，学习能力不错，热爱并常学习新技术，人家让你现场看个英文技术文，或者跟你聊两句看法，你蒙蔽了，尴尬不。问你平时咋学习的，你磕磕巴巴说不出个所以然，或者一点逻辑没有，东一头看书，西一头看视频，再来一手看野生技术文章，你说尴尬不。</li>
<li><strong>注意行业基础。</strong> 我拿技术来说，搞技术的，你说你写了个热爱技术，结果写个 <code>GitHub</code> ，都能拼错，写成 <code>Github</code> 等等，写个 <code>CSDN</code> 写成 <code>Csdn</code> ，虽说这不是什么大事，但是这些书面东西，我们搞技术的不能犯错的，这给人的印象就是你很不专业，或者说你<strong>接触的很少以至于记不清楚</strong>。假如说你说热爱开源，整天 <code>GitHub</code> 排行榜逛个遍，你告诉我你不知道 <code>GitHub</code> 怎么拼，不合适吧？我曾经见过一个人说他懂这懂那，结果拿来简历一看，关于技术的名字错了好几个，还说自己热爱这些。</li>
</ul>
<h3 id="技术口述">技术口述</h3>
<p>这部分是面试重头戏，除去手撕代码部分其余就是这个了（还可能有项目环节），对于这部分我感触最多。</p>
<p>感触最大的就是一定要<strong>有自己的理解</strong>，并有深度。什么叫有自己的理解，就是如果换个方式问你，或者从另一个问题引申过来你能不能想到。有经验的面试官很喜欢这样问，如果你对知识没有形成体系，很容易造成一问就脑子一片空白的情况。</p>
<p>有深度指的是要能从使用到原理再到理解讲出一系列成体系的知识点，不是仅仅说一点应用层面的东西。我觉得这点我们平时很容易忽视，常常说个 10 秒就没了，谈不上熟悉。</p>
<h3 id="手撕">手撕</h3>
<p>这个环节部分大厂面试其实做的不错的，如果你上来没思路没见过，他会引导你让你一步一步去解决，看你思维和反应能力，要平时多思考，不能无脑刷，没啥说的。</p>
<h2 id="假期规划">假期规划</h2>
<p>早些面试还是有好处的，确实能认识到自己的不足，我总结有这些点：</p>
<ul>
<li>自我介绍说重点，这会作为后续提问参考。</li>
<li>项目要有难点，解决方法，思考。</li>
<li><strong>知识理解要有深度</strong>。</li>
</ul>
<p>每一条都是实战出来的教训。。你可以比对自己成长，希望对你有所帮助。</p>
]]></content></item><item><title>手写一个RPCg（上）</title><link>https://kcode.icu/posts/rpc/rpcg/</link><pubDate>Sat, 28 Nov 2020 15:45:13 +0000</pubDate><guid>https://kcode.icu/posts/rpc/rpcg/</guid><description>须知 可能看到这里的一部分人还不知道什么是 RPC，也不知道为什么要用 RPC，内心：HTTP不香吗？那么你需要首先看一下这篇文章：
你觉得HTTP哪都好用是因为你不知道RPC
已经实现的 这篇文章我会带你手写一个简易版本的 RPC 框架，这个框架会支持如下这些功能：
多种网络传输方式 服务端自动注册可导出服务 可以心跳保活的注册中心 服务注册与服务发现 多种序列化方式 超时控制 一些负载均衡策略，一致性哈希、平滑带权轮询等 未来需要做的 自定义的代码生成插件
一种压缩方式
基于服务器时延的负载均衡策略？
心里有数 ”切忌重复造轮子“这句话你应该听过，不过这个”框架“的目的是带领我们大致了解 RPC 框架的工作过程，目标并不是工业级应用，我想你也一定清楚用框架和自己写框架对框架的理解程度有什么区别。也不必把 RPC 想成多么”高端“的技术，RPC 也只是一个调用，微服务的一个组件，从小的地方出发更容易让人接受罢了。好了，话不多说，让我们正式开始。
俯瞰RPCg 这个图向我们展示了最基本的 RPC 调用关系：服务端将自己的服务注册到注册中心，客户端从注册中心获取所有服务端的所有信息，在拿到这些信息之后带着自己的请求去访问某个服务端的服务。你可能会问为什么要多个”第三者“注册中心出来呢，我直接就只有客户端和服务端多方便，那你需要思考以下问题：
直接通信是不是需要将通信的地址等服务端信息硬编码到客户端的代码中？如果服务端节点数改变了怎么办，难道手动删改代码？ 客户端怎么知道服务端可不可用？难道需要服务端开个服务专门去处理这类信息吗？这属于服务端的业务吗？ &amp;hellip;&amp;hellip; 我想你应该大致能明白为什么需要这个注册中心了，就是屏蔽对方对己方的感知，通过一个第三方中介来提供/提出自己的服务/需求，这就够了，你可以类比 房产中介，婚介所等等机构，当然，注册中心还有很多功能，我们这里为了学习，就只提供这部分功能了，更多的需要留给你去探索 :)
我们再想想，我们现在有了三个主体，之前有不同的需求，怎么提供通信。业界有非常多的解决方法，比如 gRPC 的 HTTP/2.0，它的优势也是显而易见的：多路复用，pipelining 的通信方式，效率大幅提高，不必在等待对方的回复；首部压缩，这里我需要说明一下，RPC 调用大部分是服务端内部的互相调用，比如公司机房里 50 台机器之间相互调用，需要保证传输的效率，也就是说传送的数据要尽可能地小，这才有了 Protocol Buffers 的数据格式，所以经过压缩的首部数据量更小，效率更高。还有 tcp 连接，优势是简单等等。
等待更新&amp;hellip;&amp;hellip;.</description><content type="html"><![CDATA[<h1 id="须知">须知</h1>
<p>可能看到这里的一部分人还不知道什么是 RPC，也不知道为什么要用 RPC，内心：HTTP不香吗？那么你需要首先看一下这篇文章：</p>
<blockquote>
<p><a href="">你觉得HTTP哪都好用是因为你不知道RPC</a></p>
</blockquote>
<h2 id="已经实现的">已经实现的</h2>
<p>这篇文章我会带你手写一个简易版本的 RPC 框架，这个框架会支持如下这些功能：</p>
<ul>
<li>多种网络传输方式</li>
<li>服务端自动注册可导出服务</li>
<li>可以心跳保活的注册中心</li>
<li>服务注册与服务发现</li>
<li>多种序列化方式</li>
<li>超时控制</li>
<li>一些负载均衡策略，一致性哈希、平滑带权轮询等</li>
</ul>
<h2 id="未来需要做的">未来需要做的</h2>
<ul>
<li>
<p>自定义的代码生成插件</p>
</li>
<li>
<p>一种压缩方式</p>
</li>
<li>
<p>基于服务器时延的负载均衡策略？</p>
</li>
</ul>
<h2 id="心里有数">心里有数</h2>
<p>”切忌重复造轮子“这句话你应该听过，不过这个”框架“的目的是带领我们大致了解 RPC 框架的工作过程，目标并不是工业级应用，我想你也一定清楚用框架和自己写框架对框架的理解程度有什么区别。也不必把 RPC 想成多么”高端“的技术，RPC 也只是一个调用，微服务的一个组件，从小的地方出发更容易让人接受罢了。好了，话不多说，让我们正式开始。</p>
<h1 id="俯瞰rpcg">俯瞰RPCg</h1>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/2C28140D4115AF68D708DAB4515B012C.jpg" alt="img"></p>
<p>这个图向我们展示了最基本的 RPC 调用关系：服务端将自己的服务注册到注册中心，客户端从注册中心获取所有服务端的所有信息，在拿到这些信息之后带着自己的请求去访问某个服务端的服务。你可能会问为什么要多个”第三者“注册中心出来呢，我直接就只有客户端和服务端多方便，那你需要思考以下问题：</p>
<ul>
<li>直接通信是不是需要将通信的地址等服务端信息硬编码到客户端的代码中？如果服务端节点数改变了怎么办，难道手动删改代码？</li>
<li>客户端怎么知道服务端可不可用？难道需要服务端开个服务专门去处理这类信息吗？这属于服务端的业务吗？</li>
<li>&hellip;&hellip;</li>
</ul>
<p>我想你应该大致能明白为什么需要这个注册中心了，就是屏蔽对方对己方的感知，通过一个第三方中介来提供/提出自己的服务/需求，这就够了，你可以类比 房产中介，婚介所等等机构，当然，注册中心还有很多功能，我们这里为了学习，就只提供这部分功能了，更多的需要留给你去探索 :)</p>
<p>我们再想想，我们现在有了三个主体，之前有不同的需求，怎么提供通信。业界有非常多的解决方法，比如 gRPC 的 HTTP/2.0，它的优势也是显而易见的：多路复用，pipelining 的通信方式，效率大幅提高，不必在等待对方的回复；首部压缩，这里我需要说明一下，RPC 调用大部分是服务端内部的互相调用，比如公司机房里 50 台机器之间相互调用，需要保证传输的效率，也就是说传送的数据要尽可能地小，这才有了 Protocol Buffers 的数据格式，所以经过压缩的首部数据量更小，效率更高。还有 tcp 连接，优势是简单等等。</p>
<p>等待更新&hellip;&hellip;.</p>
]]></content></item><item><title>你觉得HTTP最香是因为你还不知道RPC</title><link>https://kcode.icu/posts/rpc/rpcvshttp/</link><pubDate>Tue, 10 Nov 2020 21:30:13 +0000</pubDate><guid>https://kcode.icu/posts/rpc/rpcvshttp/</guid><description>我在动手写 RPCg 这个”框架“之前看了大量的文章阐述 RPC 与 HTTP，这篇文章是比较不错的一篇，我翻译过来和你分享一下 :)
REST vs. RPC你要使用API去解决什么问题？ 有一则关于这个农民的笑话，他被问到”为什么他要尽量避免耕种出‘童话环’的形状“，他回答道，”因为如果我不那么做，我就会变成傻子“。（第一段的引用故事可暂时不关注）。
许多人关于他们自己构建的 APIs 会说同样的话，事实上，去思考一下你要用你的 APIs 去解决什么问题这非常重要，因为你所创建的 API 的风格和你所使用的技术都依赖于你上面的回答。
根据调用 自从 FORTRAN Ⅱ 在1958 年提出调用（也叫函数）这个概念，函数（调用）就一直是组织计算机代码的主要结构。所有现在主流被用来构建和使用 API 的编程语言例如 Java,Javascript, Python, Golang, C/C++ 和 PHP 都使用调用（也就是函数）来作为他们的主要组织结构。因此这数十年来”函数调用“以远程过程调用（RPC） 的形式称为设计和实现分布式 API 的主要模型也就不足为奇了。
如果你要问大多数软件开发者为什么要定义和构建 API，他们可能会解释说他们有个应用，它需要实现多个分布式组件，并且这些组件之间可以互相调用，来使整个应用程序正常运行。他们也可能说需要实现由多个应用程序使用的服务 API。</description><content type="html"><![CDATA[<p>我在动手写 RPCg 这个”框架“之前看了大量的文章阐述 RPC 与 HTTP，这篇文章是比较不错的一篇，我翻译过来和你分享一下 :)</p>
<h2 id="rest-vs-rpc你要使用api去解决什么问题">REST vs. RPC你要使用API去解决什么问题？</h2>
<p>有一则关于这个农民的笑话，他被问到”为什么他要尽量避免耕种出‘童话环’的形状“，他回答道，”因为如果我不那么做，我就会变成傻子“。（第一段的引用故事可暂时不关注）。</p>
<p>许多人关于他们自己构建的 APIs 会说同样的话，事实上，去思考一下你要用你的 APIs 去解决什么问题这非常重要，因为你所创建的 API 的风格和你所使用的技术都依赖于你上面的回答。</p>
<h2 id="根据调用">根据调用</h2>
<p>自从 FORTRAN Ⅱ 在1958 年提出调用（也叫函数）这个概念，函数（调用）就一直是组织计算机代码的主要结构。所有现在主流被用来构建和使用 API 的编程语言例如 Java,Javascript, Python, Golang, C/C++ 和 PHP 都使用调用（也就是函数）来作为他们的主要组织结构。因此这数十年来”函数调用“以远程过程调用（RPC） 的形式称为设计和实现分布式 API 的主要模型也就不足为奇了。</p>
<p>如果你要问大多数软件开发者为什么要定义和构建 API，他们可能会解释说他们有个应用，它需要实现多个分布式组件，并且这些组件之间可以互相调用，来使整个应用程序正常运行。他们也可能说需要实现由多个应用程序使用的服务 API。</p>
]]></content></item><item><title>Linux du/df命令总结</title><link>https://kcode.icu/posts/chore/linux_df_du/</link><pubDate>Wed, 04 Nov 2020 18:15:13 +0000</pubDate><guid>https://kcode.icu/posts/chore/linux_df_du/</guid><description>linux 在我们日常学习中用的非常多，连接远程 linux 服务器，使用各种 linux 命令，或者物理机就是 linux 系统或者 MacOS。如果你想要学习进阶知识，linux 已经是必不可少的一个组件了。这篇博客记录一下 linux 下常被混淆的 du/df 命令。
df df 就是 “disk free” 的缩写，一般是用来快速浏览你的文件系统，会显示所有磁盘的大小，使用空间，剩余空间，使用百分比还有磁盘挂载到哪个分区上了。使用的时候一般要带上 -h 参数来增加可读性。这些数据都是从挂载点或者文件系统级别计算出来的，比较 “宏观”。
而且，-h 标记会使你的数据四舍五入更方便显示，比如它显示 3G 的大小，实际上可能是 2.9G 或者 3.1G，并不确定。
du du 就是 “disk usage” 的缩写，如果你需要计算某个特定目录大小的时候非常好用。一般搭配 -sh 参数让结果更易读，比如这样：
df VS. du 看了这两个命令大致用法后，它们在使用场景是什么呢，众所周知不结合使用场景的技术都是耍流氓。大致可以这样总结：df 命令提供一个关于你整个文件系统的概览，比如你多少空间正在使用等等，du 命令更倾向于计算某个目录的精确快照。
如果非要说哪个的结果更有用一点，我觉得是 du。举个例子，我在 /var 目录下安装一个第三方包时遇到了一个目录空间不足的错误，那么我就可以先跑一下 df 命令去看看这个目录的空间来确认一下这是不是真的。我如果看到 /var 有足够空间，那我会接着跑一下 du /var 去看看是它的哪个子目录因为空间不够报的错。这样我就可以一直通过 df 去缩小出错目录的范围，直到找到问题。
理解这些命令的区别能让我们串联使用这些工具，从而更快的定位并解决我们所面临的绝大多数的问题。</description><content type="html"><![CDATA[<p>linux 在我们日常学习中用的非常多，连接远程 linux 服务器，使用各种 linux 命令，或者物理机就是 linux 系统或者 MacOS。如果你想要学习进阶知识，linux 已经是必不可少的一个组件了。这篇博客记录一下 linux 下常被混淆的 du/df 命令。</p>
<h2 id="df">df</h2>
<p>df 就是 “disk free” 的缩写，一般是用来快速浏览你的文件系统，会显示所有磁盘的大小，使用空间，剩余空间，使用百分比还有磁盘挂载到哪个分区上了。使用的时候一般要带上 <code>-h</code> 参数来增加可读性。这些数据都是从挂载点或者文件系统级别计算出来的，比较 “宏观”。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/sh.png" alt="df -h"></p>
<p>而且，<code>-h</code> 标记会使你的数据四舍五入更方便显示，比如它显示 3G 的大小，实际上可能是 2.9G 或者  3.1G，并不确定。</p>
<h2 id="du">du</h2>
<p>du 就是 “disk usage” 的缩写，如果你需要计算某个特定目录大小的时候非常好用。一般搭配 <code>-sh</code> 参数让结果更易读，比如这样：</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/du.png" alt="du"></p>
<h2 id="df-vs-du">df VS. du</h2>
<p>看了这两个命令大致用法后，它们在使用场景是什么呢，众所周知不结合使用场景的技术都是耍流氓。大致可以这样总结：<code>df</code> 命令提供一个关于你整个文件系统的概览，比如你多少空间正在使用等等，<code>du</code> 命令更倾向于计算某个目录的精确快照。</p>
<p>如果非要说哪个的结果更有用一点，我觉得是 <code>du</code>。举个例子，我在 <code>/var</code> 目录下安装一个第三方包时遇到了一个目录空间不足的错误，那么我就可以先跑一下 <code>df</code> 命令去看看这个目录的空间来确认一下这是不是真的。我如果看到 <code>/var</code> 有足够空间，那我会接着跑一下 <code>du /var</code> 去看看是它的哪个子目录因为空间不够报的错。这样我就可以一直通过 <code>df </code> 去缩小出错目录的范围，直到找到问题。</p>
<p>理解这些命令的区别能让我们串联使用这些工具，从而更快的定位并解决我们所面临的绝大多数的问题。</p>
]]></content></item><item><title>一文搞懂ASCII、Unicode和UTF</title><link>https://kcode.icu/posts/ascii-unicode-utf/</link><pubDate>Fri, 18 Sep 2020 09:27:13 +0000</pubDate><guid>https://kcode.icu/posts/ascii-unicode-utf/</guid><description>起因 最初在学习 Go 语言的各种类型时发现内置字符类型有两种类型，一种是 Byte（1 字节表示一个 ASCII 字符），还有一个就是 rune 类型，可能从其他语言转过来的开发者都会对 rune 觉得非常陌生，我自己也是仅仅停留在 会用 的阶段上，久而久之就会特别乱，所以写一篇博客介绍一下各种字符以及编码方便彼此学习，彻底解决这类问题。
什么是ASCII，为什么又要引入Unicode 都应该了解过 ASCII、Unicode、Unicode 码点、UTF-8等一系列名词。先说 ASCII（American Standard Code for Information Interchange: 美国信息交换标准代码），它是一种字符集，说白了就是一个字符和数字的一一对应关系，你想找这个字符怎么办，计算机又不认识字符？给出他的对应的数字就行了。最初只有美国等一些使用英文的国家使用，所以 128 个字符完全够用，它包含了标点符号、数字和字母等。但是随着世界上使用计算机的国家越来越多，这 128 个字符是完全不够用的。所以 Unicode 字符集 就出现了。Unicode 包含了世界上绝大多数的字符，给他们提供了一一对应关系，比如“知”字对应 30693，即 U+77e5（16 进制形式）。所以说白了 ASCII 和 Unicode 就是一种字符集，一种字符对应关系，Unicode 中每个字符被称为一个 Code Point（码点），而 Go 语言中的 rune 类型正是代表了这样一个单位，即一个 rune 代表了一个 unicode 字符。
那么大家肯定都听说过 UTF-8，UTF-16 吧，那问题来了， UTF 又是什么呢，UTF-8 和 UTF-16 到底又有什么关系呢？
UTF（Unicode Transformation Format） 从字面上你就应该能看出来，这就是一个 Unicode 转换格式。什么是转换格式，为什么需要转换格式？上文说了 Unicode 就是提供了字符间的一一对应关系，比如“知”对应了 30693，那计算机怎么表示这个数（计算机只认识二进制）？很显然，它首先必须要做到 准确识别每一个字符。
比如有这么一串二进制串：1101 0101 1010，如果表示每个字符所需的二进制位数相同，那么这个问题很容易解决，一一对应呗。但是如果长度不同怎么办？</description><content type="html"><![CDATA[<h2 id="起因">起因</h2>
<p>最初在学习 Go 语言的各种类型时发现内置字符类型有两种类型，一种是 Byte（1 字节表示一个 ASCII 字符），还有一个就是 rune 类型，可能从其他语言转过来的开发者都会对 rune 觉得非常陌生，我自己也是仅仅停留在 <strong>会用</strong> 的阶段上，久而久之就会特别乱，所以写一篇博客介绍一下各种字符以及编码方便彼此学习，彻底解决这类问题。</p>
<h2 id="什么是ascii为什么又要引入unicode">什么是ASCII，为什么又要引入Unicode</h2>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/ascii.png" alt="image"></p>
<p>都应该了解过 ASCII、Unicode、Unicode 码点、UTF-8等一系列名词。先说 ASCII（American Standard Code for Information Interchange: 美国信息交换标准代码），它是一种<strong>字符集</strong>，说白了就是一个字符和数字的<strong>一一对应关系</strong>，你想找这个字符怎么办，计算机又不认识字符？给出他的对应的数字就行了。最初只有美国等一些使用英文的国家使用，所以 128 个字符完全够用，它包含了标点符号、数字和字母等。但是随着世界上使用计算机的国家越来越多，这 128 个字符是完全不够用的。所以 <strong>Unicode 字符集</strong> 就出现了。Unicode 包含了世界上绝大多数的字符，给他们提供了一一对应关系，比如“知”字对应 30693，即 U+77e5（16 进制形式）。所以说白了 ASCII 和 Unicode 就是<strong>一种字符集</strong>，<strong>一种字符对应关系</strong>，Unicode 中每个字符被称为一个 <strong>Code Point</strong>（码点），而 Go 语言中的 rune 类型正是代表了这样一个单位，即一个 rune 代表了一个 unicode 字符。</p>
<p>那么大家肯定都听说过 UTF-8，UTF-16 吧，那问题来了， UTF 又是什么呢，UTF-8 和 UTF-16 到底又有什么关系呢？</p>
<h2 id="utfunicode-transformation-format">UTF（Unicode Transformation Format）</h2>
<p>从字面上你就应该能看出来，这就是一个 Unicode 转换格式。什么是转换格式，为什么需要转换格式？上文说了 Unicode 就是提供了字符间的一一对应关系，比如“知”对应了 30693，那计算机怎么表示这个数（计算机只认识二进制）？很显然，它首先必须要做到 <strong>准确识别每一个字符</strong>。</p>
<p>比如有这么一串二进制串：<code>1101 0101 1010</code>，如果表示每个字符所需的二进制位数相同，那么这个问题很容易解决，一一对应呗。但是如果长度不同怎么办？</p>
<p>那就需要先在每个字符开头说明 <strong>该字符未来在二进制流中会使用多少位</strong>，从而不会读错下一个字符。</p>
<p>**Unicode 表示一个字符可以使用 1 - 4 个字节。**UTF-8 是这样做的，第一个字节如果开头位是0，那么就说明该字符只占用一个字节，否则后面有几个 1，就说明该字符需要几个字节来表达。</p>
<p>具体如下：</p>
<table>
<thead>
<tr>
<th>1 字节</th>
<th>0xxxxxxx</th>
</tr>
</thead>
<tbody>
<tr>
<td>2 字节</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>3 字节</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>4 字节</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody>
</table>
<p>解释：如果它表示一个字符只需要 1 个字节，那么表示的就是 ASCII 字符集，从0 -&gt; 127。如果需要 2 个及以上字节表示，那么<strong>第一个字节的前 n 位是 1 ，第 n+1 位是 0，后面每个字节的前两位均为 10（n 是所需字节数）。</strong></p>
<p>所以按照上述规则，“知”字的二进制为：</p>
<pre><code>30693（十进制） -&gt; U+77E5(十六进制) -&gt; 0111 0111 1110 0101（二进制）
</code></pre><p>所以对应的 UTF-8 编码为：<strong>1110</strong>0111 <strong>10</strong>011111 <strong>10</strong>100101，你只需要从低位到高位依次按规则填充即可。</p>
<p>看到这里，我想有思考的读者应该有疑问，为什么原本只需要两字节就能表示的字经过 UTF-8 转换后需要三个字节了，这不是白白地增加内存消耗吗？你可以回忆一下哈夫曼编码的构建结果：将长短不同的<strong>二进制位段</strong>直接放在一起却不会读错，是因为他们没有共同前缀。这里的原理类似，要解决地问题是 <strong>怎么确保长短不同的字符不会重合</strong>。由于有的字符只需要一个字节，而有的需要两个，三个，n 个。当他们堆放在一起时，怎么保证不会出现读少，读多？</p>
<p>解释这个问题，我举个例子，“你”字<strong>假设</strong>表示的十六进制是 A，“我”是 B，“你我”是 AA，“好”是 AB，那我将“你好”放一起时表示就是 AAB，它为什么不是“你你我”，或者“你我我”？</p>
<p>我相信如果你看懂了这个例子，应该就能明白为什么 UTF-8 被称为变长编码了。</p>
<p>这段的标题是 UTF，上面只说了 UTF-8，其实常用的还有 UTF-16，UTF-8 是将一个字节作为一个单位，随着所需字节数量的不同给他们不同的前缀，当计算机读到第一个字节时，通过判断前面连续 1 的个数就能判断未来多少位属于这个字符的范围,，从而解决了不会读错的问题。而 UTF-16 是<strong>将两个字节作为了一个单位</strong>。原理类似，有兴趣的读者可以自己再去探索，我相信你会有更多的发现 :)</p>
<h2 id="验证结果梳理思路">验证结果，梳理思路</h2>
<p>我们可以写一个简单的 Go 语言程序来验证这个结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
 <span class="nx">str</span> <span class="o">:=</span> <span class="s">&#34;hello,狗狼&#34;</span>
 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">str</span><span class="p">))</span>
 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">([]</span><span class="nb">rune</span><span class="p">(</span><span class="nx">str</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre></div><p>输出结果为：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="m">12</span>
<span class="m">8</span>

Process finished with <span class="nb">exit</span> code <span class="m">0</span>
</code></pre></div><p>这里需要说明的是，str 字符串的底层实现就是一个字节数组，根据上面所说的汉字占用 3 个字节，总字节长度为 6+3+3=12，而转换为 rune 类型后，所有字符都占用一个 Unicode <strong>Code Point</strong>（码点），所以占用了共 8 个字符，共 8 个码点。</p>
<p>综上所述，ASCII 和 Unicode 都是一种字符集，代表了字符与数字间的一一对应关系。而 UTF 是一种变长的字符编码规范。而 rune 是 Go 语言中的一个变量类型，一个 rune 代表了一个 Unicode 码点单位。</p>
<p>因个人能力有限，有疏漏之处欢迎和我交流  :)</p>
]]></content></item><item><title>StarUML3.x 版本解包分析</title><link>https://kcode.icu/posts/chore/staruml-3.2.x/</link><pubDate>Wed, 20 May 2020 22:11:13 +0000</pubDate><guid>https://kcode.icu/posts/chore/staruml-3.2.x/</guid><description>由于软件工程基础课需要，搜索发现这个工具还算毕竟好用的，下载了这个工具发现需要注册码，遂进行一番查找，最后确定如下方法。之所以写博客记录下来是因为有两个坑点。
OS：Windows 10 专业版。
更新时间：2020/5/17
StarUML版本：3.2.2
破解思路 该工具是用 Electron 框架所写，代码是通过 asar 工具打包而成，我们只需要利用该工具反编译出源代码，修改相关判断逻辑即可。
具体做法 下载安装 node 如果不会，自（bie）行（lai）解（zhao）决（wo）。
使用 cnpm 包管理工具下载 asar 由于众所周知的原因，用 cnpm 下载，先安装 cnpm并使用淘宝镜像源：
npm install -g cnpm --registry=https://registry.npm.taobao.org // 下载 asar cnpm install -g asar // 安装 asar 解压 asar 文件，修改源代码 找到 StarUML 安装目录里 resource 文件夹下的 app.asar 文件，执行解压：
asar extract app.asar app 坑点一、解压盘符问题 由于 StarUML 默认安装位置是 C 盘，直接在 StarUML 的安装目录下执行会有权限问题，会报类似这种错误：
$ asar extract app.asar app internal/fs/utils.js:230 throw err; ^ Error: EPERM: operation not permitted, open 'app\package.</description><content type="html"><![CDATA[<p>由于软件工程基础课需要，搜索发现这个工具还算毕竟好用的，下载了这个工具发现需要注册码，遂进行一番查找，最后确定如下方法。之所以写博客记录下来是因为<strong>有两个坑点</strong>。</p>
<blockquote>
<p>OS：Windows 10 专业版。</p>
<p>更新时间：2020/5/17</p>
<p>StarUML版本：3.2.2</p>
</blockquote>
<h2 id="破解思路">破解思路</h2>
<p>该工具是用 Electron 框架所写，代码是通过 asar 工具打包而成，我们只需要利用该工具反编译出源代码，修改相关判断逻辑即可。</p>
<h2 id="具体做法">具体做法</h2>
<h3 id="下载安装-node">下载安装 node</h3>
<p>如果不会，自（bie）行（lai）解（zhao）决（wo）。</p>
<h3 id="使用-cnpm-包管理工具下载-asar">使用 cnpm 包管理工具下载 asar</h3>
<p>由于众所周知的原因，用 cnpm 下载，先安装 cnpm并使用淘宝镜像源：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">npm install -g cnpm --registry<span class="o">=</span>https://registry.npm.taobao.org	// 下载 asar

cnpm install -g asar // 安装 asar
</code></pre></div><h3 id="解压-asar-文件修改源代码">解压 asar 文件，修改源代码</h3>
<p>找到 StarUML 安装目录里 resource 文件夹下的 app.asar 文件，执行解压：</p>
<pre><code>asar extract app.asar app
</code></pre><h4 id="坑点一解压盘符问题">坑点一、解压盘符问题</h4>
<p>由于 StarUML 默认安装位置是 C 盘，直接在 StarUML 的安装目录下执行会有权限问题，会报类似这种错误：</p>
<pre><code>$ asar extract app.asar app
internal/fs/utils.js:230
 throw err;
 ^
   
   Error: EPERM: operation not permitted, open 'app\package.json'
 at Object.openSync (fs.js:458:3)
 at Object.writeFileSync (fs.js:1279:35)
    at Object.module.exports.extractAll (C:\Users\shiluo\AppData\Roaming\npm\node_modules\asar\lib\asar.js:201:10)
    at Command.&lt;anonymous&gt; (C:\Users\shiluo\AppData\Roaming\npm\node_modules\asar\bin\asar.js:72:10)
    at Command.listener [as _actionHandler] (C:\Users\shiluo\AppData\Roaming\npm\node_modules\asar\node_modules\_commander@5.1.0@commander\index.js:413:31)
    at Command._parseCommand (C:\Users\shiluo\AppData\Roaming\npm\node_modules\asar\node_modules\_commander@5.1.0@commander\index.js:914:14)
    at Command._dispatchSubcommand (C:\Users\shiluo\AppData\Roaming\npm\node_modules\asar\node_modules\_commander@5.1.0@commander\index.js:865:18)
    at Command._parseCommand (C:\Users\shiluo\AppData\Roaming\npm\node_modules\asar\node_modules\_commander@5.1.0@commander\index.js:882:12)
    at Command.parse (C:\Users\shiluo\AppData\Roaming\npm\node_modules\asar\node_modules\_commander@5.1.0@commander\index.js:717:10)
    at Object.&lt;anonymous&gt; (C:\Users\shiluo\AppData\Roaming\npm\node_modules\asar\bin\asar.js:80:9) {
   errno: -4048,
   syscall: 'open',
  code: 'EPERM',
  path: 'app\\package.json'
  }
</code></pre><p>解决方法：只需要把 app.asar 单独拿出来放其他盘比如你放 D 盘（不要在根目录，下面有解释），然后再次执行上面这个命令即可。</p>
<p>然后找到解压出来的源代码的 app/src/engine/license-manager.js 文件，大概在 120 行：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">checkLicenseValidity</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">validate</span><span class="p">().</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">setStatus</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
  <span class="p">},</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="c1">// setStatus(this, false)
</span><span class="c1"></span>    <span class="c1">// UnregisteredDialog.showDialog()
</span><span class="c1"></span>    <span class="nx">setStatus</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">}</span>
</code></pre></div><p>可以很明显看到是一个 Promise ，成功了将注册状态设置为 true，否则设置为 false，并且弹窗提示。所以嘛。。就在这里下手，把逻辑改掉，如上图所示。</p>
<h3 id="重新打包运行">重新打包运行</h3>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">asar pack app app.asar
</code></pre></div><h4 id="坑点二打包路径问题">坑点二、打包路径问题</h4>
<p>上面说到不要把解压得到的 app 目录放在根目录下，否则执行打包命令后会报这个错误，这里我拿 D 盘举个栗子：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ asar pack app app.asar
<span class="o">(</span>node:9504<span class="o">)</span> UnhandledPromiseRejectionWarning: Error: EPERM: operation not permitted, mkdir <span class="s1">&#39;D:\&#39;</span>
<span class="o">(</span>node:9504<span class="o">)</span> UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async <span class="k">function</span> without a catch block, or by rejecting a promise which was not handled with .catch<span class="o">()</span>. To terminate the node process on unhandled promise rejection, use the CLI flag <span class="sb">`</span>--unhandled-rejections<span class="o">=</span>strict<span class="sb">`</span> <span class="o">(</span>see https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode<span class="o">)</span>. <span class="o">(</span>rejection id: 1<span class="o">)</span>
<span class="o">(</span>node:9504<span class="o">)</span> <span class="o">[</span>DEP0018<span class="o">]</span> DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero <span class="nb">exit</span> code.
</code></pre></div><p>执行完后会得到一个 80 MB 左右的 asar 文件，拿它覆盖原安装包内的 asar 文件，运行 StarUML。</p>
<p>搞定。</p>
]]></content></item><item><title>OBS显示器捕获黑屏解决方案</title><link>https://kcode.icu/posts/chore/obs/</link><pubDate>Sun, 26 Apr 2020 11:34:13 +0000</pubDate><guid>https://kcode.icu/posts/chore/obs/</guid><description>问题起因 由于我最近重新安装了系统，在重新下载 OBS 后发现捕获不到桌面。我之前解决方法就是直接在显卡控制面板里将 OBS 设置为集显就行了。但是这次设置了也不行，有可能是我下载的显卡驱动版本不对。。于是就找到了这个终极解决方案，基本电脑上有这个功能的都能解决。
问题环境 操作系统：Win10 64位 专业版 - 1909
CPU 集成显卡型号：Inter(R) UHD Graphics 630
独立显卡型号：NVIDIA GeForce GTX 1050
OBS 版本：25.0.4(64 bit)
注：配置和我不一样也有可能解决，不用纠结
问题描述 在来源中添加显示器捕获后 ，是黑屏，无法捕获到显示器。
问题分析 目前网上能搜集到的解决方案大部分是以下几种：
右键 OBS 属性 - 兼容性 - 兼容模式 - 以兼容模式运行这个程序（win7）设置 - 以管理员方式运行 桌面上右键打开 NVIDIA 控制面板，管理 3D 设置 - 程序设置，找到 OBS，设置为集成图形。 但是我都试了都解决不了，我就去搜了一下问题的原因，最终发现 OBS 只能捕捉到和自己跟自己使用相同显卡的应用，然后我右键打开任务管理器，发现笔记本桌面使用的是我的集显。所以就需要把 OBS 设置为应用集显。
解决方法 左下角开始按钮 - 设置 - 系统 - 显示 - 图形设置 - 经典应用里浏览添加 OBS ，点击选项，设置为节能，节能就是使用集显。然后你再打开 OBS&amp;hellip;&amp;hellip;</description><content type="html"><![CDATA[<h2 id="问题起因">问题起因</h2>
<p>由于我最近重新安装了系统，在重新下载 OBS 后发现捕获不到桌面。我之前解决方法就是直接在<strong>显卡控制面板</strong>里将 OBS 设置为集显就行了。但是这次设置了也不行，有可能是我下载的显卡驱动版本不对。。于是就找到了这个终极解决方案，基本电脑上有这个功能的都能解决。</p>
<h2 id="问题环境">问题环境</h2>
<p>操作系统：Win10 64位 专业版 - 1909</p>
<p>CPU 集成显卡型号：Inter(R) UHD Graphics 630</p>
<p>独立显卡型号：NVIDIA GeForce GTX 1050</p>
<p>OBS 版本：25.0.4(64 bit)</p>
<blockquote>
<p>注：配置和我不一样也有可能解决，不用纠结</p>
</blockquote>
<h2 id="问题描述">问题描述</h2>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/obs-noscreen.png" alt=""></p>
<p>在来源中添加<strong>显示器捕获后</strong> ，是黑屏，<strong>无法捕获到显示器</strong>。</p>
<h2 id="问题分析">问题分析</h2>
<p>目前网上能搜集到的解决方案大部分是以下几种：</p>
<ul>
<li>右键 OBS 属性 - 兼容性 - 兼容模式 - 以兼容模式运行这个程序（win7）设置 -  以管理员方式运行</li>
<li>桌面上右键打开 NVIDIA 控制面板，管理 3D 设置 - 程序设置，找到 OBS，设置为集成图形。</li>
</ul>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/obs-gpu.png" alt="任务管理器最下面"></p>
<p>但是我都试了都解决不了，我就去搜了一下问题的原因，<strong>最终</strong>发现 OBS <strong>只能捕捉到和自己跟自己使用相同显卡的应用</strong>，然后我右键打开任务管理器，发现笔记本桌面使用的是我的集显。所以就需要把 OBS 设置为应用集显。</p>
<h2 id="解决方法">解决方法</h2>
<p><!-- raw HTML omitted --></p>
<p>左下角开始按钮 - 设置 - 系统 - 显示 - 图形设置 - 经典应用里浏览添加 OBS ，点击选项，设置为节能，节能就是使用集显。然后你再打开 OBS&hellip;&hellip;</p>
<p>这时候你就会发现你成功了。</p>
<p>其他的推流软件也一样，比如什么 B 站直播姬等同理。</p>
<p>以上。</p>
]]></content></item><item><title>Go+QML构建桌面应用</title><link>https://kcode.icu/posts/chore/go+qamel/</link><pubDate>Mon, 23 Mar 2020 14:51:15 +0000</pubDate><guid>https://kcode.icu/posts/chore/go+qamel/</guid><description>引文 开发的项目是直播助手，相关介绍在 B站直播协议分析上 有介绍，这里说一下技术选型方面遇到的问题，踩的坑，希望给后续的人一点建议和参考。
技术选型 因为当时第一步的主要想开发的功能是弹幕点歌，但是在稍做分析之后发现如何对 MP3 文件进行解码播放是个问题，自己实现可能略显复杂，也不是这个工具的主要想解决的问题。然后就考虑到使用什么组件来解码并播放音乐。
最初的想法是另写一套前端，和已经写好的这套后端进行通信，来呈现内容，播放音乐等，这是一定可以实现的，但是同一条信息进行两次传输效率太低，于是放弃，想在同一端执行，增加效率。Go 确实不擅长写 GUI 程序（C#完美。。），决定使用 qamel来使用开发，其和 therecipe 比较如下：
轻量（只使用少量的类）。构建简单的 QML 应用，比如 QApplication、 QQuickView and QQMLApplicationEngine。而 therecipe/qt 绑定了所有的 QT 模块。 安装简单。需要拿到编译好的 qamel 二进制文件（你可以选择自己编译构建，也可以选择直接从别人手里获取），放入 path 环境变量，再设置好配置，就可以构建自己的引用了。而 therecipe/qt 需要执行 setup 等一系列安装过程，繁琐且容易失败。 编译速度快。因为绑定部分代码是手动写的，使得绑定安装过程非常快，而 therecipe/qt 是安装时即时生成的，所以非常慢，可以自己体验一下。。 还有个缺点，目前跨平台编译只支持 windows 和 linux，macOS 作者未测试，目前未知。而therecipe/qt 支持 Linux, Windows, macOS, Android, Sailfish, Ubuntu Touch, WASM, and iOS各种平台。
坑在哪 以下均是在 Windows ，amd64 位环境下的结果。
不要在系统自带 CMD 或 PowerShell 中构建应用，不然会报代码第二行找不到 QApplication 的错误，换用 cmder 就可以解决，这个问题已经被证实，但是并未找到原因。</description><content type="html"><![CDATA[<h2 id="引文">引文</h2>
<p>开发的项目是直播助手，相关介绍在 <a href="http://shiluo.design/2020/03/14/B%E7%AB%99%E7%9B%B4%E6%92%AD%E5%8A%A9%E6%89%8B%E5%BC%80%E5%8F%91%5B%E4%B8%8A%5D/">B站直播协议分析上</a> 有介绍，这里说一下技术选型方面遇到的问题，踩的坑，希望给后续的人一点建议和参考。</p>
<h2 id="技术选型">技术选型</h2>
<p>因为当时第一步的主要想开发的功能是弹幕点歌，但是在稍做分析之后发现如何对 MP3 文件进行解码播放是个问题，自己实现可能略显复杂，也不是这个工具的主要想解决的问题。然后就考虑到使用什么组件来解码并播放音乐。</p>
<p><strong>最初</strong>的想法是另写一套前端，和已经写好的这套后端进行通信，来呈现内容，播放音乐等，这是一定可以实现的，但是同一条信息进行两次传输效率太低，于是放弃，想在同一端执行，增加效率。Go 确实不擅长写 GUI 程序（C#完美。。），决定使用 <a href="https://github.com/go-qamel/qamel">qamel</a>来使用开发，其和 <a href="https://github.com/therecipe/qt">therecipe</a> 比较如下：</p>
<ul>
<li>轻量（只使用少量的类）。构建简单的 QML 应用，比如 <code>QApplication</code>、 <code>QQuickView</code> and <code>QQMLApplicationEngine</code>。而 <code>therecipe/qt</code> 绑定了所有的 QT 模块。</li>
<li>安装简单。需要拿到编译好的 qamel 二进制文件（你可以选择自己编译构建，也可以选择直接从别人手里获取），放入 <code>path</code> 环境变量，再设置好配置，就可以构建自己的引用了。而 <code>therecipe/qt</code> 需要执行 <code>setup</code> 等一系列安装过程，繁琐且容易失败。</li>
<li>编译速度快。因为绑定部分代码是手动写的，使得绑定安装过程非常快，而 <code>therecipe/qt</code> 是安装时即时生成的，所以<strong>非常慢</strong>，可以自己体验一下。。</li>
</ul>
<blockquote>
<p>还有个缺点，目前跨平台编译只支持 windows 和 linux，macOS 作者未测试，目前未知。而<code>therecipe/qt</code> 支持 Linux, Windows, macOS, Android, Sailfish, Ubuntu Touch, WASM, and iOS各种平台。</p>
</blockquote>
<h2 id="坑在哪">坑在哪</h2>
<blockquote>
<p>以下均是在 Windows ，amd64 位环境下的结果。</p>
</blockquote>
<ul>
<li>
<p>不要在系统自带 CMD 或 PowerShell 中构建应用，不然会报代码第二行找不到 <code>QApplication</code> 的错误，换用 <code>cmder</code> 就可以解决，这个问题已经被证实，但是并未找到原因。</p>
</li>
<li>
<p>目前（Latest commit<a href="https://github.com/go-qamel/qamel/commit/72f913c4bdc9e8cf6f99d511c5eaa83233d36df5">72f913c</a>on 27 Nov 2019），<strong>不要用 Qt5.14.1及以上版本</strong>，但是版本号要大于5.11，不然都会报错。比如图示：</p>
</li>
</ul>
<p><img src="http://cdn.shiluo.design/aaa.png" alt="版本原因的错误"></p>
<p>因为作者基本不维护，所以提的问题也没解决，目前也不确定是哪方面的问题，所以记录一下，希望以后使用此库的人能注意。</p>
<p>以上。</p>
]]></content></item><item><title>优化Golang服务减少40%以上的CPU</title><link>https://kcode.icu/posts/translation/20200303-optimizing-a-golang-service-to-reduce-over-40-cpu/</link><pubDate>Mon, 16 Mar 2020 16:46:08 +0000</pubDate><guid>https://kcode.icu/posts/translation/20200303-optimizing-a-golang-service-to-reduce-over-40-cpu/</guid><description>优化 Golang 服务来减少 40% 以上的 CPU 十年前，谷歌正在面临一个由 C++ 编译时间过长所造成的严重瓶颈，并且需要一个全新的方式来解决这个问题。谷歌的工程师们通过创造了一种新的被称作 Go （又名 Golang）的语言来应对挑战。这个新语言 Go 带来了 C++ 最好的部分（最主要的是它的性能和稳定性），又与 Python 的速度相结合，使得 Go 能够在实现并发的同时快速地使用多核心。
在 Coralogix（译者注：一个提供全面日志分析的服务产品，官网），我们为了去给我们的客户提供关于他们日志实时的分析、警报和元数据，要去解析他们的日志。在解析阶段，我们需要非常快速地解析包含多个复杂规则的服务日志，这个目标是促使我们决定使用 Golang 的原因之一。
这项新的服务现在就全天候的跑在生产阶段，尽管我们看到了非常好的结果，但是它也需要跑在高性能的机器上。这项 Go 的服务跑在一台 AWS m4.2xlarge 实例上 ，带有 8 CPUs 和 36 GB 的配置，每天要解析几十亿的日志。
在这个阶段一切都运行正常，我们本可以自我感觉良好，但是那并不是我们在 Coralogix 想要的表现。我们想要更多的特性，比如性能等等，或者使用更少的 AWS 实例。为了改进，我们首先需要理解瓶颈的本质以及我们如何能够减少或者完全解决这些问题。
我们决定在我们的服务上进行一些分析，检查一下到底是什么造成了 CPU 的高消耗，看看我们是否能够优化。
首先，我们将 Go 升级到最新的稳定版本（这是软件生命周期中的关键一步）。我们是用的 Go 1.12.4版本，最新的是 1.13.8。根据 文档 ，Go 1.13 发行版在运行时库方面和一些其他主要利用内存使用的组件方面已经有了长足的进步。总之，使用最新的稳定版本能帮助我们节省许多工作。
因此，内存消耗由大约 800 MB 降低到了仅 180 MB。
第二，为了更好的理解我们的流程以及弄清楚我们应该在哪花费时间和资源，我们开始去进行分析。
分析不同的服务和程序语言可能看起来很复杂并且令人望而生畏，但是对于 Go 来说它实际上十分容易，仅仅几个命令就能够描述清楚。Go 有一个专门的工具叫“pprof”，它通过监听一个路由（默认端口6060）能够应用在你的 app 上，并且使用 Go 的包来管理 HTTP 连接：</description><content type="html"><![CDATA[<h1 id="优化-golang-服务来减少-40-以上的-cpu">优化 Golang 服务来减少 40% 以上的 CPU</h1>
<p>十年前，谷歌正在面临一个由 C++ 编译时间过长所造成的严重瓶颈，并且需要一个全新的方式来解决这个问题。谷歌的工程师们通过创造了一种新的被称作 Go （又名 Golang）的语言来应对挑战。这个新语言 Go 带来了 C++ 最好的部分（最主要的是它的性能和稳定性），又与 Python 的速度相结合，使得 Go 能够在实现并发的同时快速地使用多核心。</p>
<p>在 Coralogix（译者注：一个提供全面日志分析的服务产品，<a href="https://coralogix.com/">官网</a>），我们为了去给我们的客户提供关于他们日志实时的分析、警报和元数据，要去解析他们的日志。在解析阶段，我们需要非常快速地解析包含多个复杂规则的服务日志，这个目标是促使我们决定使用 Golang 的原因之一。</p>
<p>这项新的服务现在就全天候的跑在生产阶段，尽管我们看到了非常好的结果，但是它也需要跑在高性能的机器上。这项 Go 的服务跑在一台 AWS m4.2xlarge 实例上 ，带有 8 CPUs 和 36 GB 的配置，每天要解析几十亿的日志。</p>
<p>在这个阶段一切都运行正常，我们本可以自我感觉良好，但是那并不是我们在 Coralogix 想要的表现。我们想要更多的特性，比如性能等等，或者使用更少的 AWS 实例。为了改进，我们首先需要理解瓶颈的本质以及我们如何能够减少或者完全解决这些问题。</p>
<p>我们决定在我们的服务上进行一些分析，检查一下到底是什么造成了 CPU 的高消耗，看看我们是否能够优化。</p>
<p>首先，我们将 Go 升级到最新的稳定版本（这是软件生命周期中的关键一步）。我们是用的 Go 1.12.4版本，最新的是 1.13.8。根据 <a href="https://golang.org/doc/devel/release.html">文档</a> ，Go 1.13 发行版在运行时库方面和一些其他主要利用内存使用的组件方面已经有了长足的进步。总之，使用最新的稳定版本能帮助我们节省许多工作。</p>
<p>因此，内存消耗<strong>由大约 800 MB 降低到了仅 180 MB</strong>。</p>
<p>第二，为了更好的理解我们的流程以及弄清楚我们应该在哪花费时间和资源，我们开始去进行分析。</p>
<p>分析不同的服务和程序语言可能看起来很复杂并且令人望而生畏，但是对于 Go 来说它实际上十分容易，仅仅几个命令就能够描述清楚。Go 有一个专门的工具叫“pprof”，它通过监听一个路由（默认端口6060）能够应用在你的 app 上，并且使用 Go 的包来管理 HTTP 连接：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">_</span> <span class="s">&#34;net/http/pprof&#34;</span>
</code></pre></div><p>接着在你的 main 函数中或者路由包下按照如下操作初始化：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;localhost:6060&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}()</span>
</code></pre></div><p>现在你可以启动你的服务并且连接到：</p>
<pre><code>http://localhost:6060/debug/pprof
</code></pre><p>Go 官方提供的完整文档可以 <a href="https://golang.org/pkg/net/http/pprof">在这</a> 找到。</p>
<p>pprof 的默认配置是每 30 秒对 CPU 的使用情况进行采样。有许多不同的选择，也可以对 CPU 的使用，堆的使用或者其他更多的使用情况进行采样。</p>
<p>我们主要关注 CPU 使用，因此在生产阶段采取了一个 30 秒的性能分析，并且发现了你在下图所看到的情况（提醒一下：这是在我们把 Go 版本升级并且将 Go 的内部组件降到最低之后的结果）：</p>
<p><img src="http://cdn.shiluo.design/0.png" alt="Go profiling — Coralogix"></p>
<p>正如你所看到的，我们发现了许多运行时库的活动：GC 几乎使用了 <strong>29% 的 CPU</strong>（还仅仅只是消耗最多的前 20 个对象）。因为 Go 的 GC 非常快并且做了巨大的优化，最好的实践就是不要去改变或者修改它。因为我们的内存消耗非常低（与我们先前的 Go 版本相比），所以主要的怀疑对象就变成了较高的对象分配率。</p>
<p>如果是那种情况的话，我们就能做两件事情了：</p>
<ul>
<li>调整 Go GC 活动，使其适合我们的服务行为，意味着 —— 延缓它的触发以使 GC 变的不那么频繁。<strong>这将使我们不得不补偿更多的内存使用。</strong></li>
<li>找出我们代码中那些分配了太多对象的函数、区段或者行。</li>
</ul>
<p>观察一下我们的实例类型，很明显我们有大量的内存可供使用，并且我们正在被机器的 CPU 数量所限制。因此我们仅仅需要调整一下比率。因为在 Golang 的早期有一个大多数开发者都不关注的数据，叫 GOGC。这个数值默认是 100，简单地告诉你的系统什么时候触发 GC。这个默认值使得堆的大小在到达它初始态的两倍时触发 GC。将这个数值改成一个更大的数将会延缓 GC 的触发，降低它的频率。我们基准测试了许多不同的数，最终对于我们的目标来说最好的性能是在使用 GOGC = 2000 的时候。</p>
<p>这立刻<strong>增加了我们的内存使用，从大约 200 MB 到 大约 2.7 GB</strong>（那还是由于我们的 Go 版本更新，在内存消耗降低的情况下），另外也<strong>减少了我们 CPU 大约 10% 的使用。</strong></p>
<p>这个接下来的截图就展示了这些基准测试的结果：</p>
<p><img src="http://cdn.shiluo.design/01.png" alt="GOGC =2000 results — Coralogix benchmark"></p>
<p>前面的四个 CPU 的消耗函数就是我们的服务函数，这十分有意义。全部的 GC 使用现在<strong>大约是 13%，是先前消耗的一半还少！</strong></p>
<p>我们其实可以在这就停下来了，但是我们还是决定去揭露我们在哪并且为什么会分配这么多对象。很多时候，这么做有充分理由（比如在流式处理的情况下，我们为每条获取的消息创建了许多新的对象，并且因为它与下一条消息无关，需要去移除它），但是在某些情况下有一种简单的方法可以去优化并且动态地减少对象的创建。</p>
<p>首先，让我们运行一个和之前同样的命令，有一点小的改变，采用堆调试：</p>
<pre><code>http://localhost:6060/debug/pprof/heap
</code></pre><p>为了查询结果文件，你可以运行如下命令在你的代码目录下来分析调试结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">go tool pprof -alloc_objects &lt;HEAP.PROFILE.FILE&gt;
</code></pre></div><p>我们的截图看起来像这样：</p>
<p><img src="http://cdn.shiluo.design/02.png" alt=""></p>
<p>除了第三行一切似乎都很合理，这是一个监控函数，在每个 Carologix 规则解析阶段的末尾向我们的 Promethes 调用者展示结果。为了获取进一步信息，我们运行如下命令：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">list &lt;FunctionName&gt;
</code></pre></div><p>例如：</p>
<pre><code>list reportRuleExecution
</code></pre><p>然后我们会获得如下结果：</p>
<p><img src="http://cdn.shiluo.design/3.png" alt=""></p>
<p>WithLabelValues 的两个调用都是为了软件度量的 Prometheus 函数（我们将这个留给产品去决定是否真正需要）。而且，我们可以看到第一行创建了大量的对象（由这个函数所创建的全部对象的 10%）。我们进一步查看发现它是一个对于绑定到导出数据的消费者 ID 从 int 到 string 的转换，十分重要，但是考虑到实际情况，我们数据库中消费者的数量十分有限，我们不应该采用 Prometheus 的方式来接收变量作为 string 类型。因此取代了每次创建一个新的 string 并且在函数末尾都抛弃的这种方法（浪费分配还有 GC 的多余工作），我们在对象的分配阶段定义了 map，配对了所有从 1 到 10 万的数字和一个需要执行的 “get” 方法。</p>
<p>现在运行一个新的性能分析会话来验证我们的论点并且它的对的（你可以看到这一部分并不会再分配对象了）：
<img src="http://cdn.shiluo.design/4.png" alt=""></p>
<p>这并不是一个显著的改进，但是总体来说为我们节省了另一个 GC 的活动，说的更具体一点就是节省了大约 1% 的 CPU。</p>
<p>最终的状态就是下面的截图：</p>
<p><img src="http://cdn.shiluo.design/5.png" alt=""></p>
<h2 id="最终结果">最终结果</h2>
<p><strong>1) 内存使用：大约 1.3 GB -&gt; 大约 2.7 GB</strong></p>
<p><strong>2) CPU 使用：大约 2.55 avg 和 大约 5.05 峰值期 -&gt; 大约 2.13 avg 和 大约 2.9 峰值期。</strong></p>
<p>在我们 Golang 优化前的 CPU：</p>
<p><img src="http://cdn.shiluo.design/6.png" alt=""></p>
<p>在我们 Golang 优化后的CPU：</p>
<p><img src="http://cdn.shiluo.design/7.png" alt=""></p>
<p>总体来说，我们可以看到主要的改进是在每秒日志处理量增加时的高峰时间。这就意味着我们的基础架构不仅不需要再为了异常值进行调整，而且变得更加稳定了。</p>
<h2 id="总结">总结</h2>
<p>通过对我们的 Go 解析服务进行性能测试，我们能够查明有问题的地方，更好的理解我们的服务并且确定在哪里（如果有的话）投资时间进行改进。大多数性能分析工作都会以一些基础数值或配置的调整，更合适你的使用情况并且最终展现更好的性能而结束。</p>
<hr>
<p>via：https://medium.com/coralogix-engineering/optimizing-a-golang-service-to-reduce-over-40-cpu-366b67c67ef9</p>
<p>作者：<a href="https://medium.com/@eliezerj8">Eliezer Yaacov</a>
译者：<a href="https://github.com/sh1luo">sh1luo</a>
校对：<a href="https://github.com/unknwon">@unknwon</a></p>
<p>本文由 <a href="https://github.com/studygolang/GCTT">GCTT</a> 原创编译，<a href="https://studygolang.com/">Go中文网</a> 荣誉推出</p>
]]></content></item><item><title>Go+QML开发的跨平台桌面直播助手[下]</title><link>https://kcode.icu/posts/b%E7%AB%99%E7%9B%B4%E6%92%AD%E5%8A%A9%E6%89%8B%E5%BC%80%E5%8F%91%E4%B8%8B/</link><pubDate>Fri, 13 Mar 2020 13:22:23 +0000</pubDate><guid>https://kcode.icu/posts/b%E7%AB%99%E7%9B%B4%E6%92%AD%E5%8A%A9%E6%89%8B%E5%BC%80%E5%8F%91%E4%B8%8B/</guid><description>Go + QML 结合上节的分析，开发的思路的大致流程我画了个图，大概是这样：
因为是需要面向用户的，又考虑到 Go 语言的特殊性（可以直接调用 C/C++ 代码，GUI 官方不支持），最后决定使用 Qml 来呈现前端，与 Go 语言利用插槽和信号进行通信。
处理思路是创建一个协程池来处理不同类型的包数据。判断每个包内所有子包类型，将接收的未处理的字节数组直接送入对应协程池中的管道。因为代码也比较简单，就是简单的 WebSocket 通信。
// 客户端实例 type Client struct { RoomID uint32 // 房间 ID Online uint32 // 用来判断人气是否变动 Conn *websocket.Conn // 连接后的对象 IsConnected bool } // 使用了&amp;#34;github.com/gorilla/websocket&amp;#34;这个包，也可以自己升级 tcp 到 websocket u := url.URL{Scheme: &amp;#34;wss&amp;#34;, Host: DanMuServer, Path: &amp;#34;/sub&amp;#34;,} conn, _, err := websocket.DefaultDialer.Dial(u.String(), nil) if err != nil { return nil, err } // 发送包函数 func SendPackage(conn *websocket.</description><content type="html"><![CDATA[<h1 id="go--qml">Go + QML</h1>
<p>结合上节的分析，开发的思路的大致流程我画了个图，大概是这样：</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/go_qml_flowchart.png" alt="流程图"></p>
<blockquote>
<p>因为是需要面向用户的，又考虑到 Go 语言的特殊性（可以直接调用 C/C++ 代码，GUI 官方不支持），最后决定使用 Qml 来呈现前端，与 Go 语言利用插槽和信号进行通信。</p>
</blockquote>
<p>处理思路是创建一个协程池来处理不同类型的包数据。判断每个包内所有子包类型，将接收的未处理的字节数组直接送入对应协程池中的管道。因为代码也比较简单，就是简单的 WebSocket 通信。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 客户端实例
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Client</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">RoomID</span>      <span class="kt">uint32</span>				<span class="c1">// 房间 ID
</span><span class="c1"></span>	<span class="nx">Online</span>      <span class="kt">uint32</span>				<span class="c1">// 用来判断人气是否变动
</span><span class="c1"></span>	<span class="nx">Conn</span>        <span class="o">*</span><span class="nx">websocket</span><span class="p">.</span><span class="nx">Conn</span>		<span class="c1">// 连接后的对象
</span><span class="c1"></span>	<span class="nx">IsConnected</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 使用了&#34;github.com/gorilla/websocket&#34;这个包，也可以自己升级 tcp 到 websocket
</span><span class="c1"></span><span class="nx">u</span> <span class="o">:=</span> <span class="nx">url</span><span class="p">.</span><span class="nx">URL</span><span class="p">{</span><span class="nx">Scheme</span><span class="p">:</span> <span class="s">&#34;wss&#34;</span><span class="p">,</span> <span class="nx">Host</span><span class="p">:</span> <span class="nx">DanMuServer</span><span class="p">,</span> <span class="nx">Path</span><span class="p">:</span> <span class="s">&#34;/sub&#34;</span><span class="p">,}</span>
<span class="nx">conn</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">websocket</span><span class="p">.</span><span class="nx">DefaultDialer</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="nx">u</span><span class="p">.</span><span class="nf">String</span><span class="p">(),</span> <span class="kc">nil</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="c1">// 发送包函数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">SendPackage</span><span class="p">(</span><span class="nx">conn</span> <span class="o">*</span><span class="nx">websocket</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">packetlen</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">magic</span> <span class="kt">uint16</span><span class="p">,</span> <span class="nx">ver</span> <span class="kt">uint16</span><span class="p">,</span> <span class="nx">typeID</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">param</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">packetHead</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">packetlen</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">packetlen</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="o">+</span> <span class="mi">16</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">pdata</span> <span class="p">=</span> <span class="p">[]</span><span class="kd">interface</span><span class="p">{}{</span>
		<span class="nx">packetlen</span><span class="p">,</span>
		<span class="nx">magic</span><span class="p">,</span>
		<span class="nx">ver</span><span class="p">,</span>
		<span class="nx">typeID</span><span class="p">,</span>
		<span class="nx">param</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="c1">// 将包的头部信息以大端序，二进制形式写入字节数组
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pdata</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">binary</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">packetHead</span><span class="p">,</span> <span class="nx">binary</span><span class="p">.</span><span class="nx">BigEndian</span><span class="p">,</span> <span class="nx">v</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 将包内数据部分追加到数据包内
</span><span class="c1"></span>	<span class="nx">sendData</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">packetHead</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">(),</span> <span class="nx">data</span><span class="o">...</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">WriteMessage</span><span class="p">(</span><span class="nx">websocket</span><span class="p">.</span><span class="nx">BinaryMessage</span><span class="p">,</span> <span class="nx">sendData</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// fmt.Println(&#34;c.conn.Write err: &#34;, err)
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div><p>拼接 URL 是使用的官方提供的 url 包，发送包数据要注意的是发送的是二进制数据流，所以要用 binary.Write 以二进制，且在网络上传输是大端序方式写入字节数组。</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/up.png" alt="心跳包上行"></p>
<p>心跳包上行是通过发送两个空的对象，所以我把这个固定的数直接粘贴下来转为字节数组后，创建一个 go 协程，按照每 30 秒一次的时间间隔发送就好。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Client</span><span class="p">)</span> <span class="nf">HeartBeat</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">IsConnected</span> <span class="p">{</span>
			<span class="nx">obj</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;5b6f626a656374204f626a6563745d&#34;</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">util</span><span class="p">.</span><span class="nf">SendPackage</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">obj</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
            <span class="c1">// 每 30 秒发一次
</span><span class="c1"></span>			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">30</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>心跳包下行是还是一个固定的包首部，只携带了一个 4 字节大小的实体就是直播间人气值，所以我只需要每次和 c.Online 进行比较，及时修改人气数就可以了。</p>
<p><img src="https://blogimagee.oss-cn-beijing.aliyuncs.com/images/down.png" alt="心跳包下行"></p>
<p>最后一个问题就是<strong>对每个包的所有子包依次进行判断，防止信息量过大的时候有漏掉的情况</strong>，思路是读取完第一个包后，根据第一个包的大小找到第二个包的偏移位置继续读取，直到达到末尾，里面的<code>ByteArrToDecimal</code>是自己写的一个将读取到的十进制字节数组转换为十进制表示数的方法函数，也附带在下方了，如果有更好的实现可以告诉我，我也是自己脑洞大开临时写的&hellip;.有可能有更简单的实现。。。。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">inflated</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
	<span class="nx">l</span> <span class="o">:=</span> <span class="nx">util</span><span class="p">.</span><span class="nf">ByteArrToDecimal</span><span class="p">(</span><span class="nx">inflated</span><span class="p">[:</span><span class="mi">4</span><span class="p">])</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">inflated</span><span class="p">[</span><span class="mi">16</span><span class="p">:</span><span class="nx">l</span><span class="p">],</span> <span class="s">&#34;cmd&#34;</span><span class="p">).</span><span class="nf">ToString</span><span class="p">()</span>
	<span class="k">switch</span> <span class="nx">c</span> <span class="p">{</span>
		<span class="k">case</span> <span class="s">&#34;DANMU_MSG&#34;</span><span class="p">:</span>
			<span class="nx">p</span><span class="p">.</span><span class="nx">DanmuSrc</span> <span class="o">&lt;-</span> <span class="nb">string</span><span class="p">(</span><span class="nx">inflated</span><span class="p">[</span><span class="mi">16</span><span class="p">:</span><span class="nx">l</span><span class="p">])</span>
		<span class="k">case</span> <span class="s">&#34;SEND_GIFT&#34;</span><span class="p">:</span>
			<span class="nx">p</span><span class="p">.</span><span class="nx">GiftSrc</span> <span class="o">&lt;-</span> <span class="nb">string</span><span class="p">(</span><span class="nx">inflated</span><span class="p">[</span><span class="mi">16</span><span class="p">:</span><span class="nx">l</span><span class="p">])</span>
		<span class="k">case</span> <span class="s">&#34;WELCOME&#34;</span><span class="p">,</span> <span class="s">&#34;WELCOME_GUARD&#34;</span><span class="p">:</span>
			<span class="nx">p</span><span class="p">.</span><span class="nx">WelCome</span> <span class="o">&lt;-</span> <span class="nb">string</span><span class="p">(</span><span class="nx">inflated</span><span class="p">[</span><span class="mi">16</span><span class="p">:</span><span class="nx">l</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="nx">inflated</span> <span class="p">=</span> <span class="nx">inflated</span><span class="p">[</span><span class="nx">l</span><span class="p">:]</span>
<span class="p">}</span>

<span class="c1">// 返回十六进制字节数组表示数的十进制形式
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">ByteArrToDecimal</span><span class="p">(</span><span class="nx">src</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">sum</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">src</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>
    <span class="c1">// 将读取的十进制字节数组数据编码为字符串，再转换为字节数组，方便后续进行逐字节处理
</span><span class="c1"></span>	<span class="nx">b</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">hex</span><span class="p">.</span><span class="nf">EncodeToString</span><span class="p">(</span><span class="nx">src</span><span class="p">))</span>
	<span class="nx">l</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
    <span class="c1">// 从低位开始
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">base</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Pow</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">l</span><span class="o">-</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
		<span class="kd">var</span> <span class="nx">mul</span> <span class="kt">int</span>
		<span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">97</span> <span class="p">{</span>
			<span class="nx">mul</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">-</span> <span class="mi">87</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">mul</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">-</span> <span class="mi">48</span>
		<span class="p">}</span>

		<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">base</span> <span class="o">*</span> <span class="nx">mul</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div><p>其余的与 Qml 进行通信的第三方包用的是 qamel，也可以使用比较广泛，功能大而全的 therecipe/qt ，是因为这个库比较小巧，安装使用简单，所以采用了这个。通信部分非常简单，就是使用了信号和插槽，整个程序包括了弹幕礼物进场点歌功能一共 500+ 行，有些代码略冗余，还需要凝练。如果大家有任何想法都可以跟我交流，不限于博客写法，代码规范，开发思路等等，欢迎！</p>
<h2 id="总结">总结</h2>
<p>其实从有这个程序的想法到现在落地开发完成，也是走了不少的弯路的。一开始以为那些被压缩了的“乱码”是被加密的结果，自己又配置了 <code>sslkey.log</code>文件使用 Wireshark 解密，结果自然是白忙活一场。关键还是还是协议分析这块不够熟练，对网络理解不够。还有在连接弹幕服务器的时候尝试使用了 net 包下 net.Dial 进行通信，结果报错 <code>GetInfoW</code> 方法类找不到，当时只知道 ws 是基于 tcp，后来才知道单纯 tcp 根本无法与 ws 服务器连接，这一点说到底还是自己对连接过程理解不够。经过这个小项目，让自己对网络这一块的重要程度有了新的认识，决定要好好学习这些内容，还有 Go 语言的实操，协程池的使用，与 Qml 的通信。总体来说收获还是不小，以后还是要多上手练习。</p>
]]></content></item><item><title>Go语言net/url包源码初探</title><link>https://kcode.icu/posts/chore/go-net-url%E5%8C%85%E6%BA%90%E7%A0%81%E5%88%9D%E6%8E%A2/</link><pubDate>Wed, 11 Mar 2020 22:49:51 +0000</pubDate><guid>https://kcode.icu/posts/chore/go-net-url%E5%8C%85%E6%BA%90%E7%A0%81%E5%88%9D%E6%8E%A2/</guid><description>问题起因 问题的起因是最近需要写一个小工具，期间因为需要自己在服务器上搭建了一个 Web 服务来提供 RESTful API 接口，在请求接口的时候需要拼接 url，没有考虑到部分字符的编码问题，导致 400 Bad Request 错误。原来使用的是这样：
url := fmt.Sprintf(&amp;#34;%ssearch?keywords=%s %s&amp;amp;limit=1&amp;#34;, Mp3Server, name, singer) resp,err := http.Get(url) ...... 这个 name 和 singer 都有可能是中文，直接请求服务器无法识别，所以导致 400 无效请求的错误。后来改成这样，就成功了：
q := url.Values{} q.Set(&amp;#34;keywords&amp;#34;, name+&amp;#34; &amp;#34;+singer) q.Set(&amp;#34;limit&amp;#34;, &amp;#34;1&amp;#34;) u := url.URL{ Scheme: &amp;#34;http&amp;#34;, Host: &amp;#34;shiluo.design:3000&amp;#34;, Path: &amp;#34;search&amp;#34;, RawQuery: q.Encode(), // 关键在这 } resp, err := http.Get(u.String()) 问题解决的关键就是在 RawQuery: q.Encode() 。由于我一直有看源码的习惯，我就 ctrl+左键跟进去把处理逻辑看了几遍，收获不小，特别记录下来。
整体处理逻辑 整个方法的主逻辑过程：
// Encode encodes the values into ``URL encoded&amp;#39;&amp;#39; form // (&amp;#34;bar=baz&amp;amp;foo=quux&amp;#34;) sorted by key.</description><content type="html"><![CDATA[<h2 id="问题起因">问题起因</h2>
<p>问题的起因是最近需要写一个小工具，期间因为需要自己在服务器上搭建了一个 Web 服务来提供 RESTful API 接口，在请求接口的时候需要拼接 url，没有考虑到部分字符的编码问题，导致 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/400">400 Bad Request</a> 错误。原来使用的是这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">url</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%ssearch?keywords=%s %s&amp;limit=1&#34;</span><span class="p">,</span> <span class="nx">Mp3Server</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">singer</span><span class="p">)</span>
<span class="nx">resp</span><span class="p">,</span><span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
<span class="o">......</span>
</code></pre></div><p>这个 name 和 singer 都有可能是中文，直接请求服务器无法识别，所以导致 400 无效请求的错误。后来改成这样，就成功了：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">q</span> <span class="o">:=</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span><span class="p">{}</span>
<span class="nx">q</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;keywords&#34;</span><span class="p">,</span> <span class="nx">name</span><span class="o">+</span><span class="s">&#34; &#34;</span><span class="o">+</span><span class="nx">singer</span><span class="p">)</span>
<span class="nx">q</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;limit&#34;</span><span class="p">,</span> <span class="s">&#34;1&#34;</span><span class="p">)</span>
<span class="nx">u</span> <span class="o">:=</span> <span class="nx">url</span><span class="p">.</span><span class="nx">URL</span><span class="p">{</span>
	<span class="nx">Scheme</span><span class="p">:</span>   <span class="s">&#34;http&#34;</span><span class="p">,</span>
	<span class="nx">Host</span><span class="p">:</span>     <span class="s">&#34;shiluo.design:3000&#34;</span><span class="p">,</span>
	<span class="nx">Path</span><span class="p">:</span>     <span class="s">&#34;search&#34;</span><span class="p">,</span>
	<span class="nx">RawQuery</span><span class="p">:</span> <span class="nx">q</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(),</span> 				<span class="c1">// 关键在这
</span><span class="c1"></span><span class="p">}</span>

<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">u</span><span class="p">.</span><span class="nf">String</span><span class="p">())</span>
</code></pre></div><p>问题解决的关键就是在 <code>RawQuery: q.Encode()</code> 。由于我一直有看源码的习惯，我就 ctrl+左键跟进去把处理逻辑看了几遍，收获不小，特别记录下来。</p>
<h2 id="整体处理逻辑">整体处理逻辑</h2>
<p>整个方法的主逻辑过程：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Encode encodes the values into ``URL encoded&#39;&#39; form
</span><span class="c1">// (&#34;bar=baz&amp;foo=quux&#34;) sorted by key.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Values</span><span class="p">)</span> <span class="nf">Encode</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&#34;&#34;</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">buf</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Builder</span>
	<span class="nx">keys</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">v</span> <span class="p">{</span>
		<span class="nx">keys</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">keys</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nf">Strings</span><span class="p">(</span><span class="nx">keys</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">k</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">keys</span> <span class="p">{</span>
		<span class="nx">vs</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span>
		<span class="nx">keyEscaped</span> <span class="o">:=</span> <span class="nf">QueryEscape</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">vs</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">buf</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">buf</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39;&amp;&#39;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">buf</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">keyEscaped</span><span class="p">)</span>
			<span class="nx">buf</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39;=&#39;</span><span class="p">)</span>
			<span class="nx">buf</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nf">QueryEscape</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">buf</span><span class="p">.</span><span class="nf">String</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>其最终目的是把类似 <code>http://shiluo.design:3000/search?keywords=海阔天空 beyond&amp;limit=1</code> 这种的 URL 编码为服务器可识别的 <code>http://shiluo.design:3000/search?keywords=%E6%AD%8C%E6%9B%B2+%E6%AD%8C%E6%89%8B&amp;limit=1</code> 这种格式的 URL。</p>
<p>遍历的 vs 就是某个 key 对应的所有 value 值，<code>buf.WriteByte('&amp;')</code> 是在任何一次写入后追加 &amp; 连接查询字符串。我们重点关注最后一行代码 <code>buf.WriteString(QueryEscape(v))</code> 。</p>
<h2 id="深入剖析">深入剖析</h2>
<blockquote>
<p>Values 是自定义的 type Values map[string][]string</p>
</blockquote>
<p>处理过程是：判断 Values 是否为空，如果是返回空字符串。设置一个 Builder 用来构建未来需要返回的字符串。由于 url 的 query string 查询时一个 key 允许有多个 value，所以遍历每个 key 的所有value值，判定 key 值中是否有需要转义的字符，拿到转义处理后的字符串，然后通过 <code>buf.WriteString(keyEscaped)</code> 和 <code>buf.WriteByte('=')</code> 写入<strong>一对 key-value 键值对</strong> 。也就是说 key 判断转义了一次，它下面的 n 个 value 都判断转义了一次，最终<strong>处理完一个 key 时，写入了 n 对键值对</strong> 。其实最核心的逻辑在 <code>QueryEscape()</code> 这个函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// QueryEscape escapes the string so it can be safely placed
</span><span class="c1">// inside a URL query.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">QueryEscape</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">escape</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">encodeQueryComponent</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">escape</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">mode</span> <span class="nx">encoding</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">spaceCount</span><span class="p">,</span> <span class="nx">hexCount</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">c</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="k">if</span> <span class="nf">shouldEscape</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">mode</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">mode</span> <span class="o">==</span> <span class="nx">encodeQueryComponent</span> <span class="p">{</span>
				<span class="nx">spaceCount</span><span class="o">++</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">hexCount</span><span class="o">++</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">spaceCount</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">hexCount</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">s</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">buf</span> <span class="p">[</span><span class="mi">64</span><span class="p">]</span><span class="kt">byte</span>
	<span class="kd">var</span> <span class="nx">t</span> <span class="p">[]</span><span class="kt">byte</span>

	<span class="nx">required</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="nx">hexCount</span>
	<span class="k">if</span> <span class="nx">required</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">t</span> <span class="p">=</span> <span class="nx">buf</span><span class="p">[:</span><span class="nx">required</span><span class="p">]</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">t</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">required</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">hexCount</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">copy</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span> <span class="p">{</span>
				<span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="sc">&#39;+&#39;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">c</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">mode</span> <span class="o">==</span> <span class="nx">encodeQueryComponent</span><span class="p">:</span>
			<span class="nx">t</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="sc">&#39;+&#39;</span>
			<span class="nx">j</span><span class="o">++</span>
		<span class="k">case</span> <span class="nf">shouldEscape</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">mode</span><span class="p">):</span>
			<span class="nx">t</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="sc">&#39;%&#39;</span>
			<span class="nx">t</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">upperhex</span><span class="p">[</span><span class="nx">c</span><span class="o">&gt;&gt;</span><span class="mi">4</span><span class="p">]</span>
			<span class="nx">t</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="nx">upperhex</span><span class="p">[</span><span class="nx">c</span><span class="o">&amp;</span><span class="mi">15</span><span class="p">]</span>
			<span class="nx">j</span> <span class="o">+=</span> <span class="mi">3</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="nx">t</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
			<span class="nx">j</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Return true if the specified character should be escaped when
</span><span class="c1">// appearing in a URL string, according to RFC 3986.
</span><span class="c1">//
</span><span class="c1">// Please be informed that for now shouldEscape does not check all
</span><span class="c1">// reserved characters correctly. See golang.org/issue/5684.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">shouldEscape</span><span class="p">(</span><span class="nx">c</span> <span class="kt">byte</span><span class="p">,</span> <span class="nx">mode</span> <span class="nx">encoding</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// §2.3 Unreserved characters (alphanum)
</span><span class="c1"></span>	<span class="k">if</span> <span class="sc">&#39;a&#39;</span> <span class="o">&lt;=</span> <span class="nx">c</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span> <span class="o">&lt;=</span> <span class="sc">&#39;z&#39;</span> <span class="o">||</span> <span class="sc">&#39;A&#39;</span> <span class="o">&lt;=</span> <span class="nx">c</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span> <span class="o">&lt;=</span> <span class="sc">&#39;Z&#39;</span> <span class="o">||</span> <span class="sc">&#39;0&#39;</span> <span class="o">&lt;=</span> <span class="nx">c</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">mode</span> <span class="o">==</span> <span class="nx">encodeHost</span> <span class="o">||</span> <span class="nx">mode</span> <span class="o">==</span> <span class="nx">encodeZone</span> <span class="p">{</span>
		<span class="c1">// mode 不符合，与这段代码无关....
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="k">switch</span> <span class="nx">c</span> <span class="p">{</span>
	<span class="k">case</span> <span class="sc">&#39;-&#39;</span><span class="p">,</span> <span class="sc">&#39;_&#39;</span><span class="p">,</span> <span class="sc">&#39;.&#39;</span><span class="p">,</span> <span class="sc">&#39;~&#39;</span><span class="p">:</span> <span class="c1">// §2.3 Unreserved characters (mark)
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">false</span>

	<span class="k">case</span> <span class="sc">&#39;$&#39;</span><span class="p">,</span> <span class="sc">&#39;&amp;&#39;</span><span class="p">,</span> <span class="sc">&#39;+&#39;</span><span class="p">,</span> <span class="sc">&#39;,&#39;</span><span class="p">,</span> <span class="sc">&#39;/&#39;</span><span class="p">,</span> <span class="sc">&#39;:&#39;</span><span class="p">,</span> <span class="sc">&#39;;&#39;</span><span class="p">,</span> <span class="sc">&#39;=&#39;</span><span class="p">,</span> <span class="sc">&#39;?&#39;</span><span class="p">,</span> <span class="sc">&#39;@&#39;</span><span class="p">:</span> <span class="c1">// §2.2 Reserved characters (reserved)
</span><span class="c1"></span>		<span class="c1">// Different sections of the URL allow a few of
</span><span class="c1"></span>		<span class="c1">// the reserved characters to appear unescaped.
</span><span class="c1"></span>		<span class="k">switch</span> <span class="nx">mode</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">encodePath</span><span class="p">:</span> <span class="c1">// §3.3
</span><span class="c1"></span>			<span class="c1">// The RFC allows : @ &amp; = + $ but saves / ; , for assigning
</span><span class="c1"></span>			<span class="c1">// meaning to individual path segments. This package
</span><span class="c1"></span>			<span class="c1">// only manipulates the path as a whole, so we allow those
</span><span class="c1"></span>			<span class="c1">// last three as well. That leaves only ? to escape.
</span><span class="c1"></span>			<span class="k">return</span> <span class="nx">c</span> <span class="o">==</span> <span class="sc">&#39;?&#39;</span>

		<span class="k">case</span> <span class="nx">encodePathSegment</span><span class="p">:</span> <span class="c1">// §3.3
</span><span class="c1"></span>			<span class="c1">// The RFC allows : @ &amp; = + $ but saves / ; , for assigning
</span><span class="c1"></span>			<span class="c1">// meaning to individual path segments.
</span><span class="c1"></span>			<span class="k">return</span> <span class="nx">c</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span> <span class="o">||</span> <span class="nx">c</span> <span class="o">==</span> <span class="sc">&#39;;&#39;</span> <span class="o">||</span> <span class="nx">c</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span> <span class="o">||</span> <span class="nx">c</span> <span class="o">==</span> <span class="sc">&#39;?&#39;</span>

		<span class="k">case</span> <span class="nx">encodeUserPassword</span><span class="p">:</span> <span class="c1">// §3.2.1
</span><span class="c1"></span>			<span class="c1">// The RFC allows &#39;;&#39;, &#39;:&#39;, &#39;&amp;&#39;, &#39;=&#39;, &#39;+&#39;, &#39;$&#39;, and &#39;,&#39; in
</span><span class="c1"></span>			<span class="c1">// userinfo, so we must escape only &#39;@&#39;, &#39;/&#39;, and &#39;?&#39;.
</span><span class="c1"></span>			<span class="c1">// The parsing of userinfo treats &#39;:&#39; as special so we must escape
</span><span class="c1"></span>			<span class="c1">// that too.
</span><span class="c1"></span>			<span class="k">return</span> <span class="nx">c</span> <span class="o">==</span> <span class="sc">&#39;@&#39;</span> <span class="o">||</span> <span class="nx">c</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span> <span class="o">||</span> <span class="nx">c</span> <span class="o">==</span> <span class="sc">&#39;?&#39;</span> <span class="o">||</span> <span class="nx">c</span> <span class="o">==</span> <span class="sc">&#39;:&#39;</span>

		<span class="k">case</span> <span class="nx">encodeQueryComponent</span><span class="p">:</span> <span class="c1">// §3.4
</span><span class="c1"></span>			<span class="c1">// The RFC reserves (so we must escape) everything.
</span><span class="c1"></span>			<span class="k">return</span> <span class="kc">true</span>

		<span class="k">case</span> <span class="nx">encodeFragment</span><span class="p">:</span> <span class="c1">// §4.1
</span><span class="c1"></span>			<span class="c1">// The RFC text is silent but the grammar allows
</span><span class="c1"></span>			<span class="c1">// everything, so escape nothing.
</span><span class="c1"></span>			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">mode</span> <span class="o">==</span> <span class="nx">encodeFragment</span> <span class="p">{</span>
		<span class="c1">// mode 不符合，与这段代码无关....
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="c1">// Everything else must be escaped.
</span><span class="c1"></span>	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></div><p>这个函数判断了<strong>哪些字符需要转义，并对这些字符进行处理</strong>。这里就举例说明一下 <code>http://shiluo.design:3000/search?keywords=海阔天空 beyond&amp;limit=1</code> 这个 keywords 参数的转换过程，因为其包含了中文字符和空格。</p>
<p>首先通过包裹了 <code>escape</code> 通过参数 mode 将过滤类型设置为 <strong>URL 编码类型</strong> 。<code>shouldEscape(c,mode)</code> 判定哪些字符需要转义，里面根据 RFC 规范进行了各种判断就是为了找出必须要转义的字符。</p>
<p>首先是大小写字母和一些规范内的正常字符是不需要转义的，其余的比如我们参数中的中文和空格都不在这些字符内，所以最终不满足任何一种条件，返回 true，也就是需要转义。所以遍历过“海阔天空 beyond”这个 value 后，统计出来的 hex 值是 4,space 值是 1。</p>
<p>因为一个汉字例如“海”转义后是“%E6”，由原来的一个字节变为了三个字节，所以要根据上面统计出来的 hex 值扩大容量。如果 buf 能够容纳就直接获取，否则使用 make 重新分配内存。最终遍历“海阔天空 beyond”这个字符串，<code>j</code> 是用来移动数组下标的。</p>
<blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">upperhex</span> <span class="p">=</span> <span class="s">&#34;0123456789ABCDEF&#34;</span>
</code></pre></div></blockquote>
<p><strong>过程如下</strong>：“海”是需要转义的，所以将第一个字符设置为 %，紧接着取“海”这个字占用的字节数组 [230 181 183] 的第一位s[0] 230 右移4位是 14 对应是 ‘E’。第二位是和 15 按位与，结果是6，然后将下标指针向后移动三位，指向下一个存储位置。处理这个过程直到遇到空格，然后将空格替换为'+'，后面的英文正常不变，处理完成。</p>
<p><strong>最终我们可以看出，所谓转义就是取这个字符字节数组的第一位，按照一定规则将这个字符转换为十六进制的过程。所以到这里也很容易理解为什么我之前这样拼接 URL 会导致错误，之前一直没发现问题也可能是因为拼接的都是英文字符。</strong></p>
<p>最后，每次看完官方的某些代码还是不得不感叹处理逻辑的紧密，考虑之周到。还是要多多看别人源码，不断学习。</p>
]]></content></item><item><title>Go+QML开发的跨平台桌面直播助手[上]</title><link>https://kcode.icu/posts/b%E7%AB%99%E7%9B%B4%E6%92%AD%E5%8A%A9%E6%89%8B%E5%BC%80%E5%8F%91%E4%B8%8A/</link><pubDate>Thu, 05 Mar 2020 15:45:13 +0000</pubDate><guid>https://kcode.icu/posts/b%E7%AB%99%E7%9B%B4%E6%92%AD%E5%8A%A9%E6%89%8B%E5%BC%80%E5%8F%91%E4%B8%8A/</guid><description>B站直播协议分析 上篇介绍协议分析，下篇介绍开发思路。
项目缘由 假期在家，群里有几个朋友决定尝个新鲜开直播娱乐一下，后来发现B站官方提供的直播姬只有弹幕显示功能，并没有点歌等其他自定义功能，网上的项目也比较少，而且一些点歌机不维护了导致功能有缺陷，因此打算开发一个自定义的具有多功能的直播助手，初步包含弹幕礼物显示，点歌等功能。
开发的思路是分析传输二进制包，从中找出我们想要的数据，以我们想要的方式显示出来。
总体过程 随便打开一个直播间，按 F12，切换到 Network 的 WS 栏。可以看到它是首先连接弹幕服务器，并且通过观察发现这个地址并不是固定的（应该是负载均衡的结果）。
然后发送一个握手包，携带了 Roomid，访问者 id，客户端版本等信息，最后还有一个 key，后来观察发现是通过请求某个接口获取的这个 key 值（就是 token）。
重点就是分析协议包。不管是接收还是发送的二进制包都有一个固定大小 16 字节的首部。这个首部的组成我用一个表格来表示：
偏移 长度 内容 0 4 包的大小 4 4 未知（目前和分析无关） 8 4 包类型 12 4 未知（目前和分析无关） 除了首部之外的就是携带的数据部分了。在这里需要注意的一点是，由于瞬时信息量可能会很大，会把若干个包压缩为一个包发送，这个包组成是《包首部-包主体-下一个包首部-下一个包主体-&amp;hellip;..等等》，而且因为包类型为 5 的数量最多，传输信息量会很大，所以是用 gzip 压缩了的，这里要注意。这里随手拿一个包举例：
...G............{&amp;#34;cmd&amp;#34;:&amp;#34;DANMU_MSG&amp;#34;,&amp;#34;info&amp;#34;:[[0,1,25,8322816,1584073975908,1584073720,0,&amp;#34;7905c3d4&amp;#34;,0,0,0],&amp;#34;(=・ω・=)&amp;#34;,[14006391,&amp;#34;桥本环零&amp;#34;,0,1,0,10000,1,&amp;#34;&amp;#34;],[17,&amp;#34;小糕兔&amp;#34;,&amp;#34;娜可糕糕&amp;#34;,294526,16752445,&amp;#34;&amp;#34;,0],[47,0,16746162,10074],[&amp;#34;title-179-1&amp;#34;,&amp;#34;title-179-1&amp;#34;],0,0,null,{&amp;#34;ts&amp;#34;:1584073975,&amp;#34;ct&amp;#34;:&amp;#34;B0A7DFE4&amp;#34;},0,0,null,null,0]}...h............{&amp;#34;cmd&amp;#34;:&amp;#34;DANMU_MSG&amp;#34;,&amp;#34;info&amp;#34;:[[0,1,25,16777215,1584073975938,1584073264,0,&amp;#34;21635747&amp;#34;,0,0,0],&amp;#34;包砸是我关注的up里唯一一个很可爱的&amp;#34;,[339865528,&amp;#34;兰博基尼鬼怪&amp;#34;,0,0,0,10000,1,&amp;#34;&amp;#34;],[3,&amp;#34;包崽铺&amp;#34;,&amp;#34;喝薄荷奶绿&amp;#34;,1506599,6406234,&amp;#34;&amp;#34;,0],[10,0,9868950,&amp;#34;\u003e50000&amp;#34;],[&amp;#34;&amp;#34;,&amp;#34;&amp;#34;],0,0,null,{&amp;#34;ts&amp;#34;:1584073975,&amp;#34;ct&amp;#34;:&amp;#34;657DC663&amp;#34;},0,0,null,null,0]} 可以看到这里就是瞬时有两条弹幕，变为了一个包。每个包都有自己的头部，可以自行格式化一下。
也不是所有类型为 5 的包都被压缩，只有某些可能数据量很大才会被压缩，比如 DANMU_MSG，SEND_GIFT 等，并且类型为 5 的可能是用户弹幕，礼物，贵宾进场，房间关注变动等，就是依靠 “cmd” 这个字段值来判别的，目前我已知的 cmd 有这么几种，可以根据需求来利用：</description><content type="html"><![CDATA[<h1 id="b站直播协议分析">B站直播协议分析</h1>
<blockquote>
<p>上篇介绍协议分析，下篇介绍开发思路。</p>
</blockquote>
<h2 id="项目缘由">项目缘由</h2>
<p>假期在家，群里有几个朋友决定尝个新鲜开直播娱乐一下，后来发现B站官方提供的直播姬只有弹幕显示功能，并没有点歌等其他自定义功能，网上的项目也比较少，而且一些点歌机不维护了导致功能有缺陷，因此打算开发一个自定义的具有多功能的直播助手，初步包含弹幕礼物显示，点歌等功能。</p>
<p>开发的思路是<strong>分析传输二进制包，从中找出我们想要的数据，以我们想要的方式显示出来。</strong></p>
<h2 id="总体过程">总体过程</h2>
<p>随便打开一个直播间，按 F12，切换到 Network 的 WS 栏。可以看到它是首先连接弹幕服务器，并且通过观察发现这个地址并不是固定的（应该是负载均衡的结果）。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/image-20210125220539933.png" alt="wss链接"></p>
<p>然后发送一个握手包，携带了 Roomid，访问者 id，客户端版本等信息，最后还有一个 key，后来观察发现是通过请求某个接口获取的这个 key 值（就是 token）。</p>
<p><img src="https://gitee.com/sh1luo/imgs/raw/master/imgs/image-20210125220806540.png" alt="握手包"></p>
<p>重点就是分析协议包。不管是接收还是发送的二进制包都有一个固定大小 16 字节的首部。这个首部的组成我用一个表格来表示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">偏移</th>
<th style="text-align:center">长度</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">4</td>
<td style="text-align:center">包的大小</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">未知（目前和分析无关）</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">4</td>
<td style="text-align:center">包类型</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">4</td>
<td style="text-align:center">未知（目前和分析无关）</td>
</tr>
</tbody>
</table>
<p>除了首部之外的就是携带的数据部分了。在这里需要注意的一点是，<strong>由于瞬时信息量可能会很大，会把若干个包压缩为一个包发送，这个包组成是《包首部-包主体-下一个包首部-下一个包主体-&hellip;..等等》</strong>，而且因为包类型为 5 的数量最多，传输信息量会很大，所以是用 gzip 压缩了的，这里要注意。这里随手拿一个包举例：</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="err">...G............</span><span class="p">{</span><span class="nt">&#34;cmd&#34;</span><span class="p">:</span><span class="s2">&#34;DANMU_MSG&#34;</span><span class="p">,</span><span class="nt">&#34;info&#34;</span><span class="p">:[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">8322816</span><span class="p">,</span><span class="mi">1584073975908</span><span class="p">,</span><span class="mi">1584073720</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="s2">&#34;7905c3d4&#34;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="s2">&#34;(=・ω・=)&#34;</span><span class="p">,[</span><span class="mi">14006391</span><span class="p">,</span><span class="s2">&#34;桥本环零&#34;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">10000</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s2">&#34;&#34;</span><span class="p">],[</span><span class="mi">17</span><span class="p">,</span><span class="s2">&#34;小糕兔&#34;</span><span class="p">,</span><span class="s2">&#34;娜可糕糕&#34;</span><span class="p">,</span><span class="mi">294526</span><span class="p">,</span><span class="mi">16752445</span><span class="p">,</span><span class="s2">&#34;&#34;</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">47</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">16746162</span><span class="p">,</span><span class="mi">10074</span><span class="p">],[</span><span class="s2">&#34;title-179-1&#34;</span><span class="p">,</span><span class="s2">&#34;title-179-1&#34;</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="kc">null</span><span class="p">,{</span><span class="nt">&#34;ts&#34;</span><span class="p">:</span><span class="mi">1584073975</span><span class="p">,</span><span class="nt">&#34;ct&#34;</span><span class="p">:</span><span class="s2">&#34;B0A7DFE4&#34;</span><span class="p">},</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">0</span><span class="p">]}</span><span class="err">...h............</span><span class="p">{</span><span class="nt">&#34;cmd&#34;</span><span class="p">:</span><span class="s2">&#34;DANMU_MSG&#34;</span><span class="p">,</span><span class="nt">&#34;info&#34;</span><span class="p">:[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">16777215</span><span class="p">,</span><span class="mi">1584073975938</span><span class="p">,</span><span class="mi">1584073264</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="s2">&#34;21635747&#34;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="s2">&#34;包砸是我关注的up里唯一一个很可爱的&#34;</span><span class="p">,[</span><span class="mi">339865528</span><span class="p">,</span><span class="s2">&#34;兰博基尼鬼怪&#34;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">10000</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s2">&#34;&#34;</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="s2">&#34;包崽铺&#34;</span><span class="p">,</span><span class="s2">&#34;喝薄荷奶绿&#34;</span><span class="p">,</span><span class="mi">1506599</span><span class="p">,</span><span class="mi">6406234</span><span class="p">,</span><span class="s2">&#34;&#34;</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">9868950</span><span class="p">,</span><span class="s2">&#34;\u003e50000&#34;</span><span class="p">],[</span><span class="s2">&#34;&#34;</span><span class="p">,</span><span class="s2">&#34;&#34;</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="kc">null</span><span class="p">,{</span><span class="nt">&#34;ts&#34;</span><span class="p">:</span><span class="mi">1584073975</span><span class="p">,</span><span class="nt">&#34;ct&#34;</span><span class="p">:</span><span class="s2">&#34;657DC663&#34;</span><span class="p">},</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">0</span><span class="p">]}</span>
</code></pre></div><p>可以看到这里就是瞬时有两条弹幕，变为了一个包。每个包都有自己的头部，可以自行格式化一下。</p>
<p>也<strong>不是所有类型为 5 的包都被压缩</strong>，只有某些可能数据量很大才会被压缩，比如 DANMU_MSG，SEND_GIFT 等，并且类型为 5 的可能是用户弹幕，礼物，贵宾进场，房间关注变动等，就是依靠 “cmd” 这个字段值来判别的，目前我已知的 cmd 有这么几种，可以根据需求来利用：</p>
<table>
<thead>
<tr>
<th style="text-align:center">cmd</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">DANMU_MSG</td>
<td style="text-align:center">用户弹幕</td>
</tr>
<tr>
<td style="text-align:center">WELCOME</td>
<td style="text-align:center">Vip，Svip进场（<strong>标注1</strong>）</td>
</tr>
<tr>
<td style="text-align:center">WELCOME_GUARD</td>
<td style="text-align:center">房管进场</td>
</tr>
<tr>
<td style="text-align:center">ENTRY_EFFECT</td>
<td style="text-align:center">提督，总督等头衔</td>
</tr>
<tr>
<td style="text-align:center">SEND_GIFT</td>
<td style="text-align:center">用户礼物</td>
</tr>
<tr>
<td style="text-align:center">COMBO_SEND</td>
<td style="text-align:center">礼物连击</td>
</tr>
<tr>
<td style="text-align:center">COMBO_END</td>
<td style="text-align:center">连击结束（<strong>标注2</strong>）</td>
</tr>
<tr>
<td style="text-align:center">ROOMD_RANK</td>
<td style="text-align:center">这个不太清楚是什么</td>
</tr>
<tr>
<td style="text-align:center">NOTICE_MSG</td>
<td style="text-align:center">所有直播间的通告消息</td>
</tr>
</tbody>
</table>
<blockquote>
<p>标注 1: 我不太了解 B 站 Vip 的等级划分，我仅知道提督，总督等，还有老爷这些，其他不知道了，老爷是被划分到这一栏的。</p>
</blockquote>
<blockquote>
<p>标注 2: 如果送礼物连击是会有和《SEND_GIFT》不一样的特效的，连击结束也有提示，所以分开了。</p>
</blockquote>
<p>这里给出一些用到的接口，后续可能会更新失效，F12 打开找即可，截止博客发出时均有效。</p>
<table>
<thead>
<tr>
<th style="text-align:center">URL</th>
<th style="text-align:center">参数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="http://api.live.bilibili.com/room/v1/Room/room_init">http://api.live.bilibili.com/room/v1/Room/room_init</a></td>
<td style="text-align:center">id</td>
<td style="text-align:center">查询房间短id，长id等信息</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://api.live.bilibili.com/room/v1/Danmu/getConf">https://api.live.bilibili.com/room/v1/Danmu/getConf</a></td>
<td style="text-align:center">room_id=xxx&amp;platform=pc&amp;player=web</td>
<td style="text-align:center">查询可用弹幕服务器列表，握手包的key</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://api.bilibili.com/x/space/acc/info">https://api.bilibili.com/x/space/acc/info</a></td>
<td style="text-align:center">mid=382297465&amp;jsonp=jsonp</td>
<td style="text-align:center">根据userid查询用户个人信息</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://api.live.bilibili.com/xlive/web-room/v1/index/getInfoByRoom">https://api.live.bilibili.com/xlive/web-room/v1/index/getInfoByRoom</a></td>
<td style="text-align:center">room_id=xxx</td>
<td style="text-align:center">查询房间信息，标题等</td>
</tr>
</tbody>
</table>
<p>到这里其实就已经结束了，<strong>我们可以模拟连接某个弹幕服务器，然后按照要求发送握手包，随后一直接收信息，根据首部的类型 ID 可以判定不同的包，然后根据 cmd 字段判定消息类型，获取我们想要的字段值就可以了。再结合其他的一些接口就可以完整的获取直播间的各种信息了。</strong></p>
<p>分析完后，就可以根据流程去写程序了，下一节介绍如何使用 <a href="https://golang.org/">Go</a> 语言开发助手的后端部分。</p>
]]></content></item><item><title>超越代码的贡献:对于每一个人的开源</title><link>https://kcode.icu/posts/translation/20191204-contribute-beyond-code-open-source-for-everyone/</link><pubDate>Fri, 14 Feb 2020 21:21:55 +0000</pubDate><guid>https://kcode.icu/posts/translation/20191204-contribute-beyond-code-open-source-for-everyone/</guid><description>超越代码的贡献：对于每一个人的开源 开发者经常被鼓励去为开源做贡献。如果你不把自己当成一个开发者，那么踏上贡献这个旅程可能让人感到望而生畏。在过去的一年里，我发现参与开源 folk 的数量跌倒了谷底，这一定程度上与大家总是拿“但是我不是开发者”作为借口有关。在这篇文章中，我会分享一些关于为什么你应该为 Go OSS 项目做贡献，并且提供一些信息关于在哪贡献，包括一些额外的资源让你开始。
你为什么应该贡献开源项目？ 参与开源是一份保持给予的礼物。每一个人都有他们的动机，但是以一个积极的角色和社区联系起来的好处包括：
提高学习和开发技巧。 你能够在与绩效评估无关的角色中练习合作技巧。并且由你工作之外的兴趣所驱动，你会发展出其他的技能。 构建和提高知名度。 你的雇主会受益于你参与了开源社区。你可以找到新的工作机会和潜在的同事。 你需要什么？ 首先，弄清楚你的雇主对于开源贡献的政策并且审查一下你的雇佣协议。虽然我认为每一个使用开源软件的公司都应该给他们的雇员一些时间去做贡献，但是开源政策经常有问题，尽管个体贡献在个人时间和个人设备的环境下。如果你的公司还没有一个政策（或者有一个受限的政策），我分享的 A Model IP and Open Source Contribution Policy 可能对于向你提供引导，去改善这个情况有帮助。
特殊的软件需求会基于项目千变万化。对于一个还未实现这些实践的项目来说，你在基础设施方面（例如代码和配置持续部署管道）的技巧可能会十分有帮助。你在这些领域的经验可能会改变软件需求的方向；比如，某个特殊版本的 docker 和云 CLI 工具。
如果你从未提交过 PR ，first-contributions project 有排练功能，作为这个仓库的一部分。每一个项目都会有一个工作流，并且可能会有多个不同的推荐，关于如何去提交一个 PR 。在这里学习基础知识对
你十分有帮助，比在一个你感兴趣的项目上从 0 开始要好得多。
什么样的贡献？ 除了开发功能外，贡献的领域还包括：
指导
文档（包括为社区活动写博客文章，比如Gopher Academy Advent 或者 liveblogging for GopherCon）
架构图
CI/CD 管道
基础设施代码
维护测试</description><content type="html"><![CDATA[<h1 id="超越代码的贡献对于每一个人的开源">超越代码的贡献：对于每一个人的开源</h1>
<p>开发者经常被鼓励去为开源做贡献。如果你不把自己当成一个开发者，那么踏上贡献这个旅程可能让人感到望而生畏。在过去的一年里，我发现参与开源 folk 的数量跌倒了谷底，这一定程度上与大家总是拿“但是我不是开发者”作为借口有关。在这篇文章中，我会分享一些关于为什么你应该为 Go OSS 项目做贡献，并且提供一些信息关于在哪贡献，包括一些额外的资源让你开始。</p>
<h2 id="你为什么应该贡献开源项目">你为什么应该贡献开源项目？</h2>
<p>参与开源是一份保持给予的礼物。每一个人都有他们的动机，但是以一个积极的角色和社区联系起来的好处包括：</p>
<ul>
<li><strong>提高学习和开发技巧。</strong> 你能够在与绩效评估无关的角色中练习合作技巧。并且由你工作之外的兴趣所驱动，你会发展出其他的技能。</li>
<li><strong>构建和提高知名度。</strong> 你的雇主会受益于你参与了开源社区。你可以找到新的工作机会和潜在的同事。</li>
</ul>
<h2 id="你需要什么">你需要什么？</h2>
<p>首先，弄清楚你的雇主对于开源贡献的政策并且审查一下你的雇佣协议。虽然我认为每一个使用开源软件的公司都应该给他们的雇员一些时间去做贡献，但是开源政策经常有问题，尽管个体贡献在个人时间和个人设备的环境下。如果你的公司还没有一个政策（或者有一个受限的政策），我分享的  <a href="https://processmechanics.com/2015/07/22/a-model-ip-and-open-source-contribution-policy/">A Model IP and Open Source Contribution Policy</a> 可能对于向你提供引导，去改善这个情况有帮助。</p>
<p>特殊的软件需求会基于项目千变万化。对于一个还未实现这些实践的项目来说，你在基础设施方面（例如代码和配置持续部署管道）的技巧可能会十分有帮助。你在这些领域的经验可能会改变软件需求的方向；比如，某个特殊版本的 docker 和云 CLI 工具。</p>
<p>如果你从未提交过 PR ，<a href="https://github.com/firstcontributions/first-contributions">first-contributions project</a> 有排练功能，作为这个仓库的一部分。每一个项目都会有一个工作流，并且可能会有多个不同的推荐，关于如何去提交一个 PR 。在这里学习基础知识对</p>
<p>你十分有帮助，比在一个你感兴趣的项目上从 0 开始要好得多。</p>
<h2 id="什么样的贡献">什么样的贡献？</h2>
<p>除了开发功能外，贡献的领域还包括：</p>
<ul>
<li></li>
<li>
<p>指导</p>
</li>
<li>
<p>文档（包括为社区活动写博客文章，比如<a href="https://docs.google.com/spreadsheets/d/1f1ez2NBYNzqRc2NLeL4KZx4dDhp1UZFE4QT8ncDLph4/edit?usp=sharing">Gopher Academy Advent</a> 或者 <a href="https://about.sourcegraph.com/go/">liveblogging for GopherCon</a>）</p>
</li>
<li>
<p>架构图</p>
</li>
<li>
<p>CI/CD  管道</p>
</li>
<li>
<p>基础设施代码</p>
</li>
<li></li>
<li>
<p>维护测试</p>
</li>
<li>
<p>审查 PR</p>
</li>
<li>
<p>项目管理</p>
</li>
<li>
<p>支援其他的社区成员</p>
</li>
</ul>
<p>许多大项目会有贡献者峰会，允许个体见面并协作。比如，在这些峰会上，提供一个操作系统，设计，项目管理，测试或者安全方面的建议会帮助指导这个项目变得更加健壮和有弹性。</p>
<h2 id="什么项目">什么项目？</h2>
<hr>
<p>via：https://blog.gopheracademy.com/advent-2019/contribute-beyond-code/</p>
<p>作者：Jennifer Davis
译者：<a href="https://github.com/sh1luo">sh1luo</a>
校对：<a href="https://github.com/"></a></p>
<p>本文由 <a href="https://github.com/studygolang/GCTT">GCTT</a> 原创编译，<a href="https://studygolang.com/">Go中文网</a> 荣誉推出</p>
]]></content></item><item><title>Go语言内存管理与内存清理</title><link>https://kcode.icu/posts/translation/20191109-go-memory-management-and-memory-sweep/</link><pubDate>Fri, 14 Feb 2020 21:20:33 +0000</pubDate><guid>https://kcode.icu/posts/translation/20191109-go-memory-management-and-memory-sweep/</guid><description>Go：内存管理与内存清理 清理内存是一个过程，它能够让 Go 知道哪些内存段最近可用于分配。但是，它并不会使用将位置 0 的方式来清理内存。
将内存置0 将内存置 0 的过程 —— 就是把内存段中的所有位赋值为 0 —— 是在分配过程中即时执行的。
然后，第一个分配就开始了：
分配过程将会再一次出现，之后， GC 将会启动去释放不再被使用的内存。在标记期间，GC 会用一个位图gcmarkBits 来跟踪在使用中的内存。让我们通过我们运行的程序以相同的示例为例，在第一个块不再被使用的地方。
有关更多关于标记和着色阶段的信息，我建议你阅读我的这篇文章 Go：GC 是如何标记内存的？
现在，我们可以使用 gomarkBits精确查看可用于分配的内存。Go 现在也使用gomarkBits 代替了allocBits ，这个操作就是内存清理：
清理阶段 Go 提供了两种方式来清理内存：
使用一个工作程序在后台等待，一个一个的清理这些范围。 当分配需要一个范围的时候即时执行。 关于后台工作程序，当开始运行程序时，Go 将设置一个后台运行的 Worker（唯一的任务就是去清理内存），它将进入睡眠状态并等待内存段扫描：
与 GC 周期的冲突 正如之前看到的，由于后台只有一个 worker 在清理内存块，清理过程可能会花费一些时间。但是，我们可能想知道如果另一个 GC 周期在一次清理过程中启动会发生什么。在这种情况下，这个运行 GC 的 goroutine 就会在开始标记阶段前去协助完成剩余的清理工作。让我们举个例子看一下连续调用两次 GC，包含数千个对象的内存分配的过程。
via：来源链接
作者：Vincent Blanchon 译者：sh1luo 校对：[](https://github.com/
本文由 GCTT 原创编译，Go中文网 荣誉推出</description><content type="html"><![CDATA[<h1 id="go内存管理与内存清理">Go：内存管理与内存清理</h1>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191109-Go-Memory-Management-and-Memory-Sweep/01.png" alt=""></p>
<!-- raw HTML omitted -->
<p>清理内存是一个过程，它能够让 Go 知道哪些内存段最近可用于分配。但是，它并不会使用将位置 0 的方式来清理内存。</p>
<h2 id="将内存置0">将内存置0</h2>
<p>将内存置 0 的过程 —— 就是把内存段中的所有位赋值为 0 —— 是在分配过程中即时执行的。</p>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191109-Go-Memory-Management-and-Memory-Sweep/02.png" alt=""></p>
<!-- raw HTML omitted -->
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191109-Go-Memory-Management-and-Memory-Sweep/03.png" alt=""></p>
<!-- raw HTML omitted -->
<p>然后，第一个分配就开始了：</p>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191109-Go-Memory-Management-and-Memory-Sweep/04.png" alt=""></p>
<!-- raw HTML omitted -->
<p>分配过程将会再一次出现，之后， GC 将会启动去释放不再被使用的内存。在标记期间，GC 会用一个位图<code>gcmarkBits</code> 来跟踪在使用中的内存。让我们通过我们运行的程序以相同的示例为例，在第一个块不再被使用的地方。</p>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191109-Go-Memory-Management-and-Memory-Sweep/05.png" alt=""></p>
<!-- raw HTML omitted -->
<blockquote>
<p>有关更多关于标记和着色阶段的信息，我建议你阅读我的这篇文章 <a href="">Go：GC 是如何标记内存的？</a></p>
</blockquote>
<p>现在，我们可以使用 <code>gomarkBits</code>精确查看可用于分配的内存。Go 现在也使用<code>gomarkBits</code> 代替了<code>allocBits</code> ，这个操作就是内存清理：</p>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191109-Go-Memory-Management-and-Memory-Sweep/06.png" alt=""></p>
<!-- raw HTML omitted -->
<h2 id="清理阶段">清理阶段</h2>
<p>Go 提供了两种方式来清理内存：</p>
<ul>
<li>使用一个工作程序在后台等待，一个一个的清理这些范围。</li>
<li>当分配需要一个范围的时候即时执行。</li>
</ul>
<p>关于后台工作程序，当开始运行程序时，Go 将设置一个后台运行的 Worker（唯一的任务就是去清理内存），它将进入睡眠状态并等待内存段扫描：</p>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191109-Go-Memory-Management-and-Memory-Sweep/07.png" alt=""></p>
<!-- raw HTML omitted -->
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191109-Go-Memory-Management-and-Memory-Sweep/08.png" alt=""></p>
<!-- raw HTML omitted -->
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191109-Go-Memory-Management-and-Memory-Sweep/09.png" alt=""></p>
<!-- raw HTML omitted -->
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191109-Go-Memory-Management-and-Memory-Sweep/10.png" alt=""></p>
<!-- raw HTML omitted -->
<h2 id="与-gc-周期的冲突">与 GC 周期的冲突</h2>
<p>正如之前看到的，由于后台只有一个 worker 在清理内存块，清理过程可能会花费一些时间。但是，我们可能想知道如果另一个 GC 周期在一次清理过程中启动会发生什么。在这种情况下，这个运行 GC 的 goroutine 就会在开始标记阶段前去协助完成剩余的清理工作。让我们举个例子看一下连续调用两次 GC，包含数千个对象的内存分配的过程。</p>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191109-Go-Memory-Management-and-Memory-Sweep/11.png" alt=""></p>
<!-- raw HTML omitted -->
<hr>
<p>via：<a href="https://medium.com/a-journey-with-go/go-memory-management-and-memory-sweep-cc71b484de05">来源链接</a></p>
<p>作者：<a href="https://medium.com/@blanchon.vincent?source=post_page-----dbef99be2c35----------------------">Vincent Blanchon</a>
译者：<a href="https://github.com/sh1luo">sh1luo</a>
校对：[](<a href="https://github.com/">https://github.com/</a></p>
<p>本文由 <a href="https://github.com/studygolang/GCTT">GCTT</a> 原创编译，<a href="https://studygolang.com/">Go中文网</a> 荣誉推出</p>
]]></content></item><item><title>Go的GC是怎样监听你的应用的？</title><link>https://kcode.icu/posts/translation/20191002-go-how-does-the-garbage-collector-watch-your-application/</link><pubDate>Wed, 01 Jan 2020 20:43:19 +0000</pubDate><guid>https://kcode.icu/posts/translation/20191002-go-how-does-the-garbage-collector-watch-your-application/</guid><description>Go: GC 是怎样监听你的应用的？ Go 语言的垃圾收集器 （下文简称 GC ）能够帮助到开发者，通过自动地释放掉一些程序中不再需要使用的内存。但是，跟踪并清理掉这些内存也可能影响我们程序的性能。Go 语言的 GC 旨在实现 这些目标 并且关注如下几个问题：
当程序被终止时，尽可能多的减少在这两个阶段的 STW （的次数） 。 一个 GC 周期的时间要少于 10 毫秒。 一次 GC 周期不能占用超过 25% 的 CPU 资源。 这是一些很有挑战性的目标，如果 GC 从我们的程序中了解到足够多的信息，它就能去解决这些问题。
到达堆阈值 GC 将会关注的第一个指标是堆的使用增长。默认情况下，它将在堆大小加倍时运行。这是一个在循环中分配内存的简单程序。
func BenchmarkAllocationEveryMs(b *testing.B) { // need permanent allocation to clear see when the heap double its size var s *[]int tmp := make([]int, 1100000, 1100000) s = &amp;amp;tmp var a *[]int for i := 0; i &amp;lt; b.</description><content type="html"><![CDATA[<h1 id="go-gc-是怎样监听你的应用的">Go: GC 是怎样监听你的应用的？</h1>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191002-Go-How-Does-the-Garbage-Collector-Watch-Your-Application/1.png" alt=""></p>
<!-- raw HTML omitted -->
<p>Go 语言的垃圾收集器 （下文简称 GC ）能够帮助到开发者，通过自动地释放掉一些程序中不再需要使用的内存。但是，跟踪并清理掉这些内存也可能影响我们程序的性能。Go 语言的 GC 旨在实现 <a href="https://blog.golang.org/ismmkeynote">这些目标</a> 并且关注如下几个问题：</p>
<ul>
<li>当程序被终止时，尽可能多的减少在这两个阶段的 STW （的次数） 。</li>
<li>一个 GC 周期的时间要少于 10 毫秒。</li>
<li>一次 GC 周期不能占用超过 25% 的 CPU 资源。</li>
</ul>
<p>这是一些很有挑战性的目标，如果 GC 从我们的程序中了解到足够多的信息，它就能去解决这些问题。</p>
<h2 id="到达堆阈值">到达堆阈值</h2>
<p>GC 将会关注的第一个指标是堆的使用增长。默认情况下，它将在堆大小加倍时运行。这是一个在循环中分配内存的简单程序。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">BenchmarkAllocationEveryMs</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// need permanent allocation to clear see when the heap double its size
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="p">[]</span><span class="kt">int</span>
	<span class="nx">tmp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1100000</span><span class="p">,</span> <span class="mi">1100000</span><span class="p">)</span>
	<span class="nx">s</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">tmp</span>

	<span class="kd">var</span> <span class="nx">a</span> <span class="o">*</span><span class="p">[]</span><span class="kt">int</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span>  <span class="p">{</span>
		<span class="nx">tmp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>
		<span class="nx">a</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">tmp</span>

		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">_</span> <span class="p">=</span> <span class="nx">a</span>
	<span class="nx">runtime</span><span class="p">.</span><span class="nf">KeepAlive</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>追踪器向我们展示了 GC 什么时候被调用：</p>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191002-Go-How-Does-the-Garbage-Collector-Watch-Your-Application/2.png" alt=""></p>
<!-- raw HTML omitted -->
<pre><code>gc 8 @0.251s 0%: 0.004+0.11+0.003 ms clock, 0.036+0/0.10/0.15+0.028 ms cpu, 16-&gt;16-&gt;8 MB, 17 MB goal, 8 P

gc 9 @0.389s 0%: 0.005+0.11+0.007 ms clock, 0.041+0/0.090/0.11+0.062 ms cpu, 16-&gt;16-&gt;8 MB, 17 MB goal, 8 P

gc 10 @0.526s 0%: 0.046+0.24+0.014 ms clock, 0.37+0/0.14/0.23+0.11 ms cpu, 16-&gt;16-&gt;8 MB, 17 MB goal, 8 P
</code></pre><p>第九个循环就是我们之前看到的那个循环，运行在第 389 ms 。有意思的部分是 <code>16-&gt;16-&gt;8 MB</code> ，它展示了在 GC 被调用前堆使用的内存有多大，以及在 GC 执行后它们还剩下多少。我们可以清楚地看到，当第八个循环将堆大小减少到 8 MB 时，第九个 GC 周期将在 16 MB 时刻触发。</p>
<p>这个阈值的比例由环境变量 GOGC 决定，默认值为 100 % —— 也就是说，在堆的大小增加了一倍之后，GC 就会被调用。出于性能原因，并且为了避免经常启动一个循环，当堆的大小低于 4 MB * GOGC 的时候， GC 将不会被执行。——当 GOGC 被设置为 100 % 时，在堆内存低于 4 MB 时 GC 将不会被触发。</p>
<h2 id="到达时间阈值">到达时间阈值</h2>
<p>GC 关注的第二个指标是在两次 GC 之间的时间间隔。如果超过两分钟 GC 还未执行，那么就会强制启动一次 GC 循环。</p>
<p>由<code>GODEBUG</code> 给出的跟踪显示，两分钟后会强制启动一次循环。</p>
<pre><code>GC forced
gc 15 @121.340s 0%: 0.058+1.2+0.015 ms clock, 0.46+0/2.0/4.1+0.12 ms cpu, 1-&gt;1-&gt;1 MB, 4 MB goal, 8 P
</code></pre><h2 id="需要协助">需要协助</h2>
<p>GC 主要由两个主要阶段组成：</p>
<ul>
<li>标记仍在使用的内存</li>
<li>清理未标记为使用中的内存</li>
</ul>
<p>在标记期间，Go 必须确保 GC 标记内存的速度比新分配内存的速度更快。事实是，如果 GC 正在标记 4 MB 大小的内存，然而同时程序正在分配同样大小的内存，那么 GC 必须在完成后立即触发。</p>
<p>为了解决这个问题，Go 在标记内存的同时会跟踪新的内存分配，并关注 GC 何时过载。第一步在 GC 触发时执行，它会首先为每一个处理器准备一个 处于 sleep状态的goroutine，等待标记阶段。</p>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191002-Go-How-Does-the-Garbage-Collector-Watch-Your-Application/3.png" alt=""></p>
<!-- raw HTML omitted -->
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191002-Go-How-Does-the-Garbage-Collector-Watch-Your-Application/4.png" alt=""></p>
<!-- raw HTML omitted -->
<p>GC 现在已经能够去标记那些不再使用的变量。对于每一个被扫描到的变量，它会增加一个计数器，以便继续跟踪当前的工作并且也能够获得剩余工作的快照。当一个 goroutine 在 GC 期间被安排了任务，Go 将会比较所需要的分配和已经扫描到的，以便对比扫描的速度和分配的需求。如果比较的结果是扫描内容较多，那么当前的 goroutine 并不需要去提供帮助。换句话说，如果扫描与分配相比有所欠缺，那么 Go 就会使用 goroutine来协助。这有一个图表来反应这个逻辑：</p>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191002-Go-How-Does-the-Garbage-Collector-Watch-Your-Application/5.png" alt=""></p>
<!-- raw HTML omitted -->
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191002-Go-How-Does-the-Garbage-Collector-Watch-Your-Application/6.png" alt=""></p>
<!-- raw HTML omitted -->
<p>Go 语言 GC 的目标之一是不占用 25 % 的 CPU。这就意味着 Go 在标记阶段不应分配超过四分之一的处理器。实际上，这正是我们在前面的示例中所看到的，在八个处理器中只有两个 goroutine 被 GC 充分利用：</p>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191002-Go-How-Does-the-Garbage-Collector-Watch-Your-Application/7.png" alt=""></p>
<!-- raw HTML omitted -->
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191002-Go-How-Does-the-Garbage-Collector-Watch-Your-Application/8.png" alt=""></p>
<!-- raw HTML omitted -->
<hr>
<p>via：<a href="https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-watch-your-application-dbef99be2c35">来源地址</a></p>
<p>作者：<a href="https://medium.com/@blanchon.vincent?source=post_page-----dbef99be2c35----------------------">Vincent Blanchon</a>
译者：<a href="https://github.com/sh1luo">sh1luo</a>
校对：<a href="https://github.com/lxbwolf">lxbwolf</a></p>
<p>本文由 <a href="https://github.com/studygolang/GCTT">GCTT</a> 原创编译，<a href="https://studygolang.com/">Go中文网</a> 荣誉推出</p>
]]></content></item><item><title>Go的随机数是怎样产生的？</title><link>https://kcode.icu/posts/translation/20191202-go-how-are-random-numbers-generated/</link><pubDate>Sun, 29 Dec 2019 21:14:55 +0000</pubDate><guid>https://kcode.icu/posts/translation/20191202-go-how-are-random-numbers-generated/</guid><description>Go：随机数是怎样产生的？ 这篇文章基于 Go 1.13 版本
Go 实现了两个包来产生随机数：
在包 math/rand 的一个伪随机数生成器（ PRNG ） 在包 crypto/rand 中实现的加密伪随机数生成器（ CPRNG ） 如果这两个包都产生了随机数，则将基于真正的随机数和性能之间取舍
确定的结果 Go 的rand包会使用相同的源来产生一个确定的伪随机数序列。这个源会产生一个不变的数列，稍后在执行期间使用。将你的程序运行多次将会读到一个完全相同的序列并产生相同的结果。让我们用一个简单的例子来尝试一下：
func main() { for i := 0; i &amp;lt; 4; i++ { println(rand.Intn(100)) } } 多次运行这个程序将会产生相同的结果：
81 87 47 59 由于源代码已经发布到 Go 的官方标准库中，因此任何运行此程序的计算机都会得到相同的结果。但是，由于 Go 仅保留一个生成的数字序列，我们可能想知道 Go 是如何管理用户请求的时间间隔的。Go 实际上使用此数字序列来播种一个产生这个随机数的源，然后获取其请求间隔的模。例如，运行相同的程序，最大值为 10，则模 10 的结果相同。
1 7 7 9 让我们来看一下如何在每次运行我们的程序时得到不同的序列。
播种 Go 提供一个方法， Seed(see int64) ，该方法能让你初始化这个默认序列。默认情况下，它会使用变量 1。使用另一个变量将会提供一个新的序列，但会保持确定性：
func main() { rand.Seed(2) for i := 0; i &amp;lt; 4; i++ { println(rand.</description><content type="html"><![CDATA[<h1 id="go随机数是怎样产生的">Go：随机数是怎样产生的？</h1>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191202-Go-How-Are-Random-Numbers-Generated/01.png" alt=""></p>
<!-- raw HTML omitted -->
<p><em>这篇文章基于 Go 1.13 版本</em></p>
<p>Go 实现了两个包来产生随机数：</p>
<ul>
<li>在包 <code>math/rand</code> 的一个伪随机数生成器（ PRNG ）</li>
<li>在包 <code>crypto/rand</code> 中实现的加密伪随机数生成器（ CPRNG ）</li>
</ul>
<p>如果这两个包都产生了随机数，则将基于真正的随机数和性能之间取舍</p>
<h2 id="确定的结果">确定的结果</h2>
<p>Go 的<code>rand</code>包会使用相同的源来产生一个确定的伪随机数序列。这个源会产生一个不变的数列，稍后在执行期间使用。将你的程序运行多次将会读到一个完全相同的序列并产生相同的结果。让我们用一个简单的例子来尝试一下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span>  <span class="p">{</span>
      <span class="nb">println</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>多次运行这个程序将会产生相同的结果：</p>
<pre><code>81
87
47
59
</code></pre><p>由于源代码已经发布到 Go 的官方标准库中，因此任何运行此程序的计算机都会得到相同的结果。但是，由于 Go 仅保留一个生成的数字序列，我们可能想知道 Go 是如何管理用户请求的时间间隔的。Go 实际上使用此数字序列来播种一个产生这个随机数的源，然后获取其请求间隔的模。例如，运行相同的程序，最大值为 10，则模 10 的结果相同。</p>
<pre><code>1
7
7
9
</code></pre><p>让我们来看一下如何在每次运行我们的程序时得到不同的序列。</p>
<h2 id="播种">播种</h2>
<p>Go 提供一个方法， <code>Seed(see int64)</code> ，该方法能让你初始化这个默认序列。默认情况下，它会使用变量 1。使用另一个变量将会提供一个新的序列，但会保持确定性：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">rand</span><span class="p">.</span><span class="nf">Seed</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span>  <span class="p">{</span>
      <span class="nb">println</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这些是新的结果：</p>
<pre><code>86
86
92
40
</code></pre><p>在你每次运行这个程序时，这个序列将会保持不变。这是构建此序列的工作流：</p>
<p><img src="https://raw.githubusercontent.com/studygolang/gctt-images2/master/20191202-Go-How-Are-Random-Numbers-Generated/02.png" alt=""></p>
<!-- raw HTML omitted -->
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">rand</span><span class="p">.</span><span class="nf">Seed</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">())</span>
   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span>  <span class="p">{</span>
      <span class="nb">println</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>由于当前纳秒数在任何时刻都是不同的，因此这个程序每次运行都会使用一个不同的序列。然而，尽管这个序列在每次运行都是不同的，可这些数字仍是伪随机数。如果你准备牺牲性能来获得更好的随机性，那么 Go 已经为你提供了另一种实现方式。</p>
<h2 id="随机数生成器">随机数生成器</h2>
<p>Go 的标准库也提供了一个适用于加密应用的随机数生成器。因此，理所当然的，生成的随机数并不固定，并且一定会提供更好的随机性。这有一个例子使用了这个新包<code>cryto/rand</code> ：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span>  <span class="p">{</span>
      <span class="nx">n</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Int</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nx">Reader</span><span class="p">,</span> <span class="nx">big</span><span class="p">.</span><span class="nf">NewInt</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
      <span class="nb">println</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nf">Int64</span><span class="p">())</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这是结果：</p>
<pre><code>12
24
56
19
</code></pre><p>多次运行这个程序将会得到不同的结果。在内部，Go应用了如下规则：</p>
<blockquote>
<p><em>在 Linux 和 FreeBSD 系统上，Reader 会使用 getrandom(2) （如果可用的话），否则使用 /dev/urandom。</em></p>
<p><em>在 OpenBSD 上，Reader 会使用 getentropy(2)。</em></p>
<p><em>在其他的类 Unix系统上，Reader 会读取 /dev/urandom。</em></p>
<p><em>在 Windows 系统上，Reader 会使用 CryptGenRandom API.</em></p>
<p><em>在 Wasm 上，Reader 会使用 Web Cryto API。</em></p>
</blockquote>
<p>但是，获得更好的质量意味着性能降低，因为它必须执行更多的操作并且不能使用预生成的序列。</p>
<h2 id="性能">性能</h2>
<p>为了理解生成随机数的两种不同方式之间的折衷，我基于先前的两个例子运行了一个基准测试。结果如下：</p>
<pre><code>name    time/op
RandWithCrypto-8  272ns ± 3%
name    time/op
RandWithMath-8   22.8ns ± 4%
</code></pre><p>不出所料，<code>crypto</code> 包更慢一些。但是，如果你不用去处理安全的随机数，那么 <code>math</code> 包就足够了并且它将会给你提供最好的性能。</p>
<p>你也可以调整默认数字生成器的并发安全，由于内部互斥锁，它是并发安全的。如果生成器并不在并发环境下使用，那么你就可以在不使用锁的情况下创建你自己的生成器：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">gRand</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nf">NewSource</span><span class="p">(</span><span class="mi">1</span><span class="p">).(</span><span class="nx">rand</span><span class="p">.</span><span class="nx">Source64</span><span class="p">))</span>
   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span>  <span class="p">{</span>
      <span class="nb">println</span><span class="p">(</span><span class="nx">gRand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
   <span class="p">}</span>
<span class="p">}</span>

</code></pre></div><p>性能会更好：</p>
<pre><code>name                  time/op
RandWithMathNoLock-8  10.7ns ± 4%
</code></pre><hr>
<p>via：<!-- raw HTML omitted --><a href="https://medium.com/a-journey-with-go/go-how-are-random-numbers-generated-e58ee8696999">来源链接</a><!-- raw HTML omitted --></p>
<p>作者：<a href="https://medium.com/@blanchon.vincent?source=post_page-----e58ee8696999----------------------">Vincent Blanchon</a>
译者：<a href="https://github.com/sh1luo">sh1luo</a>
校对：<a href="https://github.com/lxbwolf">lxbwolf</a></p>
<p>本文由 <a href="https://github.com/studygolang/GCTT">GCTT</a> 原创编译，<a href="https://studygolang.com/">Go中文网</a> 荣誉推出</p>
]]></content></item></channel></rss>