<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on 失落</title>
    <link>https://www.kcode.icu/tags/go/</link>
    <description>Recent content in Go on 失落</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Fri, 22 Jan 2021 23:35:20 +0000</lastBuildDate><atom:link href="https://www.kcode.icu/tags/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>深入理解 Go map</title>
      <link>https://www.kcode.icu/posts/go/map/</link>
      <pubDate>Fri, 22 Jan 2021 23:35:20 +0000</pubDate>
      
      <guid>https://www.kcode.icu/posts/go/map/</guid>
      <description>哈希表 几乎所有语言都有 哈希表 这个数据结构，能够在平均 O(1)，最差 O(n) 的时间复杂度增删改查元素，Go 语言哈希表的精妙设计使得它几乎不会出现 O(n) 的糟糕情况。这篇文章我就带你从使用到底层由浅入深地探究 Go map 的奥秘，一起作一个不只是会用的”大神“。
问题来源于实际，我们先看看这些问题 ：
 声明。当我使用 :=，var，make，甚至 new 声明 map 的时候，编译器帮我们做了什么事情，它们有什么区别？ 增删改查。使用 数组+链表 的情况下如何设计才能避免 O(n) 的最差情况？ 注意事项。map 的键有什么要求？map 是值类型还是引用类型，函数传参时会有上层影响吗？是并发安全的吗？  还有一个常识是 Go map 的遍历是随机的，即多次遍历输出的结果集不同。
设计方式/数据结构 Go map 实现哈希表使用的是 数组+链表 的形式，也就是使用链地址法解决的哈希冲突。这种方式桶的大小和元素个数之间没有关系，另外还有开放定址法，这是个宽泛的名字，具体包含线性探测法，再哈希法，平方探测法等等。
为了降低 map 操作的时间复杂度，引入了一个 负载因子 的概念，这个概念在其他实现哈希表这个数据结构的语言里也都有，比如 python 中这个值被定义为 2/3，Java 中是 0.75，这个值评估了哈希表里 实际上最好只存 多少比例的元素，而不是一直等到满载再处理，因为多到一定程度效率 可能 就低了。在 Go 语言里这个值被定义为 6.5，即每个桶里最多存 6.5 个，包括溢出桶。
当我们在 Go 语言中声明一个 map 的时候，实际上就是创建了一个 hmap 的结构体，它定义在 runtime/map.go 文件下，这个结构体包含了许多信息：map 的大小，桶数量、地址，溢出桶数量、地址等等。 哈希表就是实现一个映射关系，给出自变量 x，能够通过平均 O(1) 的时间复杂度方法找到这个元素所对应的因变量 y=f(x) 来对它进行操作。</description>
    </item>
    
    <item>
      <title>一些常见Go语言及面试问题的整理</title>
      <link>https://www.kcode.icu/posts/interview/somequestions/</link>
      <pubDate>Fri, 15 Jan 2021 21:10:55 +0000</pubDate>
      
      <guid>https://www.kcode.icu/posts/interview/somequestions/</guid>
      <description>这篇博客记录一些关于面试常见的 Go 语言方面的问题，希望能帮到大家，等待更新中。
Go make和new的区别，使用和底层？ Go内存管理 goroutine 什么时候会阻塞？ goroutine有几种状态？ m操作g的时候有自旋与非自旋状态？
线程有哪些状态 注册中心挂了怎么办？ N节点，raft一致性？
反射底层原理？ 通过反射执行函数，拿结构体tag？ 锁机制？饥饿模式正常模式？锁底层原理？ channel使用，坑，底层原理？ </description>
    </item>
    
    <item>
      <title>手写一个RPCg（上）</title>
      <link>https://www.kcode.icu/posts/rpc/rpcg/</link>
      <pubDate>Sat, 28 Nov 2020 15:45:13 +0000</pubDate>
      
      <guid>https://www.kcode.icu/posts/rpc/rpcg/</guid>
      <description>须知 可能看到这里的一部分人还不知道什么是 RPC，也不知道为什么要用 RPC，内心：HTTP不香吗？那么你需要首先看一下这篇文章：
 你觉得HTTP哪都好用是因为你不知道RPC
 已经实现的 这篇文章我会带你手写一个简易版本的 RPC 框架，这个框架会支持如下这些功能：
 多种网络传输方式 服务端自动注册可导出服务 可以心跳保活的注册中心 服务注册与服务发现 多种序列化方式 超时控制 一些负载均衡策略，一致性哈希、平滑带权轮询等  未来需要做的   自定义的代码生成插件
  一种压缩方式
  基于服务器时延的负载均衡策略？
  心里有数 ”切忌重复造轮子“这句话你应该听过，不过这个”框架“的目的是带领我们大致了解 RPC 框架的工作过程，目标并不是工业级应用，我想你也一定清楚用框架和自己写框架对框架的理解程度有什么区别。也不必把 RPC 想成多么”高端“的技术，RPC 也只是一个调用，微服务的一个组件，从小的地方出发更容易让人接受罢了。好了，话不多说，让我们正式开始。
俯瞰RPCg 这个图向我们展示了最基本的 RPC 调用关系：服务端将自己的服务注册到注册中心，客户端从注册中心获取所有服务端的所有信息，在拿到这些信息之后带着自己的请求去访问某个服务端的服务。你可能会问为什么要多个”第三者“注册中心出来呢，我直接就只有客户端和服务端多方便，那你需要思考以下问题：
 直接通信是不是需要将通信的地址等服务端信息硬编码到客户端的代码中？如果服务端节点数改变了怎么办，难道手动删改代码？ 客户端怎么知道服务端可不可用？难道需要服务端开个服务专门去处理这类信息吗？这属于服务端的业务吗？ &amp;hellip;&amp;hellip;  我想你应该大致能明白为什么需要这个注册中心了，就是屏蔽对方对己方的感知，通过一个第三方中介来提供/提出自己的服务/需求，这就够了，你可以类比 房产中介，婚介所等等机构，当然，注册中心还有很多功能，我们这里为了学习，就只提供这部分功能了，更多的需要留给你去探索 :)
我们再想想，我们现在有了三个主体，之前有不同的需求，怎么提供通信。业界有非常多的解决方法，比如 gRPC 的 HTTP/2.0，它的优势也是显而易见的：多路复用，pipelining 的通信方式，效率大幅提高，不必在等待对方的回复；首部压缩，这里我需要说明一下，RPC 调用大部分是服务端内部的互相调用，比如公司机房里 50 台机器之间相互调用，需要保证传输的效率，也就是说传送的数据要尽可能地小，这才有了 Protocol Buffers 的数据格式，所以经过压缩的首部数据量更小，效率更高。还有 tcp 连接，优势是简单等等。
等待更新&amp;hellip;&amp;hellip;.</description>
    </item>
    
    <item>
      <title>Go&#43;QML构建桌面应用</title>
      <link>https://www.kcode.icu/posts/chore/go&#43;qamel/</link>
      <pubDate>Mon, 23 Mar 2020 14:51:15 +0000</pubDate>
      
      <guid>https://www.kcode.icu/posts/chore/go&#43;qamel/</guid>
      <description>引文 开发的项目是直播助手，相关介绍在 B站直播协议分析上 有介绍，这里说一下技术选型方面遇到的问题，踩的坑，希望给后续的人一点建议和参考。
技术选型 因为当时第一步的主要想开发的功能是弹幕点歌，但是在稍做分析之后发现如何对 MP3 文件进行解码播放是个问题，自己实现可能略显复杂，也不是这个工具的主要想解决的问题。然后就考虑到使用什么组件来解码并播放音乐。
最初的想法是另写一套前端，和已经写好的这套后端进行通信，来呈现内容，播放音乐等，这是一定可以实现的，但是同一条信息进行两次传输效率太低，于是放弃，想在同一端执行，增加效率。Go 确实不擅长写 GUI 程序（C#完美。。），决定使用 qamel来使用开发，其和 therecipe 比较如下：
 轻量（只使用少量的类）。构建简单的 QML 应用，比如 QApplication、 QQuickView and QQMLApplicationEngine。而 therecipe/qt 绑定了所有的 QT 模块。 安装简单。需要拿到编译好的 qamel 二进制文件（你可以选择自己编译构建，也可以选择直接从别人手里获取），放入 path 环境变量，再设置好配置，就可以构建自己的引用了。而 therecipe/qt 需要执行 setup 等一系列安装过程，繁琐且容易失败。 编译速度快。因为绑定部分代码是手动写的，使得绑定安装过程非常快，而 therecipe/qt 是安装时即时生成的，所以非常慢，可以自己体验一下。。   还有个缺点，目前跨平台编译只支持 windows 和 linux，macOS 作者未测试，目前未知。而therecipe/qt 支持 Linux, Windows, macOS, Android, Sailfish, Ubuntu Touch, WASM, and iOS各种平台。
 坑在哪  以下均是在 Windows ，amd64 位环境下的结果。
   不要在系统自带 CMD 或 PowerShell 中构建应用，不然会报代码第二行找不到 QApplication 的错误，换用 cmder 就可以解决，这个问题已经被证实，但是并未找到原因。</description>
    </item>
    
    <item>
      <title>优化Golang服务减少40%以上的CPU</title>
      <link>https://www.kcode.icu/posts/translation/20200303-optimizing-a-golang-service-to-reduce-over-40-cpu/</link>
      <pubDate>Mon, 16 Mar 2020 16:46:08 +0000</pubDate>
      
      <guid>https://www.kcode.icu/posts/translation/20200303-optimizing-a-golang-service-to-reduce-over-40-cpu/</guid>
      <description>优化 Golang 服务来减少 40% 以上的 CPU 十年前，谷歌正在面临一个由 C++ 编译时间过长所造成的严重瓶颈，并且需要一个全新的方式来解决这个问题。谷歌的工程师们通过创造了一种新的被称作 Go （又名 Golang）的语言来应对挑战。这个新语言 Go 带来了 C++ 最好的部分（最主要的是它的性能和稳定性），又与 Python 的速度相结合，使得 Go 能够在实现并发的同时快速地使用多核心。
在 Coralogix（译者注：一个提供全面日志分析的服务产品，官网），我们为了去给我们的客户提供关于他们日志实时的分析、警报和元数据，要去解析他们的日志。在解析阶段，我们需要非常快速地解析包含多个复杂规则的服务日志，这个目标是促使我们决定使用 Golang 的原因之一。
这项新的服务现在就全天候的跑在生产阶段，尽管我们看到了非常好的结果，但是它也需要跑在高性能的机器上。这项 Go 的服务跑在一台 AWS m4.2xlarge 实例上 ，带有 8 CPUs 和 36 GB 的配置，每天要解析几十亿的日志。
在这个阶段一切都运行正常，我们本可以自我感觉良好，但是那并不是我们在 Coralogix 想要的表现。我们想要更多的特性，比如性能等等，或者使用更少的 AWS 实例。为了改进，我们首先需要理解瓶颈的本质以及我们如何能够减少或者完全解决这些问题。
我们决定在我们的服务上进行一些分析，检查一下到底是什么造成了 CPU 的高消耗，看看我们是否能够优化。
首先，我们将 Go 升级到最新的稳定版本（这是软件生命周期中的关键一步）。我们是用的 Go 1.12.4版本，最新的是 1.13.8。根据 文档 ，Go 1.13 发行版在运行时库方面和一些其他主要利用内存使用的组件方面已经有了长足的进步。总之，使用最新的稳定版本能帮助我们节省许多工作。
因此，内存消耗由大约 800 MB 降低到了仅 180 MB。
第二，为了更好的理解我们的流程以及弄清楚我们应该在哪花费时间和资源，我们开始去进行分析。
分析不同的服务和程序语言可能看起来很复杂并且令人望而生畏，但是对于 Go 来说它实际上十分容易，仅仅几个命令就能够描述清楚。Go 有一个专门的工具叫“pprof”，它通过监听一个路由（默认端口6060）能够应用在你的 app 上，并且使用 Go 的包来管理 HTTP 连接：</description>
    </item>
    
    <item>
      <title>Go&#43;QML开发的跨平台桌面直播助手[下]</title>
      <link>https://www.kcode.icu/posts/b%E7%AB%99%E7%9B%B4%E6%92%AD%E5%8A%A9%E6%89%8B%E5%BC%80%E5%8F%91%E4%B8%8B/</link>
      <pubDate>Fri, 13 Mar 2020 13:22:23 +0000</pubDate>
      
      <guid>https://www.kcode.icu/posts/b%E7%AB%99%E7%9B%B4%E6%92%AD%E5%8A%A9%E6%89%8B%E5%BC%80%E5%8F%91%E4%B8%8B/</guid>
      <description>Go + QML 结合上节的分析，开发的思路的大致流程我画了个图，大概是这样：
 因为是需要面向用户的，又考虑到 Go 语言的特殊性（可以直接调用 C/C++ 代码，GUI 官方不支持），最后决定使用 Qml 来呈现前端，与 Go 语言利用插槽和信号进行通信。
 处理思路是创建一个协程池来处理不同类型的包数据。判断每个包内所有子包类型，将接收的未处理的字节数组直接送入对应协程池中的管道。因为代码也比较简单，就是简单的 WebSocket 通信。
// 客户端实例 type Client struct { RoomID uint32	// 房间 ID 	Online uint32	// 用来判断人气是否变动 	Conn *websocket.Conn	// 连接后的对象 	IsConnected bool } // 使用了&amp;#34;github.com/gorilla/websocket&amp;#34;这个包，也可以自己升级 tcp 到 websocket u := url.URL{Scheme: &amp;#34;wss&amp;#34;, Host: DanMuServer, Path: &amp;#34;/sub&amp;#34;,} conn, _, err := websocket.DefaultDialer.Dial(u.String(), nil) if err != nil { return nil, err } // 发送包函数 func SendPackage(conn *websocket.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.kcode.icu/posts/chore/go-net-url%E5%8C%85%E6%BA%90%E7%A0%81%E5%88%9D%E6%8E%A2/</link>
      <pubDate>Wed, 11 Mar 2020 22:49:51 +0000</pubDate>
      
      <guid>https://www.kcode.icu/posts/chore/go-net-url%E5%8C%85%E6%BA%90%E7%A0%81%E5%88%9D%E6%8E%A2/</guid>
      <description>问题起因 问题的起因是最近需要写一个小工具，期间因为需要自己在服务器上搭建了一个 Web 服务来提供 RESTful API 接口，在请求接口的时候需要拼接 url，没有考虑到部分字符的编码问题，导致 400 Bad Request 错误。原来使用的是这样：
// url := fmt.Sprintf(&amp;#34;%ssearch?keywords=%s %s&amp;amp;limit=1&amp;#34;, Mp3Server, name, singer) // resp,err := http.Get(url) // ... 这个 name 和 singer 都有可能是中文，直接请求服务器无法识别，所以导致 400 无效请求的错误。后来改成这样，就成功了：
q := url.Values{} q.Set(&amp;#34;keywords&amp;#34;, name+&amp;#34; &amp;#34;+singer) q.Set(&amp;#34;limit&amp;#34;, &amp;#34;1&amp;#34;) u := url.URL{ Scheme: &amp;#34;http&amp;#34;, Host: &amp;#34;shiluo.design:3000&amp;#34;, Path: &amp;#34;search&amp;#34;, RawQuery: q.Encode(), // 关键在这 } resp, err := http.Get(u.String()) 问题解决的关键就是在 RawQuery: q.Encode() 。由于我一直有看源码的习惯，我就 ctrl+左键跟进去把处理逻辑看了几遍，收获不小，特别记录下来。
整体处理逻辑 整个方法的主逻辑过程：
// Encode encodes the values into ``URL encoded&amp;#39;&amp;#39; form // (&amp;#34;bar=baz&amp;amp;foo=quux&amp;#34;) sorted by key.</description>
    </item>
    
    <item>
      <title>Go语言内存管理与内存清理</title>
      <link>https://www.kcode.icu/posts/translation/20191109-go-memory-management-and-memory-sweep/</link>
      <pubDate>Fri, 14 Feb 2020 21:20:33 +0000</pubDate>
      
      <guid>https://www.kcode.icu/posts/translation/20191109-go-memory-management-and-memory-sweep/</guid>
      <description>Go：内存管理与内存清理 清理内存是一个过程，它能够让 Go 知道哪些内存段最近可用于分配。但是，它并不会使用将位置 0 的方式来清理内存。
将内存置0 将内存置 0 的过程 —— 就是把内存段中的所有位赋值为 0 —— 是在分配过程中即时执行的。
然后，第一个分配就开始了：
分配过程将会再一次出现，之后， GC 将会启动去释放不再被使用的内存。在标记期间，GC 会用一个位图gcmarkBits 来跟踪在使用中的内存。让我们通过我们运行的程序以相同的示例为例，在第一个块不再被使用的地方。
 有关更多关于标记和着色阶段的信息，我建议你阅读我的这篇文章 Go：GC 是如何标记内存的？
 现在，我们可以使用 gomarkBits精确查看可用于分配的内存。Go 现在也使用gomarkBits 代替了allocBits ，这个操作就是内存清理：
清理阶段 Go 提供了两种方式来清理内存：
 使用一个工作程序在后台等待，一个一个的清理这些范围。 当分配需要一个范围的时候即时执行。  关于后台工作程序，当开始运行程序时，Go 将设置一个后台运行的 Worker（唯一的任务就是去清理内存），它将进入睡眠状态并等待内存段扫描：
与 GC 周期的冲突 正如之前看到的，由于后台只有一个 worker 在清理内存块，清理过程可能会花费一些时间。但是，我们可能想知道如果另一个 GC 周期在一次清理过程中启动会发生什么。在这种情况下，这个运行 GC 的 goroutine 就会在开始标记阶段前去协助完成剩余的清理工作。让我们举个例子看一下连续调用两次 GC，包含数千个对象的内存分配的过程。
 via：来源链接
作者：Vincent Blanchon 译者：sh1luo 校对：[](https://github.com/
本文由 GCTT 原创编译，Go中文网 荣誉推出</description>
    </item>
    
    <item>
      <title>Go的随机数是怎样产生的？</title>
      <link>https://www.kcode.icu/posts/translation/20191202-go-how-are-random-numbers-generated/</link>
      <pubDate>Sun, 29 Dec 2019 21:14:55 +0000</pubDate>
      
      <guid>https://www.kcode.icu/posts/translation/20191202-go-how-are-random-numbers-generated/</guid>
      <description>Go：随机数是怎样产生的？ 这篇文章基于 Go 1.13 版本
Go 实现了两个包来产生随机数：
 在包 math/rand 的一个伪随机数生成器（ PRNG ） 在包 crypto/rand 中实现的加密伪随机数生成器（ CPRNG ）  如果这两个包都产生了随机数，则将基于真正的随机数和性能之间取舍
确定的结果 Go 的rand包会使用相同的源来产生一个确定的伪随机数序列。这个源会产生一个不变的数列，稍后在执行期间使用。将你的程序运行多次将会读到一个完全相同的序列并产生相同的结果。让我们用一个简单的例子来尝试一下：
func main() { for i := 0; i &amp;lt; 4; i++ { println(rand.Intn(100)) } } 多次运行这个程序将会产生相同的结果：
81 87 47 59 由于源代码已经发布到 Go 的官方标准库中，因此任何运行此程序的计算机都会得到相同的结果。但是，由于 Go 仅保留一个生成的数字序列，我们可能想知道 Go 是如何管理用户请求的时间间隔的。Go 实际上使用此数字序列来播种一个产生这个随机数的源，然后获取其请求间隔的模。例如，运行相同的程序，最大值为 10，则模 10 的结果相同。
1 7 7 9 让我们来看一下如何在每次运行我们的程序时得到不同的序列。
播种 Go 提供一个方法， Seed(see int64) ，该方法能让你初始化这个默认序列。默认情况下，它会使用变量 1。使用另一个变量将会提供一个新的序列，但会保持确定性：
func main() { rand.Seed(2) for i := 0; i &amp;lt; 4; i++ { println(rand.</description>
    </item>
    
  </channel>
</rss>
