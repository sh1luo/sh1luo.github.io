<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>HTTP on 失落</title>
    <link>https://www.kcode.icu/tags/http/</link>
    <description>Recent content in HTTP on 失落</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Wed, 27 Jan 2021 15:57:50 +0000</lastBuildDate><atom:link href="https://www.kcode.icu/tags/http/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>https为什么安全，绝对安全吗</title>
      <link>https://www.kcode.icu/posts/secure/</link>
      <pubDate>Wed, 27 Jan 2021 15:57:50 +0000</pubDate>
      
      <guid>https://www.kcode.icu/posts/secure/</guid>
      <description>我这次会使用 Wireshark 进行抓包分析，这样应该比纯理论更好理解一点，希望我的这篇文章能带你彻底理清 https 的前世今生。
简介 HTTP 是无状态协议，这一特性极大地增强了 HTTP 协议的灵活性，设计的高度自由随着发展也带来了各种问题。比如明文传输且无法验证通信方身份，不适合在安全场景下使用等等。
所以提出了 HTTPS 的概念。HTTPS 并不是新的协议，而是 HTTP over SSL/TLS，也就是使用了 SSL/TLS 加密的 HTTP，解决了 HTTP 不安全的问题。SSL（Secure Sockets Layer） 是 TLS（Transport Layer Security） 的前身，SSL 经历了三个版本的变迁，后来升级为了 TLS，TLS 主要有 1.0、1.1、1.2 和 1.3，版本越高兼容性越不好，现在大部分正在从 1.1 到 1.2 的迁移，部分使用 1.3，我们可以使用 Wireshark 过滤一下进行简单查看。
需要注意的是，应用了 HTTPS 后通信效率会变低，毕竟需要进行额外的握手，加解密步骤。
证书 不管什么版本的 SSL/TLS，只使用对称加密和非对称加密也是不够的，因为无法解决中间人攻击，都需要配合证书来完成整个验证过程。
证书的作用有两个：
 确保通信目标的身份。 确认你的身份。  其实就是确认通信双方的身份，而不是中间某个第三者。再结合非对称加密与对称加密，就可以解决 HTTP 的三大问题，明文传输，消息篡改，窃听。证书的整个流程如下图：
加密与签名 这里有一点需要注意，非对称加密中的公私钥有两种用法，被称为 加密 和 签名 ，很多人容易搞混。不过需要记住不变的是私钥永远需要保密，不能公布。
 前者是使用公钥加密，私钥解密。将公钥发布出去，只有自己才能获得加密信息，用于 保护信息。 后者是私钥加密，公钥解密。用于 判断信息是否被篡改。  加密很好理解，签名可以这样理解：私钥加密的签名其他人无法伪造（其他人没有私钥），而你将经过私钥加密的信息和未加密明文还有公钥一起交付，对方就可以用公钥去解密（公钥是公开的），然后比对，如果一致了就说明信息没有被篡改，否则已经被改过了，抛弃。
整个过程可以参考上图，证书的过程就是使用了加密和签名两种手段。</description>
    </item>
    
    <item>
      <title>谈谈最常见的 HTTP</title>
      <link>https://www.kcode.icu/posts/http/</link>
      <pubDate>Fri, 15 Jan 2021 23:10:22 +0000</pubDate>
      
      <guid>https://www.kcode.icu/posts/http/</guid>
      <description>标题的”最常见“我想应该没有什么争议，对大多数人来说日常生活中接触到最多的应用层协议就是 HTTP了，从聊天软件、浏览器页面再到各种游戏实现，它们无处不在。这篇文章我就带你来看一看这个处于 OSI 标准最上层、最常用也是最普通的 HTTP 它究竟有什么“东西”，一起作为一个不只是听说过的“大神”。
这篇博客我想阐述除书本概念之外的一些可能你 理解不深刻 的问题的 个人理解，希望对你有所帮助。
HTTP是什么 超文本传输协议（Hypertext Transfer Protocol，HTTP），是一个应用层面上的，也就是软件双方通信的数据规则，是通信的基石。不然你发给我一串 @#$%$%^$%^，只有你能看懂，我怎么知道你说的是什么玩意？双方按照这个规则去通信，有什么需求都在这个规范里写好了发给对方，对方就知道你想干什么，就可以也按照这个规范给你回过去，就是这么简单。只是因为随着技术的发展，所遇到的问题越来越多，从功能需求，再到安全、效率、可读性等等，不得不提出一系列的解决方案去完善，最终变得很 ”臃肿“ 罢了。但是你应该明白，这就是一个为应用程序通信所提出来的一个基础通信协议。
HTTP方法有什么“实际区别” 你可能听说过类似 “GET 和 POST 有什么区别” 这种问题，其实说到底从底层上来说，它们之间 没有任何区别，仅仅是约定、规范。 也就是说 按照约定，GET 方法的请求 不应该 携带请求体，并且在以前 Postman 这类客户端模拟软件也是不允许构造这类请求的，但是后来也是支持了。
但是，如果你强行带了请求体，是没有任何问题的。你甚至可以把 GET 方法携带上请求体用来登录，使用 POST 请求用来获取 HTML 等静态资源，用 DELETE 方法来为数据库增加一条记录，只要你后端程序员老哥不把你捶死（手动狗头） 🤣🤣🤣
各个版本之间的发展史 HTTP 比较重要的几个发展时间节点是 0.9、1.0、1.1、2.0 和 3.0，每一次的版本变迁都是为了解决前一个版本的性能不足或者功能不完善，我不推荐死记硬背，即使它被称为计算机八股文。
http 0.9和1.1 在 HTTP 0.9 的时候只有 GET 方法，1.0 补充了 POST，DEL 方法完善语义，还添加了几个首部，这个阶段的 HTTP 主要就是完善功能。
1.0 和 1.1 的最大区别就是长短连接了。在 HTTP 1.1 将长连接设置为了默认，也就是：
Connection: keep-alive 在这之前这个字段的默认是 close，长连接的好处是显而易见的，由于 HTTP 是基于 tcp，如果总共传输三个文件，1.</description>
    </item>
    
  </channel>
</rss>
