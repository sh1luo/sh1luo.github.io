<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>wasabi</title>
    <link>https://kcode.icu/</link>
    <description>Recent content on wasabi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Sat, 19 Jun 2021 15:00:13 +0000</lastBuildDate><atom:link href="https://kcode.icu/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>最近两个月及远程实习半个月小记</title>
      <link>https://kcode.icu/posts/chore/2021-06-19-recent-life/</link>
      <pubDate>Sat, 19 Jun 2021 15:00:13 +0000</pubDate>
      
      <guid>https://kcode.icu/posts/chore/2021-06-19-recent-life/</guid>
      <description>自 3 月末完成许多轮线上面试，4 月初拿到 offer，到现在因疫情远程实习，已经过去2个多月了，时间真的一晃就过去了，虽说还没拿到正式的秋招 offer，但也距离面试不远了，有必要记录一下这段时间的生活，顺便总结反思。
前段时间 在拿到实习 offer 后，和之前学习状态相比有点佛系，一方面是因为阶段性的目标没了，短时间内没有下一个目标；另一方面是把重心从看/背知识点转移到了深入思考，理解上来了。因为在准备时有一些知识难免是死记硬背的，或者理解不透彻，需要复现并弄清楚。
针对第一方面，其实我之前已经有了另一个目标的雏形，也是针对我的简历项目比较薄弱。就是寻找一个 “亮眼” 的项目来丰富简历上的项目部分，思前想后主要有四大块方向，竞赛类项目，开源贡献，造轮子，还有 秒杀/CRUD 类。
竞赛类项目是一些参加比赛的项目，比如一年一次的微信小程序开发大赛，用小程序解决一个实际问题或者开发一个趣味游戏。这个我现在来不及了，不适合。开源贡献这块我一直在关注 GSoC，奈何要求确实略高，另外需要提前至少 1-2 个月进行准备，为目标社区的项目贡献，联系导师等，之前加入了国内 GSoC 的 Gitter 社区讨论群，在 5 月恰巧看到群里有人说国内也搞了个开源夏令营，模仿谷歌的，是第二年举办，我就参加了，贡献了半个多月，累计 PR 10 个左右 ，也是常常肝到凌晨，目前结果怎么样还未知，不过学习到的东西真的很多，例如更多的 Git 用法，开源规范，还有具体项目的知识。这个如果成功了我觉得也应该比单纯的 CRUD 好（希望😄
参加这类夏令营，大多都不看重 proposal，也就是申请书/简历一类的，强调在实际贡献中体现代码及工程能力，所以要提前一段时间准备，了解项目。
造轮子就是创造一些小工具，这个需要有一定的代码能力，做得好了也很加分，但是我觉得写 用 tcp 实现 http，json 解析器之类的可以自己写，就没必要写简历上了，一来没啥问的，二来没啥实际用途。我个人是用 Go 写了个 rpc 框架的小轮子，不过难点也很多，很容易被怼。
秒杀/CRUD 类就是常见的 xx管理系统，多做一些 CRUD 的操作，不推荐，除非吃透不怕问，不过我觉得面试官比你更懂秒杀（​逃😆
 除了简历，我也在思考一些常见问题如何回答的更深入，例如常见的 https，select/poll/epoll，memory，file system等等，这些问题想要答的透彻，基本都要看源码，看底层设计实现，比较耗时，但是能将清楚非常加分，也是拿到 sp/ssp 的关键一环。
近期实习 由于疫情远程参与了实习，前期也比较闲，主要是熟悉产品，在内网逛逛😄，不得不说，来大厂实习的一大好处就是可以体验一下大厂内部的环境。好多都是自研，确实方便。
很多资料，格式/规范，除非一部分实习生没权限之外（比如腾讯的乐问），技术资料都公开。因为可能是出售的产品，所以有的代码是不能访问，需要开权限才能访问。当然内部开源的工具的源码还是随便看的。
等疫情过去，7 月多我就过去线下实习体验一下，还是挺期待现场实习的。
 2021.6.30 16:02更新，已入选~
顺便吐槽一下，入选有时候真的看运气，有的项目4、5个人，卷的飞起，10 几个PR不一定能进，有的没人，可能写个申请书随便交点PR就进了 😂
 </description>
    </item>
    
    <item>
      <title>面试官：如何只使用一个指针域实现双向链表</title>
      <link>https://kcode.icu/posts/interview/2021-06-05-%E5%A6%82%E4%BD%95%E5%8F%AA%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E5%9F%9F%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sat, 05 Jun 2021 14:36:20 +0000</pubDate>
      
      <guid>https://kcode.icu/posts/interview/2021-06-05-%E5%A6%82%E4%BD%95%E5%8F%AA%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E5%9F%9F%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid>
      <description>这是来自某学习群的群友提供的，一道 便利蜂 的实习面试题，恰好被看到了（不是
问题是：只使用一个指针如何实现双向链表，乍一想好像不可能，我当时的大致思路是这样的：原来直接使用 -&amp;gt;right 或者 -&amp;gt;left 就能访问到左右节点，现在只有一个指针，就要修改指针的含义，不能直接存储下一个节点的地址了，大概率是要根据某些条件算出下一个地址。
事实呢？为了了解具体做法，我去翻了维基百科关于这部分的 详细解释 ，并本地实现了一遍完整代码，记录在这里。
实现原理 这种链表被称为 异或链表（XOR Linked List），能够达到只使用一个指针域实现双向链表的效果，从而降低空间复杂度。当然它也不是没有缺点，如果只有一个节点，无法向两个方向遍历，必须有连续的两个节点地址。
回到之前说的问题，问题的关键就是如何只使用一个指针实现双向访问的效果，再来看链表名，异或链表。
任何一个节点的指针域的值为 它的前一个节点和下一个节点的地址异或。
假如现在有 3 个节点分别为 A,B 和 C，地址分别为 0x1,0x2,0x3，那么，
A.next = null^0x2 B.next = 0x1^0x3 C.next = 0x2^null  XOR linked List+--- -----+ next=0x1 +---------+ next=0x1^0x3 +---------+| *A=0x1 +--------- | *B=0x2 +------------ | *C=0x3 |+---------+ +---------+ +------+--+|| | next=0x2| || next=0x1 ||+------+--+ +---------+| null | | null |+---------+ +---------+这个图之所以没有画出箭头是因为这里并不是直接指向下一个节点的地址，而是需要和前一个节点异或计算才能得到下一个节点的地址。</description>
    </item>
    
    <item>
      <title>正/反向代理与科学上网</title>
      <link>https://kcode.icu/posts/2021-05-31-%E6%AD%A3%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</link>
      <pubDate>Mon, 31 May 2021 15:33:50 +0000</pubDate>
      
      <guid>https://kcode.icu/posts/2021-05-31-%E6%AD%A3%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</guid>
      <description>代理
你可能听过许多 反向代理（Reverse Proxy） 软件例如 Nginx、Apache 等，它们性能优越，被广泛应用于实际场景中，那么你是否知道 “反向” 是什么意思，为什么叫反向呢，明白这个问题有助于我们更深入的理解它们。还有许多框架中常用的的 控制反转（IOC）/依赖注入（DI） 等概念，你是否理解 反转 或 注入 的真正含义。
既然有反向代理，就有正向代理，常用的科学上网就是使用了这个技术，你所见过的例如 ss/ssr/socks5 等等仅仅是协议名，配合上一些混淆方式，它们的技术原理还是 正向代理（ Forward Proxy）。
之前我在「刷」面试题的时候，就遇到过相关问题，“墙以及科学上网的原理”。相信读完这本文你会得到答案。
在了解正反向代理之前先牢记一句话，反向代理 代理并 隐藏服务端，正向代理与之相反，隐藏客户端。
反向代理 OK，记住了这句话，想想 Nginx/Apache 的功能，你将服务部署在服务器上，只公开了 80/443 端口，而内部服务有很多个，通过不同域名访问，然后使用 Nginx/Apache 来接受外界请求，利用提供的指令，例如 sever_name，listen，index，location 来控制其进行转发到不同的内部端口上，由于其使用了非常高效的 epoll IO多路复用模型，效率非常高。
那么你的脑海中应该有大致这么一张图，类似这样：
Reverse Proxy +------------------------------------------------------+ | | | +---------+ | | +-------&amp;gt; | Server1 | | | | +---------+ | +--------------+ | +-----------------+ | | | | | | | | +---------+ | | Client +-----------+--&amp;gt;| google.</description>
    </item>
    
    <item>
      <title>极客时间专栏《RPC实战与核心原理》读后笔记</title>
      <link>https://kcode.icu/posts/rpc/geektime-rpc/</link>
      <pubDate>Fri, 14 May 2021 21:45:13 +0000</pubDate>
      
      <guid>https://kcode.icu/posts/rpc/geektime-rpc/</guid>
      <description>对 RPC 相关的学习也有了一段时间，算是有了一个初步的认识，回过头来读 极客时间的专栏 感觉思路清晰了不少，顺利了许多，再回头看 rpcx 的源码也没有那么费劲了。我把我在这个专栏中学到的一些内容记录下来，共同学习。
本文不再解释 RPC 相关基础概念，有需要可在上文链接或者往期文章中学习。
以下的二级标题均对应专栏的课程大纲，同样分单元总结。
开篇词 开篇词介绍了 RPC 的使用场景，重要意义，作为引文。
RPC 即远程过程调用，目的是使调用另一台机器上的程序就像调用本地程序一样简单。总是和 “微服务”，SOA 联系，其实理论上来说，任何牵扯到网络通信的系统都可能需要使用 RPC。比如分布式各个组件间或与应用间的通信，比如 etcd 作为统一的配置服务，客户端就是通过 gRPC 框架与服务端进行通信的。
RPC 是解决分布式系统通信问题的一大利器。 RPC 的通信原理十分简单，可是想完美驾驭却不那么容易，这个过程除了调用过程之外，还主要包括：通信节点查找，连接的建立与状态管理，数据传输的编解码，序列化与反序列化等等，每一项都十分复杂。
而完整的 RPC 框架却对上述过程进行了封装，使得网络通信逻辑的开发变得十分简单，效率也会更高。
最初的我学习 RPC 也是由浅入深，从 “字面意思” 出发，即如何调用远程主机上的某个函数，实现了编解码，序列化等等一整套调用流程，成功执行了远程主机的程序，当然了，这还是点对点的。
后来我发现这些仅仅是基础，冰山下的还包括一系列服务治理功能：连接管理，健康检测，负载均衡，优雅启停机，异常重试，业务分组以及熔断限流等等。十分复杂又充满了挑战性。</description>
    </item>
    
    <item>
      <title>MIT 6.828 课程学习记录</title>
      <link>https://kcode.icu/posts/os/mitos/</link>
      <pubDate>Sun, 25 Apr 2021 23:35:20 +0000</pubDate>
      
      <guid>https://kcode.icu/posts/os/mitos/</guid>
      <description>介绍 好多人推荐这个国外的课程，就找了一下课程，下载了一份讲义，打开第一眼就看到大名鼎鼎的 rsc 大佬，偶像啊，Go 的当下掌舵人。就冲这名必须得看完了（狗头😄）。 开个玩笑，我个人对计算机基础最感兴趣的就是组成原理、操作系统和汇编语言，除此之外就是分布式了，等搞定这个之后也去跟一下 MIT 6.824 分布式部分（开新坑🕳️ ）
待更&amp;hellip;.</description>
    </item>
    
    <item>
      <title>Go 使用的 plan9 汇编语言初探</title>
      <link>https://kcode.icu/posts/go/2021-03-20-go-%E4%BD%BF%E7%94%A8%E7%9A%84-plan9-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%88%9D%E6%8E%A2/</link>
      <pubDate>Sun, 04 Apr 2021 20:30:20 +0000</pubDate>
      
      <guid>https://kcode.icu/posts/go/2021-03-20-go-%E4%BD%BF%E7%94%A8%E7%9A%84-plan9-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%88%9D%E6%8E%A2/</guid>
      <description>plan9 汇编既不同于 Intel-x86 家族的汇编，也不与 AT&amp;amp;T 标准相同，作者是 unix 操作系统的同一批人，bell 实验室所开发的，其实 plan9 是一个操作系统，我们主要关注构建它的汇编语言。
Go 语言早在 1.5 版本就实现了自举，即 使用 Go 语言去写 Go 语言。Go 的底层实现是使用 plan9 汇编完成的，并不是我们常见的 Intel 家族汇编，它与其他的汇编有几个不同点，在下文中一边比较一边介绍。
伪寄存器 plan9 抽象了 4 种伪寄存器：
 FP（Frame Pointer），帧指针，快速访问函数的参数和返回值。 SP（Stack Pointer），栈指针，指向栈顶。 SB（Static base pointer），静态基址，全局变量。 PC（Program Counter），其实就是 IP（Instruction Pointer）的别名，指向下一条指令的地址。jmp等跳转指令还有分支控制等原理就是通过修改这个值。在 8086 机里等价于 CS:IP。  其实就是对 CPU 的重新抽象，这个抽象结构与具体的 CPU 结构无关。
它们之间的具体关系如下图：
与x86汇编的差异 许多人之前广泛了解的汇编可能是 AT&amp;amp;T 格式或者传统 Intel-x86 格式，AT&amp;amp;T 规范与 x86 有许多不同，而 plan9 与 AT&amp;amp;T 有许多相似的地方，比如操作数顺序许多是相同的，但 不完全等价。还是需要我们重新学习，这里列举一些常见区别。
Mnemonic | Go operands | AT&amp;amp;T operands================================================BOUNDW | m16&amp;amp;16, r16 | r16, m16&amp;amp;16BOUNDL | m32&amp;amp;32, r32 | r32, m32&amp;amp;32CMPB | AL, imm8 | imm8, ALCMPW | AX, imm16 | imm16, AXCMPL | EAX, imm32 | imm32, EAXCMPQ | RAX, imm32 | imm32, RAXCMPW | r/m16, imm16 | imm16, r/m16CMPW | r/m16, imm8 | imm8, r/m16CMPW | r/m16, r16 | r16, r/m16CMPL | r/m32, imm32 | imm32, r/m32CMPL | r/m32, imm8 | imm8, r/m32CMPL | r/m32, r32 | r32, r/m32CMPQ | r/m64, imm32 | imm32, r/m64CMPQ | r/m64, imm8 | imm8, r/m64CMPQ | r/m64, r64 | r64, r/m64CMPB | r/m8, imm8 | imm8, r/m8CMPB | r/m8, imm8 | imm8, r/m8CMPB | r/m8, r8 | r8, r/m8CMPB | r/m8, r8 | r8, r/m8CMPW | r16, r/m16 | r/m16, r16CMPL | r32, r/m32 | r/m32, r32CMPQ | r64, r/m64 | r/m64, r64CMPB | r8, r/m8 | r/m8, r8CMPB | r8, r/m8 | r/m8, r8CMPPD | imm8, xmm1, xmm2/m128 | imm8, xmm2/m128, xmm1CMPPS | imm8, xmm1, xmm2/m128 | imm8, xmm2/m128, xmm1CMPSD | imm8, xmm1, xmm2/m64 | imm8, xmm2/m64, xmm1CMPSS | imm8, xmm1, xmm2/m32 | imm8, xmm2/m32, xmm1ENTER | 0, imm16 | imm16, 0ENTER | 1, imm16 | imm16, 1操作数顺序不同 在 x86 中，一些常见指令是这样的：</description>
    </item>
    
    <item>
      <title>大三实习求职之旅</title>
      <link>https://kcode.icu/posts/interview/2021-3-nowcoder/</link>
      <pubDate>Tue, 30 Mar 2021 17:20:20 +0000</pubDate>
      
      <guid>https://kcode.icu/posts/interview/2021-3-nowcoder/</guid>
      <description>说在前面 经常“吸”社区，也要时不时反馈一点，一起延续开源精神。
个人情况：22 届双非一本，从去年 12 月开始面试找寒假的实习，由于学校疫情原因没去成功，于是经过寒假复习“二战”。先后面了跟谁学，腾讯，字节，阿里。
由于我个人情况特殊，从大一开始使用 Go 语言到现在，了解比较多，C++ 用来写题，有的问题可能不具有参考价值，理性看待。
另外有的问题确实记不得了，大家不要太看重问题，因为大部分都是八股的题型，网上一搜一大堆，博客的总结能几万字，但是没有面试官喜欢听这种东西，都是搞技术的不喜欢花里胡哨，我曾经就因为答协程区别和特点被反问 你这个有点像背的，，不过我也没反驳，下次总结避免就好了。你要答出问题的本质，底层的思考，说出跟别人不一样的地方，用有些面试官的话来说就是 这个问题我只想听你说一句话，我看我能不能听到。说白了就是你说了一大堆可能在对面听来都没听到，说不到点子上等于没说。
另外本文我主要突出面试过程，不是面试问题的总结帖（有的问题我真的记不得了 :(。
好了，不说废话了，大家看正文吧，有什么问题欢迎找我聊~
跟谁学两面 oc，第一次面试 一面 自我介绍
项目：
  用go写的rpc框架的具体功能细节，注册中心单机还是分布式的，其中一个挂了怎么办？一致性，可靠性怎么保证的。超时控制，加锁和管道支持并发，单机（考虑了多机情况，说了已经在todo里了）。
  Go+QML 利用cgo实现的跨平台桌面应用功能，场景，为什么要写这个东西？ 我说为了性能，追问性能如何体现，如何测试的，如何优化。答宏观上从任务管理器，top中看，细节上从pprof进行性能定位调优，从火焰图上看。追问pprof还有什么功能，你一般是怎么定位问题的？回答还是先具体再细节。
  这时候我就俩项目，后面怕不够，又想拿go写个web的，正好学校说需要重构某个子选课系统，就跟同学接了，这个下面说。
写个快排？时分复杂度分析？看你了解过go的标准库实现，说说go的快排源码怎么实现的，答三数取中，根据数据量选择多种排序方式组合，追问细节我就不知道i了，，确实没看过这个。。他说没事。
协程与线程区别？为什么快，快在哪了？自定义了4个伪寄存器 fp sp sb pc，轻量，初始2KB动态伸缩，由runtime管理，对os透明等等各种原因，又说了以下gmp调度的优势。追问寄存器是什么，你对寄存器还有什么了解。我说了一点关于go和c 在寄存器方面使用的不同，函数传参，调用堆栈等等，扯了点汇编区别，就又问了几个汇编指令，过了。
虚拟地址，物理地址区别
rpc与http区别，使用场景，自己总结一下再说几条
还有点八股没啥难的 有点忘了。。
也没问啥难点一面就过了
二面部门leader 详细聊虚拟地址与物理地址，为什么分这俩，段页作用，为什么内存占用能比实际要大的多（还是虚拟地址作用），循序渐进的从现象到技术实现来问，不是考试。
go+qml项目问了几个关于cgo的特性，聊了聊优劣势，看得出来这个项目好多面试官也不懂，cgo特性一是用起来结合其他语言的时候确实有坑点，二是拿go写gui有点杀马特，不招人待见？
闲聊网络跟os，最后问了个智力问题，就过了。
总结 感觉难度不大，缺人进来打杂，要求不高。问了一下前辈，说加班严重，校招的话工资高了可以放备选考虑去。。面试体验还不错，自己缺乏一点回答技巧上的经验，聊技术不能一下到点子上，废话略多。
字节二面挂，腾讯二面挂 这俩对我帮助最大。
字节 字节对我最大的帮助是深度思考算法，为什么要这么写，别的方法行不行？
自己感觉有了点面试方面的经验，就投了较大的厂，遭到毒打。
字节一面是算法面，最后写了个单链表归并非递归，勉强通过。
二面上来扣20分钟rpc项目，挖出你这个项目的所有特点为止：
 序列化方式有哪几个，区别是什么，自己写过吗 协议用的哪个，为啥不用udp &amp;hellip;鞭打。。。  当时确实缺少对项目的深度思考，也是参考了声哥的项目，不过他是java写的，用go写起来参考了不少框架源码，rpcx，grpc，实现起来略费劲，时间仓促，底层思考略少。
二面挂是因为问了个快排复杂度，详细分析这三个时间复杂度的结果，怎么来的这个值，举例子说明等等，自己算法这方面当时确实弱项，挂了正常。
腾讯 腾讯对我最大的帮助是看源码，有的东西嚼别人的东西是不够的，应该学习一手资料，详情参考曹大的博客《工程师应该怎么学习》。还是太菜了，缺乏深度思考
几个亿找中位数
搜索树旋转过程
对面应该是c++的，问我map，我说我用go，他就说go也行，你说说go map 时间复杂度，为啥是这个值，为什么这么多数，O1能直接访问到，当时map只了解了一点，遂答的浅。</description>
    </item>
    
    <item>
      <title>Go unsafe.Pointer、uintptr、Pointer之间的区别与联系</title>
      <link>https://kcode.icu/posts/go/2021-03-14-go-unsafe.pointeruintptr%E4%B8%8E%E6%8C%87%E9%92%88/</link>
      <pubDate>Sun, 14 Mar 2021 13:35:20 +0000</pubDate>
      
      <guid>https://kcode.icu/posts/go/2021-03-14-go-unsafe.pointeruintptr%E4%B8%8E%E6%8C%87%E9%92%88/</guid>
      <description>前几天见到了一个问题：
uintptr与 unsafe.Pointer 有什么区别？你可能曾经看到过类似这样的代码：
type T struct { a uint8 b bool c string } t := T{a: 1, b: true, c: &amp;#34;goooo&amp;#34;} Tc := *(*string)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;amp;a)) + unsafe.Offsetof(T{}.c))) fmt.Println(Tc) 这一行代码看似实现的功能非常复杂，其实它就是等价于：
fmt.Println(t.c) 从某种意义上来说，这好像没什么用（确实没啥作用&amp;hellip;），那你再看一段代码：
//go:nosplit func Bytes2String(bs []byte) string { return *(*string)(unsafe.Pointer(&amp;amp;bs)) } //go:nosplit func String2Bytes(s string) []byte { ss := *[2]uintptr(unsafe.Pointer(&amp;amp;s)) b := [3]uintptr{ss[0], ss[1], ss[1]} return *(*[]byte)(unsafe.Pointer(&amp;amp;b)) } 这两个函数实现了 []Byte 与 string 的互转，并且不需要申请任何内存，因为他们共享底层数据空间。
函数前的类似注释的一行是一些指令，用来指示编译器进行一些用户的行为，Go 中的栈帧是可以根据需要动态增长的，一开始只有 2048Byte，是固定在源码中的。而 go:nosplit 就是表明函数栈空间无需动态增长，这在一定程度上增加了效率，但是如果你申请了过量的空间，就会导致程序因为爆栈而 panic。</description>
    </item>
    
    <item>
      <title>深入理解 Go channel</title>
      <link>https://kcode.icu/posts/go/2021-02-22-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3go-channel/</link>
      <pubDate>Thu, 25 Feb 2021 19:35:20 +0000</pubDate>
      
      <guid>https://kcode.icu/posts/go/2021-02-22-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3go-channel/</guid>
      <description>Go 语言的 Channel 关键字是实现其原生并发编程的关键组成，你可能听说过 “不要通过共享内存的方式通信，要通过通信的方式共享内存”，这句话正是针对 Channel 说的。
Go 语言倡导通过通信的方式共享内存，也就是减少锁的使用，尽量都通过 Channel 来进行协程间通信。
其实这被称为一种并发模型名为 CSP（Communicating Sequential Processes），即通信顺序进程。
两个实体 goroutine 通过 Channel 通信，收发消息。
数据结构 Channel 是一种 带锁环状队列，运行时结构定义在 runtime/chan.hchan ，代码也比较容易理解。
type hchan struct { qcount uint // 队列中元素数量 	dataqsiz uint // 环形队列总大小 	buf unsafe.Pointer // 底层数组指针 	elemsize uint16	// 元素大小 	closed uint32	// 是否已关闭 	elemtype *_type // 元素类型 	sendx uint // 发送端下标 	recvx uint // 接收端下标 	recvq waitq // 接收端等待队列 	sendq waitq // 发送端等待队列  // 保护 hchan 并发访问的字段 	lock mutex } type waitq struct { first *sudog	// 等待队列链表的头节点 	last *sudog	// 尾节点 } 通过两个指针指向发送端和接收端接下来的操作位置，结合锁机制完成数据操作，这是很容易想到的并发处理方式。runtime/chan.</description>
    </item>
    
    <item>
      <title>记 MySQL 5.7.5 及以上实现的功能检测依赖报错分析</title>
      <link>https://kcode.icu/posts/chore/2021-02-24-%E8%AE%B0-mysql-5.7.5-%E5%8F%8A%E4%BB%A5%E4%B8%8A%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%9F%E8%83%BD%E6%A3%80%E6%B5%8B%E4%BE%9D%E8%B5%96/</link>
      <pubDate>Wed, 24 Feb 2021 15:15:13 +0000</pubDate>
      
      <guid>https://kcode.icu/posts/chore/2021-02-24-%E8%AE%B0-mysql-5.7.5-%E5%8F%8A%E4%BB%A5%E4%B8%8A%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%9F%E8%83%BD%E6%A3%80%E6%B5%8B%E4%BE%9D%E8%B5%96/</guid>
      <description>秉承着 “软件均使用最新版本，学习均从文档入手” 的理念，学习使用 MySQL 我也是在使用最新的大版本 MySQL 8，而在技术发展过程中，一个不可忽视的因素就是兼容性，在保证新特性无误的同时必须确保以前的功能不受影响，如果不能保证这一点，那么许多使用者在迁移的时候就需要考虑很多改动成本，除非不是大改动，一般都会考虑到这一点，比如 HTTP/2 、TLS/1.3 等等。
错误描述及分析 最近为学校写一个选课平台时关系型数据库使用的是 MySQL 8+，使用 Group by 时报了这个错误：
ERROR 1055 (42000): Expression #2 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#39;mydb.t.address&#39; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by意思是说 select 列表中包含了非聚合列，其并不函数依赖于 Group by 子句中的列。并且和 sql_mode 这个配置项的 only_full_group_by 值冲突。不过这篇文章并不只是单纯说解决方法，如果想要解决方法请直接移步文末。
可以确定的是同样的使用了 Group by 的 SQL 查询语句在低版本中是正常的但是高版本却不行，猜测可能是版本差异造成的，而且还是因为这个配置项导致的。
所以虽然我们一开始可能看不懂这个报错信息，但是我们通过一些分析已经定位了问题，并且报错的错误码明显（ERROR 1055(42000)），报错提示信息清楚，并不难找到解决方法。</description>
    </item>
    
  </channel>
</rss>
