<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>汇编 on wasabi</title>
    <link>https://www.kcode.icu/tags/%E6%B1%87%E7%BC%96/</link>
    <description>Recent content in 汇编 on wasabi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Sun, 04 Apr 2021 20:30:20 +0000</lastBuildDate><atom:link href="https://www.kcode.icu/tags/%E6%B1%87%E7%BC%96/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go 使用的 plan9 汇编语言初探</title>
      <link>https://www.kcode.icu/posts/go/2021-03-20-go-%E4%BD%BF%E7%94%A8%E7%9A%84-plan9-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%88%9D%E6%8E%A2/</link>
      <pubDate>Sun, 04 Apr 2021 20:30:20 +0000</pubDate>
      
      <guid>https://www.kcode.icu/posts/go/2021-03-20-go-%E4%BD%BF%E7%94%A8%E7%9A%84-plan9-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%88%9D%E6%8E%A2/</guid>
      <description>plan9 汇编既不同于 Intel-x86 家族的汇编，也不与 AT&amp;amp;T 标准相同，作者是 unix 操作系统的同一批人，bell 实验室所开发的，其实 plan9 是一个操作系统，我们主要关注构建它的汇编语言。
Go 语言早在 1.5 版本就实现了自举，即 使用 Go 语言去写 Go 语言。Go 的底层实现是使用 plan9 汇编完成的，并不是我们常见的 Intel 家族汇编，它与其他的汇编有几个不同点，在下文中一边比较一边介绍。
伪寄存器 plan9 抽象了 4 种伪寄存器：
 FP（Frame Pointer），帧指针，快速访问函数的参数和返回值。 SP（Stack Pointer），栈指针，指向栈顶。 SB（Static base pointer），静态基址，全局变量。 PC（Program Counter），其实就是 IP（Instruction Pointer）的别名，指向下一条指令的地址。jmp等跳转指令还有分支控制等原理就是通过修改这个值。在 8086 机里等价于 CS:IP。  其实就是对 CPU 的重新抽象，这个抽象结构与具体的 CPU 结构无关。
它们之间的具体关系如下图：
与x86汇编的差异 许多人之前广泛了解的汇编可能是 AT&amp;amp;T 格式或者传统 Intel-x86 格式，AT&amp;amp;T 规范与 x86 有许多不同，而 plan9 与 AT&amp;amp;T 有许多相似的地方，但不完全等价。还是需要我们重新学习，这里列举一些常见区别。
操作数顺序不同 在 x86 中，一些常见指令是这样的：
MOV EAX, 10	;EAX=10 MOV AH, [BL]	;AH=*BL 而在 plan9 中操作数的顺序会相反：</description>
    </item>
    
  </channel>
</rss>
