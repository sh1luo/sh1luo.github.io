---
title: "Go 使用的 plan9 汇编初探、与传统汇编差异与 Go 函数调用栈帧分析"
date: 2021-04-04 20:30:20
tags:
  - Go
  - 源码
---

## plan9汇编初探

plan9 汇编既不同于 Intel-x86 家族的汇编，也不与 AT&T 标准相同，作者是 unix 操作系统的同一批人，bell 实验室所开发的，其实 plan9 是一个操作系统，我们主要关注构建它的汇编语言。

Go 语言早在 1.5 版本就实现了自举，即使用 Go 语言去写 Go 语言。Go 的底层实现是使用 plan9 汇编完成的，并不是我们常见的 Intel 家族汇编，它与其他的汇编有几个不同点，放在下文 `与传统汇编差异` 解释。

我们从最简单的例子出发。

### 看一个最简单的程序

```go
package main

func add(x, y int) (sum int) {
  z := x + y
  return z
}

func main() {
  c := add(2, 3)
}
```

在命令行中执行 `go tool compile -s main.go` 查看plan9汇编代码：
```masm
mov eax
```

我们只关注 main 函数调用 add 函数的过程：



## 与传统汇编的差异





## 函数调用栈帧汇编





### 指令差异

- 没有 push，pop 等栈操作，栈的增缩是通过对 sp 栈顶寄存器的加减实现的，例如 +8（sp）
- 操作数的大小不是通过区分操作码来实现的，而是通过操作码的后缀实现，例如复制 `ax` 寄存器低 1 字节到第二字节，在 `x86` 汇编中是通过 `mov ah,al`，而在 plan9 中则是通过 `movb al,ah`
    - b w d q分别代表1 2 4 8 Byte，含义是byte，word，double word，quatury。
- 操作数在第一个参数，结果放在第二个参数，与intel汇编相反，具体看第二条

> 我们学习 plan9 汇编其实也并没有太大困难，前期在学习时也未必要看懂全部的汇编代码，可先学习大概思路，再深入了解即可。

但是为什么 plan9 不与 x86 系兼容呢，而要单独开发一套自己的语法呢，我看了不少人的解释，貌似是因为 unix 团队是学院派，特立独行，也不屑于商业化（就是玩
