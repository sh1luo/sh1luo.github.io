---
title: "Go 使用的 plan9 汇编初探、与传统汇编差异与函数调用栈帧汇编分析"
date: 2021-04-04 20:30:20
tags:
  - Go
  - 源码
---

## 了解plan9汇编
plan9 汇编不同于 intel 家族的汇编，开发者是 unix 操作系统的同一批作者，bell 实验室所开发的，go语言最初的三个开发者之一 ken 正是其中之一，其实 plan9 是一个操作系统，只是我们主要关注它的汇编。

go 语言早在 1.5 版本就实现了自举，即使用 go 语言去写 go语言。go 的底层实现是使用 plan9 汇编完成的，并不是我们常见的 intel 家族汇编，它与 intel 系汇编有几个不同点：

- 没有push，pop等栈操作，栈的增缩是通过对sp栈顶寄存器的加减实现的，例如 +8（sp）
- 操作数的大小不是通过区分操作数来实现的，而是通过限制操作码的后缀后缀，例如复制ax寄存器低1字节到第二子节，在intel x86汇编中是通过 `mov ah, al`，而在 plan9 中则是通过 `movb al, ah`
    - b w d q分别代表1 2 4 8byte，含义是byte，word，double word，quatury。
- 操作数在第一个参数，结果放在第二个参数，与intel汇编相反，具体看第二条
- 。。。

我们学习 plan9 汇编其实也并没有太大困难，前期在学习时也未必要看懂全部的汇编代码，可先学习大概思路，再深入了解即可。

但是为什么 plan9 不与 intel 系兼容呢，貌似是因为 unix 团队也不屑于商业化。

## 从一个简单的程序出发

```go
package main

func add(x, y int) (sum int) {
  z := x + y
  return z
}

func main() {
  c := add(2, 3)
}
```

在命令行中执行 `go tool compile -s main.go` 查看plan9汇编代码：
```masm
mov eax
```

我们只关注 main 函数调用 add 函数的过程：

