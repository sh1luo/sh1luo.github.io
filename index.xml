<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>失落</title>
    <link>https://www.kcode.icu/</link>
    <description>Recent content on 失落</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Fri, 22 Jan 2021 23:35:20 +0000</lastBuildDate><atom:link href="https://www.kcode.icu/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>深入理解 Go map</title>
      <link>https://www.kcode.icu/posts/go/map/</link>
      <pubDate>Fri, 22 Jan 2021 23:35:20 +0000</pubDate>
      
      <guid>https://www.kcode.icu/posts/go/map/</guid>
      <description>哈希表 几乎所有语言都有 哈希表 这个数据结构，能够在平均 O(1)，最差 O(n) 的时间复杂度增删改查元素，Go 语言哈希表的精妙设计使得它几乎不会出现 O(n) 的糟糕情况。这篇文章我就带你从使用到底层由浅入深地探究 Go map 的奥秘，一起作一个不只是会用的”大神“。
问题来源于实际，我们先看看这些问题 ：
 声明。当我使用 :=，var，make，甚至 new 声明 map 的时候，编译器帮我们做了什么事情，它们有什么区别？ 增删改查。使用 数组+链表 的情况下如何设计才能避免 O(n) 的最差情况？ 注意事项。map 的键有什么要求？map 是值类型还是引用类型，函数传参时会有上层影响吗？是并发安全的吗？  还有一个常识是 Go map 的遍历是随机的，即多次遍历输出的结果集不同。
设计方式 Go map 实现哈希表使用的是 数组+链表 的形式，也就是使用链地址法解决的哈希冲突。这种方式桶的大小和元素个数之间没有关系，另外还有开放定址法，这是个宽泛的名字，具体包含线性探测法，再哈希法，平方探测法等等。
为了降低 map 操作的时间复杂度，引入了一个 负载因子 的概念，这个概念在其他实现哈希表这个数据结构的语言里也都有，比如 python 中这个值被定义为 2/3，Java 中是 0.75，这个值评估了哈希表里 实际上最好只存 多少比例的元素，而不是一直等到满载再处理，因为多到一定程度效率 可能 就低了。在 Go 语言里这个值被定义为 6.5，即每个桶里最多存 6.5 个，包括溢出桶。
数据结构 当我们在 Go 语言中声明一个 map 的时候，实际上就是创建了一个 hmap 的结构体，它定义在 runtime/map.go 文件下。 哈希表就是实现一个映射关系，给出自变量 x，能够通过平均 O(1) 的时间复杂度方法找到这个元素所对应的因变量 y=f(x)，这里有个非常重要的限制：对于无限的输入，需要给出有限的输出。在哈希函数中这句话成立，在 Go map 中也成立，指的是只有有限的桶，怎么放无限的元素？我们需要考虑这个问题。</description>
    </item>
    
    <item>
      <title>博客图床解决方案</title>
      <link>https://www.kcode.icu/posts/chore/imgs/</link>
      <pubDate>Wed, 20 Jan 2021 15:45:13 +0000</pubDate>
      
      <guid>https://www.kcode.icu/posts/chore/imgs/</guid>
      <description>很多人应该都听说过来人说过要写博客进行总结记录，一是说自己学习过程的复盘，二是在某些时候向不认识自己的人间接显示自己的大致水平。不过如果没有人“手把手”教的话我相信还会遇到各种各样的问题的，这篇文章就介绍一下在博客中必不可少的图片网络地址解决方法，也就是图床。它的目标是在你写文章的过程中可以一键插入目标图片并自动上传到网络，就像你使用本地图片一样快捷。
图床的目的就是把你的本地图片上传上去，从而能获得它的网络地址。当然了，只使用图床也是可以的，但是需要配合对应的工具上传拿 URL（比如 OSS）或者纯手动（GitHub/Gitee），非常不方便 一点也不极客，所以需要配合其他工具一键快速拿到它对应的网络地址（URL），所以我在下面介绍了我使用到的工具，仅供参考。
 评估用的稳定性指你上传的图片会不会在某个不确定的时间突然挂掉，让你的文章出现大量图片 404 丢失的情况。
 图床 这里我介绍三种图床，列出优缺点。可以根据需要进行选择。
GitHub/Gitee GitHub 和 Gitee 是干什么的我就不多说了，它们也是可以作为图床使用的，前者境内访问较慢，后者较快。没有账号可以免费注册一个，然后随便创建一个公开仓库，把图片上传上去就可以获取它的 URL 了，比较简单粗暴。
优点：稳定性较好，空间无限，上手难度较简单
缺点：无法阻止盗链，无法管理（原本目的就不是作为图床，没有统计流量等功能）。
总结，如果你是新手，不担心自己的图片被别人轻易获取 ，随缘使用图床，这个是首选。
OSS OSS （Object Storage Service）即对象存储服务，用来做个人博客的图床有点小题大做，腾讯云、阿里云等等提供 OSS 的平台都可以，一般需要续费，一年 50G 左右话 10 块钱左右。
优点：可控性比较强，提供了专业的平台，你能想到的各种需求基本都有，包括防盗链，流量统计与分析等。
缺点：对新手不友好，根据流量付费。
总结，如果你未来博客流量会不断增大，出于可控考虑选这个，流量较小的新人不考虑。
不稳定第三方 也可以使用这种第三方的图床，没有任何操作步骤，上传完就拿到 URL，当然事物都有两面性，这种极致快捷带来的就是不稳定，就跟当年的新浪图床一样，你不知道什么时候它就没了。。
优点：简单快捷打开一键就用，免费
缺点：不知道什么时候你的图片就被人家清了。。然后你的文章里的图片就全部 404 了。。
总结，随缘党首选不解释，懂得都懂。
工具 这里就介绍我使用的两个配合工具，其他的可以自行搜索。
typora typora 是一款 Markdown 文本编辑软件，我相信写过 Markdown 的都听说过，它的特点是真正的实时显示，不左右分栏，扩展性强，灵活可配置。我个人平时写 Markdown 文本都是使用这个软件，具体可以去它的官网首页看，十分推荐。
PicGo PicGo 是一款使用 Node + Electron 开发的跨平台可视化图片上传开源软件，支持 N 种图床平台，配置灵活简单，最重要的是它支持插件功能，理论上支持任意图床平台的使用（需要提供相应上传下载的 API），可以自行开发插件。操作也比较简单，把图片拖到框里就可以拿到 URL。这张图是 gitee 相关配置，其他平台类似，只需若干个必要参数即可：
配合使用 前面说的这两种工具可以结合使用快速进行写作，在 typora 主界面上方，文件-&amp;gt;偏好设置-&amp;gt;图像，修改 PicGo 路径为你安装的路径下的 exe 地址。这样就可以做到你在 typora 里编辑时直接粘贴图片到文档里一键点击上传，非常方便。当然了，如果你不需要 typora，或者使用的是别的 Markdown 编辑器，也可以只使用 PicGo。</description>
    </item>
    
    <item>
      <title>《一起了解 Go 语言》</title>
      <link>https://www.kcode.icu/go/</link>
      <pubDate>Sun, 17 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.kcode.icu/go/</guid>
      <description>我不太喜欢只看问题的表面，总是不经意间思考了这么多，希望对你有所帮助。
我打算围绕 Go 的底层实现写一些自己的思考和探究，我在写之前参考了大量博客等”二手资料“，写时手边也拿着 Go 语言最新版源代码这样的”一手资料“，其一是因为官方源码和文档永远是我们最好的第一学习工具，其二是我个人在没看到源信息时有种不踏实的感觉（可能跟以前踩过坑有关），所以文中说到的任何知识点均会附带源码说明，由于 Go 语言特殊性，必要时还会附带汇编代码辅助，最后我还会通过理论来推动实践为你做个演示。
标记的内容已经列入计划，正在赶工中 😄
 一：深入表象  「map」深入理解 Go map ，正在&amp;hellip; 「string」简单又有”东西“的字符串 ，正在&amp;hellip; 「slice」灵活高效的切片 ，正在&amp;hellip; 「string&amp;amp;slice」用理论驱动实践 ，正在&amp;hellip;   二：深入理解  「method」方法到底是什么 ，正在&amp;hellip;   三：深入灵魂  「GPM」Go 调度模型为什么这么特别？ ，正在&amp;hellip; 「GC」入个 GC 算法的门？ ，正在&amp;hellip;    我的公众号 平时喜欢分享 Go 语言、学习历程，欢迎关注我的公众号：</description>
    </item>
    
    <item>
      <title>谈谈最常见的 HTTP</title>
      <link>https://www.kcode.icu/posts/http/</link>
      <pubDate>Fri, 15 Jan 2021 23:10:22 +0000</pubDate>
      
      <guid>https://www.kcode.icu/posts/http/</guid>
      <description>标题的”最常见“我想应该没有什么争议，对大多数人来说日常生活中接触到最多的应用层协议就是 HTTP了，从聊天软件、浏览器页面再到各种游戏实现，它们无处不在。这篇文章我就带你来看一看这个处于 OSI 标准最上层、最常用也是最普通的 HTTP 它究竟有什么“东西”，一起作为一个不只是听说过的“大神”。
这篇博客我想阐述除书本概念之外的一些可能你 理解不深刻 的问题的 个人理解，希望对你有所帮助。
HTTP是什么 超文本传输协议（Hypertext Transfer Protocol，HTTP），是一个应用层面上的，也就是软件双方通信的数据规则，是通信的基石。不然你发给我一串 @#$%$%^$%^，只有你能看懂，我怎么知道你说的是什么玩意？双方按照这个规则去通信，有什么需求都在这个规范里写好了发给对方，对方就知道你想干什么，就可以也按照这个规范给你回过去，就是这么简单。只是因为随着技术的发展，所遇到的问题越来越多，从功能需求，再到安全、效率、可读性等等，不得不提出一系列的解决方案去完善，最终变得很 ”臃肿“ 罢了。但是你应该明白，这就是一个为应用程序通信所提出来的一个基础通信协议。
HTTP方法有什么“实际区别” 你可能听说过类似 “GET 和 POST 有什么区别” 这种问题，其实说到底从底层上来说，它们之间 没有任何区别，仅仅是约定、规范。 也就是说 按照约定，GET 方法的请求 不应该 携带请求体，并且在以前 Postman 这类客户端模拟软件也是不允许构造这类请求的，但是后来也是支持了。
但是，如果你强行带了请求体，是没有任何问题的。你甚至可以把 GET 方法携带上请求体用来登录，使用 POST 请求用来获取 HTML 等静态资源，用 DELETE 方法来为数据库增加一条记录，只要你后端程序员老哥不把你捶死（手动狗头） 🤣🤣🤣
各个版本之间的发展史 HTTP 比较重要的几个发展时间节点是 0.9、1.0、1.1、2.0 和 3.0，每一次的版本变迁都是为了解决前一个版本的性能不足或者功能不完善，我不推荐死记硬背，即使它被称为计算机八股文。
http 0.9和1.1 在 HTTP 0.9 的时候只有 GET 方法，1.0 补充了 POST，DEL 方法完善语义，还添加了几个首部，这个阶段的 HTTP 主要就是完善功能。
1.0 和 1.1 的最大区别就是长短连接了。在 HTTP 1.1 将长连接设置为了默认，也就是：
Connection: keep-alive 在这之前这个字段的默认是 close，长连接的好处是显而易见的，由于 HTTP 是基于 tcp，如果总共传输三个文件，1.</description>
    </item>
    
    <item>
      <title>一些常见Go语言及面试问题的整理</title>
      <link>https://www.kcode.icu/posts/interview/somequestions/</link>
      <pubDate>Fri, 15 Jan 2021 21:10:55 +0000</pubDate>
      
      <guid>https://www.kcode.icu/posts/interview/somequestions/</guid>
      <description>这篇博客记录一些关于面试常见的 Go 语言方面的问题，希望能帮到大家，等待更新中。
Go make和new的区别，使用和底层？ Go内存管理 goroutine 什么时候会阻塞？ goroutine有几种状态？ m操作g的时候有自旋与非自旋状态？
线程有哪些状态 注册中心挂了怎么办？ N节点，raft一致性？
反射底层原理？ 通过反射执行函数，拿结构体tag？ 锁机制？饥饿模式正常模式？锁底层原理？ channel使用，坑，底层原理？ </description>
    </item>
    
    <item>
      <title>几经周折的博客变迁史</title>
      <link>https://www.kcode.icu/posts/chore/blog_journey/</link>
      <pubDate>Wed, 06 Jan 2021 21:13:13 +0000</pubDate>
      
      <guid>https://www.kcode.icu/posts/chore/blog_journey/</guid>
      <description>仔细想起来我的博客旅程也有好多年了，兜兜转转地走了不少弯路，也确实在这个过程中学到了很多东西，大致有这些时间节点：
 尝试购买了国内域名和学生机服务器，看到自己写的内容能在公网上让全世界的人看到就高兴了好久，内容很随意，自己管理。 使用 hexo 框架系统化内容，并部署到 GitHub Page 上交给 GitHub 管理。 发现了国内访问速度更快的 Gitee Page。 再次购买域名，使用 CDN 加速国外空间，未果（下文说）&amp;hellip;&amp;hellip;  前前后后也折腾了好几年，技术上的提升我倒觉得不太大，因为折腾地挺多但是都是应用层面上的，对我来说更多的是动手能力的提高，有好多东西不经过自己亲手尝试是根本理解不了的，我前面很多东西就是别人远程或者一步一步告诉我让我去点这个点那个就可以了，但是回过头来问你，你根本不知道发生了什么，甚至隔天就忘，这是典型的不理解、死记硬背式学习方法。
当时配置那个 A 记录，CNAME 记录啥的根本不知道是什么东西，也不知道 DNS 是什么，就是配，成功了就行，不成功就猜，一个个试呗。现在想想，真的是走了不少弯路，如果能系统地学一下多好。不过这些问题也都在我后来的实践以及学习过程中逐一解决了，现在遇到问题也不用像没头苍蝇一样乱撞了，这种感觉很不错 :)
这件事也让我大致理解了一句老话，大致是这么说的：真正厉害的技术人员不是说他写程序一定要多么多么厉害，而是他有非常强悍的问题定位能力（trouble shooting），能解决别人解决不了的问题，而这一切都源自于无数经验的积累以及深度的思考。
下面说我的最后一次迁移：)
 之所以有两个部分是因为买了域名后才发现必须要国内域名并且备案，才能加速国内。我买的是国外域名所以没办法，最后就用 GitHub Page + 自定义域名了。
 GitHub Page+自定义域名 这种方案比较简单（因为GitHub 都帮我们做了），这也是我现在的方式，只不过我的域名是国外的，所以没办法使用 CDN 加速。
你首先需要创建一个名为 &amp;lt;YourGitHubName&amp;gt;.github.io 的仓库，比如 sh1luo.github.io，然后购买一个域名（国内国外都行，国内要备案），因为我们是要使用 GitHub 的自定义域名，所以需要使用 CNAME 记录，在域名服务器处添加两条CNAME 记录 ，就像这样
我是国外的域名，不能使用国内 CDN 加速，正好 CloudFlare 提供免费全球 CDN，虽然效果一般，但是它提供的免费功能也是非常的多，包括各种流量统计分析，也是很良心了。想使用 CloudFlare 当 DNS 服务器做法也非常简单。注册一个账号填上域名信息，然后会提供给我们两个 DNS 服务器域名，我们把原域名服务器商的 NameServers 改成新解析服务器提供的就好了。
当然，如果你本来就是国内域名，就不用这么麻烦了，直接添加两条 CNAME 记录，然后在 GitHub Pages 仓库的发布分支放一个 CNAME 文件，文件内容就是你的 CNAME 地址就可以了，它会自动帮你设置为这个域名并搞定一切的:)</description>
    </item>
    
    <item>
      <title>记人生中前几次面试及思考</title>
      <link>https://www.kcode.icu/posts/interview/2020-12-interview/</link>
      <pubDate>Sun, 03 Jan 2021 21:18:13 +0000</pubDate>
      
      <guid>https://www.kcode.icu/posts/interview/2020-12-interview/</guid>
      <description>写作背景 由于早早有了就业的想法，于是我在大三上学期快要结束的时候便早早地”物色“各大公司的实习了，也是希望能在就业前增加几段实习经历，丰富一下经验。这也是人生中我的第一次面试，感触颇多。特别记录下来自己的总结以及对于假期自己的学习规划。
面试总结 这次我面试的总共有三家公司，跟谁学、字节跳动和腾讯，对我印象最深也是帮助最大的就是”字节跳动“。关于面试的准备大致有三块，简历、技术口述和手撕代码，下面分开说。
简历 我个人使用的简历大致是这样的风格，简约并且色调一致。简历这块我倒没什么卡壳，简历没过的 我猜 都是因为学历等等硬性条件不合适，这也是没有办法的事情。这里需要确保这么几点：
 不要造假，实事求是 。虽然有的公司面试官根本不看你简历问（我的几次实习面试不看，校招社招应该是要看的），但是如果你写熟悉甚至精通，你躲过了 HR，但是人家面试官上来问了一个很简单的问题你答不上来，人家可能没兴趣继续问了。。在面试官心里你的这项技术等于没写，并且有了吹牛的成分，众所周知，搞技术的都不喜欢这种人。 拿出有说服力的证据。 这一条不单指技术也包括其他方面，举个例子，如果你写了你优化了这个项目，那么等于没写，谁知道你优化了多少？比如原来服务器 CPU 总是跑到 90+%，然后你通过 xxx 手段优化，优化到了稳定在 70% 左右，这就比较有说服里，面试官也比较好针对你的这个点去问。再举个例子，你在个人相关那栏里写英语能力强，学习能力不错，热爱新技术，咱就不说过没过四六级了，人家让你现场看个技术文，获取跟你聊两句，你蒙蔽了，尴尬不。问你平时咋学习的，你磕磕巴巴说不出个所以然，或者一点逻辑没有，东一头看书，西一头看视频，再来一手看野生技术文章，你说尴尬不。 注意行业基础。 我拿技术来说，搞技术的，你说你写了个热爱技术，结果写个 GitHub ，都能拼错，写成 Github 等等，写个 CSDN 写成 Csdn ，虽说这不是什么大事，但是这些书面东西，我们搞技术的不能犯错的，这给人的印象就是你很不专业，或者说你接触的很少以至于记不清楚。假如说你说热爱开源，整天 GitHub 排行榜逛个遍，你告诉我你不知道 GitHub 怎么拼，不合适吧？我曾经见过一个人说他懂这懂那，结果拿来简历一看，关于技术的名字错了好几个，还说自己热爱这些，实际水平也就可想而知了。  我个人关于简历这块总结就是这样，虽然说简历很重要，但是我认为还是不难写的，把握好这些点即可 :)
技术口述 这部分是面试重头戏，除去手撕代码部分其余就是这个了（还可能有项目环节），对于这部分我感触最多。大体是，以前我认为掌握一种技术就是会用来解决某个问题就完事了，不想探究怎么实现的。举个例子，现在需要有个从反序列化出来的 json 字节数组里拿某个字段的值，以前的我就是去找个库用用完事了，现在经过大厂面试洗礼的我是这样的：我能不能自己写一个，看他代码不多呀，这样写效率高不高？紧接着看了源代码之后就会惊叹：哇还能这么设计，哇这个还能这么用，厉害了。。。真实。。。
而实际面试里也是这样的，我们不能只考虑表现层面的东西，而要去探究其底层大致的实现原理，只有这样，当你遇到问题的时候才能有初步想法从而去解决，而不是只会去问别人。别人不告诉你或者怎样你就解决不了了，不是有那么一句话说得好嘛，好的工程师（注意不是程序员）并不是他写的代码多厉害，而是他遇到问题总是能快速定位问题，并以最优雅的方式去解决，这一点值得我们深思。学会用工程师的视角去解决问题也是我们每一个人的最终目标。
在面试过程中我也遇到了很多之前没考虑过的问题，举个例子，我写的 RPC 框架里，大的问题比如说 注册中心挂了怎么办？能不能自动通过 .proto 文件生成规范的并且与我们框架配合使用的 RPC 代码？小的问题比如说 底层用的 NIO，NIO是什么，为什么快等等。因为我这个框架说白了只在运输层以上工作，我只在运输层以上思考，也就是说只是应用层面理解了而已，只是更深一点点的应用层面罢了，所以当面试官问我一系列深层次的问题后，我的问题就暴露出来了：对这个框架没有进一步的思考和认识。所以这也是我接下来要去思考和改进的一个点。项目大致都是如此，比如你写了一个 Web 类型的项目，用到了某某框架、技术或者标准库，你就要思考为什么它很好？好在哪了？我个人对它有优化吗？我实际上做了什么事情呢？我能从哪些方面提高它的并发量或者说是功能技术创新呢？
总结来说就是项目要有一定规模，有一定自己的思考在里面，别人问你关于你项目的特色，你的工作点，你都有的说。
假期规划 </description>
    </item>
    
    <item>
      <title>手写一个RPCg（上）</title>
      <link>https://www.kcode.icu/posts/rpc/rpcg/</link>
      <pubDate>Sat, 28 Nov 2020 15:45:13 +0000</pubDate>
      
      <guid>https://www.kcode.icu/posts/rpc/rpcg/</guid>
      <description>须知 可能看到这里的一部分人还不知道什么是 RPC，也不知道为什么要用 RPC，内心：HTTP不香吗？那么你需要首先看一下这篇文章：
 你觉得HTTP哪都好用是因为你不知道RPC
 已经实现的 这篇文章我会带你手写一个简易版本的 RPC 框架，这个框架会支持如下这些功能：
 多种网络传输方式 服务端自动注册可导出服务 可以心跳保活的注册中心 服务注册与服务发现 多种序列化方式 超时控制 一些负载均衡策略，一致性哈希、平滑带权轮询等  未来需要做的   自定义的代码生成插件
  一种压缩方式
  基于服务器时延的负载均衡策略？
  心里有数 ”切忌重复造轮子“这句话你应该听过，不过这个”框架“的目的是带领我们大致了解 RPC 框架的工作过程，目标并不是工业级应用，我想你也一定清楚用框架和自己写框架对框架的理解程度有什么区别。也不必把 RPC 想成多么”高端“的技术，RPC 也只是一个调用，微服务的一个组件，从小的地方出发更容易让人接受罢了。好了，话不多说，让我们正式开始。
俯瞰RPCg 这个图向我们展示了最基本的 RPC 调用关系：服务端将自己的服务注册到注册中心，客户端从注册中心获取所有服务端的所有信息，在拿到这些信息之后带着自己的请求去访问某个服务端的服务。你可能会问为什么要多个”第三者“注册中心出来呢，我直接就只有客户端和服务端多方便，那你需要思考以下问题：
 直接通信是不是需要将通信的地址等服务端信息硬编码到客户端的代码中？如果服务端节点数改变了怎么办，难道手动删改代码？ 客户端怎么知道服务端可不可用？难道需要服务端开个服务专门去处理这类信息吗？这属于服务端的业务吗？ &amp;hellip;&amp;hellip;  我想你应该大致能明白为什么需要这个注册中心了，就是屏蔽对方对己方的感知，通过一个第三方中介来提供/提出自己的服务/需求，这就够了，你可以类比 房产中介，婚介所等等机构，当然，注册中心还有很多功能，我们这里为了学习，就只提供这部分功能了，更多的需要留给你去探索 :)
我们再想想，我们现在有了三个主体，之前有不同的需求，怎么提供通信。业界有非常多的解决方法，比如 gRPC 的 HTTP/2.0，它的优势也是显而易见的：多路复用，pipelining 的通信方式，效率大幅提高，不必在等待对方的回复；首部压缩，这里我需要说明一下，RPC 调用大部分是服务端内部的互相调用，比如公司机房里 50 台机器之间相互调用，需要保证传输的效率，也就是说传送的数据要尽可能地小，这才有了 Protocol Buffers 的数据格式，所以经过压缩的首部数据量更小，效率更高。还有 tcp 连接，优势是简单等等。
等待更新&amp;hellip;&amp;hellip;.</description>
    </item>
    
    <item>
      <title>你觉得HTTP最香是因为你还不知道RPC</title>
      <link>https://www.kcode.icu/posts/rpc/rpcvshttp/</link>
      <pubDate>Tue, 10 Nov 2020 21:30:13 +0000</pubDate>
      
      <guid>https://www.kcode.icu/posts/rpc/rpcvshttp/</guid>
      <description>我在动手写 RPCg 这个”框架“之前看了大量的文章阐述 RPC 与 HTTP，这篇文章是比较不错的一篇，我翻译过来和你分享一下 :)
REST vs. RPC你要使用API去解决什么问题？ 有一则关于这个农民的笑话，他被问到”为什么他要尽量避免耕种出‘童话环’的形状“，他回答道，”因为如果我不那么做，我就会变成傻子“。（第一段的引用故事可暂时不关注）。
许多人关于他们自己构建的 APIs 会说同样的话，事实上，去思考一下你要用你的 APIs 去解决什么问题这非常重要，因为你所创建的 API 的风格和你所使用的技术都依赖于你上面的回答。
根据调用 自从 FORTRAN Ⅱ 在1958 年提出调用（也叫函数）这个概念，函数（调用）就一直是组织计算机代码的主要结构。所有现在主流被用来构建和使用 API 的编程语言例如 Java,Javascript, Python, Golang, C/C++ 和 PHP 都使用调用（也就是函数）来作为他们的主要组织结构。因此这数十年来”函数调用“以远程过程调用（RPC） 的形式称为设计和实现分布式 API 的主要模型也就不足为奇了。
如果你要问大多数软件开发者为什么要定义和构建 API，他们可能会解释说他们有个应用，它需要实现多个分布式组件，并且这些组件之间可以互相调用，来使整个应用程序正常运行。他们也可能说需要实现由多个应用程序使用的服务 API。</description>
    </item>
    
    <item>
      <title>Linux du/df命令总结</title>
      <link>https://www.kcode.icu/posts/chore/linux_df_du/</link>
      <pubDate>Wed, 04 Nov 2020 18:15:13 +0000</pubDate>
      
      <guid>https://www.kcode.icu/posts/chore/linux_df_du/</guid>
      <description>linux 在我们日常学习中用的非常多，连接远程 linux 服务器，使用各种 linux 命令，或者物理机就是 linux 系统或者 MacOS。如果你想要学习进阶知识，linux 已经是必不可少的一个组件了。这篇博客记录一下 linux 下常被混淆的 du/df 命令。
df df 就是 “disk free” 的缩写，一般是用来快速浏览你的文件系统，会显示所有磁盘的大小，使用空间，剩余空间，使用百分比还有磁盘挂载到哪个分区上了。使用的时候一般要带上 -h 参数来增加可读性。这些数据都是从挂载点或者文件系统级别计算出来的，比较 “宏观”。
而且，-h 标记会使你的数据四舍五入更方便显示，比如它显示 3G 的大小，实际上可能是 2.9G 或者 3.1G，并不确定。
du du 就是 “disk usage” 的缩写，如果你需要计算某个特定目录大小的时候非常好用。一般搭配 -sh 参数让结果更易读，比如这样：
df VS. du 看了这两个命令大致用法后，它们在使用场景是什么呢，众所周知不结合使用场景的技术都是耍流氓。大致可以这样总结：df 命令提供一个关于你整个文件系统的概览，比如你多少空间正在使用等等，du 命令更倾向于计算某个目录的精确快照。
如果非要说哪个的结果更有用一点，我觉得是 du。举个例子，我在 /var 目录下安装一个第三方包时遇到了一个目录空间不足的错误，那么我就可以先跑一下 df 命令去看看这个目录的空间来确认一下这是不是真的。我如果看到 /var 有足够空间，那我会接着跑一下 du /var 去看看是它的哪个子目录因为空间不够报的错。这样我就可以一直通过 df  去缩小出错目录的范围，直到找到问题。
理解这些命令的区别能让我们串联使用这些工具，从而更快的定位并解决我们所面临的绝大多数的问题。</description>
    </item>
    
  </channel>
</rss>
