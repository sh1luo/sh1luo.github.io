<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>失落</title>
    <link>https://www.kcode.icu/</link>
    <description>Recent content on 失落</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Fri, 15 Jan 2021 23:10:22 +0000</lastBuildDate><atom:link href="https://www.kcode.icu/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>聊聊你最常见的HTTP</title>
      <link>https://www.kcode.icu/posts/http/</link>
      <pubDate>Fri, 15 Jan 2021 23:10:22 +0000</pubDate>
      
      <guid>https://www.kcode.icu/posts/http/</guid>
      <description>标题的这句话我想应该没有什么争议，对大多数人来说日常生活中接触到最多的应用层协议就是 HTTP了，从聊天软件、浏览器页面再到各种游戏实现，它们无处不在。这篇文章我就带你来看一看这个处于 OSI 标准最上层、最常用也是最普通的 HTTP 它究竟有什么“东西”，一起作为一个不只是听说过的“大神”。
HTTP是什么 超文本传输协议（Hypertext Transfer Protocol，HTTP）。</description>
    </item>
    
    <item>
      <title>几经周折的博客变迁史</title>
      <link>https://www.kcode.icu/posts/chore/blog_journey/</link>
      <pubDate>Wed, 06 Jan 2021 21:13:13 +0000</pubDate>
      
      <guid>https://www.kcode.icu/posts/chore/blog_journey/</guid>
      <description>仔细想起来我的博客旅程也有好多年了，兜兜转转地走了不少弯路，也确实在这个过程中学到了很多东西，大致有这些时间节点：
 尝试购买了国内域名和学生机服务器，看到自己写的内容能在公网上让全世界的人看到就高兴了好久，内容很随意，自己管理。 使用 hexo 框架系统化内容，并部署到 GitHub Page 上交给 GitHub 管理。 发现了国内访问速度更快的 Gitee Page。 再次购买域名，使用 CDN 加速国外空间，未果（下文说）&amp;hellip;&amp;hellip;  前前后后也折腾了好几年，技术上的提升我倒觉得不太大，因为折腾地挺多但是都是应用层面上的，对我来说更多的是动手能力的提高，有好多东西不经过自己亲手尝试是根本理解不了的，我前面很多东西就是别人远程或者一步一步告诉我让我去点这个点那个就可以了，但是回过头来问你，你根本不知道发生了什么，甚至隔天就忘，这是典型的不理解、死记硬背式学习方法。
当时配置那个 A 记录，CNAME 记录啥的根本不知道是什么东西，也不知道 DNS 是什么，就是配，成功了就行，不成功就猜，一个个试呗。现在想想，真的是走了不少弯路，如果能系统地学一下多好。不过这些问题也都在我后来的实践以及学习过程中逐一解决了，现在遇到问题也不用像没头苍蝇一样乱撞了，这种感觉很不错 :)
这件事也让我大致理解了一句老话，大致是这么说的：真正厉害的技术人员不是说他写程序一定要多么多么厉害，而是他有非常强悍的问题定位能力（trouble shooting），能解决别人解决不了的问题，而这一切都源自于无数经验的积累以及深度的思考。
下面说我的最后一次迁移：)
 之所以有两个部分是因为买了域名后才发现必须要国内域名并且备案，才能加速国内。我买的是国外域名所以没办法，最后就用 GitHub Page + 自定义域名了。
 GitHub Page+自定义域名 这种方案比较简单（因为GitHub 都帮我们做了），你首先需要创建一个名为 &amp;lt;YourGitHubName&amp;gt;.github.io 的仓库，比如 sh1luo.github.io，然后购买一个域名（国内国外都行，国内要备案），给他添加一条 CNAME 记录 ，就像这样
我是国外的域名，所以转为了国内的 DNSPod 进行解析，希望快一点，做法也非常简单。就是把原域名服务器商的 NameServers 改成 新解析服务器提供的就好了，如上图的 hickory.dnspod.net 那两条。
当然，如果你本来就是国内域名，就不用这么麻烦了，直接添加一条 CNAME 记录，然后在 GitHub Pages 那里设置上自定义域名就完事了，它会自动帮你部署 HTTPS 和一切的 :)
CDN加速 如果你是国内的域名但是是国外的空间，就可以使用 CDN 加速了，加速区域选国内。这里需要注意源站地址由于是 GitHub Pages ，而 GitHub Pages 有 4 个 IP。都写上一行一个，回源 HOST 写你自己地址就可以了。这个回源 HOST 实际上就是 HTTP 头里的 host 字段，如果同一台机器上有多个服务的话，用来标识是哪一个服务，比较常见就是一个 IP 地址上配置了多个域名，就是通过这种给 host 首部字段的方式区分的不同 Web 站点。</description>
    </item>
    
    <item>
      <title>记人生中前几次面试及思考</title>
      <link>https://www.kcode.icu/posts/interview/2020-12-interview/</link>
      <pubDate>Sun, 03 Jan 2021 21:18:13 +0000</pubDate>
      
      <guid>https://www.kcode.icu/posts/interview/2020-12-interview/</guid>
      <description>写作背景 由于早早有了就业的想法，于是我在大三上学期快要结束的时候便早早地”物色“各大公司的实习了，也是希望能在就业前增加几段实习经历，丰富一下经验。这也是人生中我的第一次面试，感触颇多。特别记录下来自己的总结以及对于假期自己的学习规划。
面试总结 这次我面试的总共有三家公司，跟谁学、字节跳动和腾讯，对我印象最深也是帮助最大的就是”字节跳动“。关于面试的准备大致有三块，简历、技术口述和手撕代码，下面分开说。
简历 我个人使用的简历大致是这样的风格，简约并且色调一致。简历这块我倒没什么卡壳，简历没过的 我猜 都是因为学历等等硬性条件不合适，这也是没有办法的事情。这里需要确保这么几点：
 不要造假，实事求是 。虽然有的公司面试官根本不看你简历问（我的几次实习面试不看，校招社招应该是要看的），但是如果你写熟悉甚至精通，你躲过了 HR，但是人家面试官上来问了一个很简单的问题你答不上来，人家可能没兴趣继续问了。。在面试官心里你的这项技术等于没写，并且有了吹牛的成分，众所周知，搞技术的都不喜欢这种人。 拿出有说服力的证据。 这一条不单指技术也包括其他方面，举个例子，如果你写了你优化了这个项目，那么等于没写，谁知道你优化了多少？比如原来服务器 CPU 总是跑到 90+%，然后你通过 xxx 手段优化，优化到了稳定在 70% 左右，这就比较有说服里，面试官也比较好针对你的这个点去问。再举个例子，你在个人相关那栏里写英语能力强，学习能力不错，热爱新技术，咱就不说过没过四六级了，人家让你现场看个技术文，获取跟你聊两句，你蒙蔽了，尴尬不。问你平时咋学习的，你磕磕巴巴说不出个所以然，或者一点逻辑没有，东一头看书，西一头看视频，再来一手看野生技术文章，你说尴尬不。 注意行业基础。 我拿技术来说，搞技术的，你说你写了个热爱技术，结果写个 GitHub ，都能拼错，写成 Github 等等，写个 CSDN 写成 Csdn ，虽说这不是什么大事，但是这些书面东西，我们搞技术的不能犯错的，这给人的印象就是你很不专业，或者说你接触的很少以至于记不清楚。假如说你说热爱开源，整天 GitHub 排行榜逛个遍，你告诉我你不知道 GitHub 怎么拼，不合适吧？我曾经见过一个人说他懂这懂那，结果拿来简历一看，关于技术的名字错了好几个，还说自己热爱这些，实际水平也就可想而知了。  我个人关于简历这块总结就是这样，虽然说简历很重要，但是我认为还是不难写的，把握好这些点即可 :)
技术口述 这部分是面试重头戏，除去手撕代码部分其余就是这个了（还可能有项目环节），对于这部分我感触最多。大体是，以前我认为掌握一种技术就是会用来解决某个问题就完事了，不想探究怎么实现的。举个例子，现在需要有个从反序列化出来的 json 字节数组里拿某个字段的值，以前的我就是去找个库用用完事了，现在经过大厂面试洗礼的我是这样的：我能不能自己写一个，看他代码不多呀，这样写效率高不高？紧接着看了源代码之后就会惊叹：哇还能这么设计，哇这个还能这么用，厉害了。。。真实。。。
而实际面试里也是这样的，我们不能只考虑表现层面的东西，而要去探究其底层大致的实现原理，只有这样，当你遇到问题的时候才能有初步想法从而去解决，而不是只会去问别人。别人不告诉你或者怎样你就解决不了了，不是有那么一句话说得好嘛，好的工程师（注意不是程序员）并不是他写的代码多厉害，而是他遇到问题总是能快速定位问题，并以最优雅的方式去解决，这一点值得我们深思。学会用工程师的视角去解决问题也是我们每一个人的最终目标。
在面试过程中我也遇到了很多之前没考虑过的问题，举个例子，我写的 RPC 框架里，大的问题比如说 注册中心挂了怎么办？能不能自动通过 .proto 文件生成规范的并且与我们框架配合使用的 RPC 代码？小的问题比如说 底层用的 NIO，NIO是什么，为什么快等等。因为我这个框架说白了只在运输层以上工作，我只在运输层以上思考，也就是说只是应用层面理解了而已，只是更深一点点的应用层面罢了，所以当面试官问我一系列深层次的问题后，我的问题就暴露出来了：对这个框架没有进一步的思考和认识。所以这也是我接下来要去思考和改进的一个点。项目大致都是如此，比如你写了一个 Web 类型的项目，用到了某某框架、技术或者标准库，你就要思考为什么它很好？好在哪了？我个人对它有优化吗？我实际上做了什么事情呢？我能从哪些方面提高它的并发量或者说是功能技术创新呢？
总结来说就是项目要有一定规模，有一定自己的思考在里面，别人问你关于你项目的特色，你的工作点，你都有的说。
假期规划 </description>
    </item>
    
    <item>
      <title>手写一个RPCg（上）</title>
      <link>https://www.kcode.icu/posts/rpc/rpcg/</link>
      <pubDate>Sat, 28 Nov 2020 15:45:13 +0000</pubDate>
      
      <guid>https://www.kcode.icu/posts/rpc/rpcg/</guid>
      <description>须知 可能看到这里的一部分人还不知道什么是 RPC，也不知道为什么要用 RPC，内心：HTTP不香吗？那么你需要首先看一下这篇文章：
 你觉得HTTP哪都好用是因为你不知道RPC
 已经实现的 这篇文章我会带你手写一个简易版本的 RPC 框架，这个框架会支持如下这些功能：
 多种网络传输方式 服务端自动注册可导出服务 可以心跳保活的注册中心 服务注册与服务发现 多种序列化方式 超时控制 一些负载均衡策略，一致性哈希、平滑带权轮询等  未来需要做的   自定义的代码生成插件
  一种压缩方式
  基于服务器时延的负载均衡策略？
  心里有数 ”切忌重复造轮子“这句话你应该听过，不过这个”框架“的目的是带领我们大致了解 RPC 框架的工作过程，目标并不是工业级应用，我想你也一定清楚用框架和自己写框架对框架的理解程度有什么区别。也不必把 RPC 想成多么”高端“的技术，RPC 也只是一个调用，微服务的一个组件，从小的地方出发更容易让人接受罢了。好了，话不多说，让我们正式开始。
俯瞰RPCg 这个图向我们展示了最基本的 RPC 调用关系：服务端将自己的服务注册到注册中心，客户端从注册中心获取所有服务端的所有信息，在拿到这些信息之后带着自己的请求去访问某个服务端的服务。你可能会问为什么要多个”第三者“注册中心出来呢，我直接就只有客户端和服务端多方便，那你需要思考以下问题：
 直接通信是不是需要将通信的地址等服务端信息硬编码到客户端的代码中？如果服务端节点数改变了怎么办，难道手动删改代码？ 客户端怎么知道服务端可不可用？难道需要服务端开个服务专门去处理这类信息吗？这属于服务端的业务吗？ &amp;hellip;&amp;hellip;  我想你应该大致能明白为什么需要这个注册中心了，就是屏蔽对方对己方的感知，通过一个第三方中介来提供/提出自己的服务/需求，这就够了，你可以类比 房产中介，婚介所等等机构，当然，注册中心还有很多功能，我们这里为了学习，就只提供这部分功能了，更多的需要留给你去探索 :)
我们再想想，我们现在有了三个主体，之前有不同的需求，怎么提供通信。业界有非常多的解决方法，比如 gRPC 的 HTTP/2.0，它的优势也是显而易见的：多路复用，pipelining 的通信方式，效率大幅提高，不必在等待对方的回复；首部压缩，这里我需要说明一下，RPC 调用大部分是服务端内部的互相调用，比如公司机房里 50 台机器之间相互调用，需要保证传输的效率，也就是说传送的数据要尽可能地小，这才有了 Protocol Buffers 的数据格式，所以经过压缩的首部数据量更小，效率更高。还有 tcp 连接，优势是简单等等。
等待更新&amp;hellip;&amp;hellip;.</description>
    </item>
    
    <item>
      <title>你觉得HTTP最香是因为你还不知道RPC</title>
      <link>https://www.kcode.icu/posts/rpc/rpcvshttp/</link>
      <pubDate>Tue, 10 Nov 2020 21:30:13 +0000</pubDate>
      
      <guid>https://www.kcode.icu/posts/rpc/rpcvshttp/</guid>
      <description>我在动手写 RPCg 这个”框架“之前看了大量的文章阐述 RPC 与 HTTP，这篇文章是比较不错的一篇，我翻译过来和你分享一下 :)
REST vs. RPC你要使用API去解决什么问题？ 有一则关于这个农民的笑话，他被问到”为什么他要尽量避免耕种出‘童话环’的形状“，他回答道，”因为如果我不那么做，我就会变成傻子“。（第一段的引用故事可暂时不关注）。
许多人关于他们自己构建的 APIs 会说同样的话，事实上，去思考一下你要用你的 APIs 去解决什么问题这非常重要，因为你所创建的 API 的风格和你所使用的技术都依赖于你上面的回答。
根据调用 自从 FORTRAN Ⅱ 在1958 年提出调用（也叫函数）这个概念，函数（调用）就一直是组织计算机代码的主要结构。所有现在主流被用来构建和使用 API 的编程语言例如 Java,Javascript, Python, Golang, C/C++ 和 PHP 都使用调用（也就是函数）来作为他们的主要组织结构。因此这数十年来”函数调用“以远程过程调用（RPC） 的形式称为设计和实现分布式 API 的主要模型也就不足为奇了。
如果你要问大多数软件开发者为什么要定义和构建 API，他们可能会解释说他们有个应用，它需要实现多个分布式组件，并且这些组件之间可以互相调用，来使整个应用程序正常运行。他们也可能说需要实现由多个应用程序使用的服务 API。</description>
    </item>
    
    <item>
      <title>Linux du/df命令总结</title>
      <link>https://www.kcode.icu/posts/chore/linux_df_du/</link>
      <pubDate>Wed, 04 Nov 2020 18:15:13 +0000</pubDate>
      
      <guid>https://www.kcode.icu/posts/chore/linux_df_du/</guid>
      <description>linux 在我们日常学习中用的非常多，连接远程 linux 服务器，使用各种 linux 命令，或者物理机就是 linux 系统或者 MacOS。如果你想要学习进阶知识，linux 已经是必不可少的一个组件了。这篇博客记录一下 linux 下常被混淆的 du/df 命令。
df df 就是 “disk free” 的缩写，一般是用来快速浏览你的文件系统，会显示所有磁盘的大小，使用空间，剩余空间，使用百分比还有磁盘挂载到哪个分区上了。使用的时候一般要带上 -h 参数来增加可读性。这些数据都是从挂载点或者文件系统级别计算出来的，比较 “宏观”。
而且，-h 标记会使你的数据四舍五入更方便显示，比如它显示 3G 的大小，实际上可能是 2.9G 或者 3.1G，并不确定。
du du 就是 “disk usage” 的缩写，如果你需要计算某个特定目录大小的时候非常好用。一般搭配 -sh 参数让结果更易读，比如这样：
df VS. du 看了这两个命令大致用法后，它们在使用场景是什么呢，众所周知不结合使用场景的技术都是耍流氓。大致可以这样总结：df 命令提供一个关于你整个文件系统的概览，比如你多少空间正在使用等等，du 命令更倾向于计算某个目录的精确快照。
如果非要说哪个的结果更有用一点，我觉得是 du。举个例子，我在 /var 目录下安装一个第三方包时遇到了一个目录空间不足的错误，那么我就可以先跑一下 df 命令去看看这个目录的空间来确认一下这是不是真的。我如果看到 /var 有足够空间，那我会接着跑一下 du /var 去看看是它的哪个子目录因为空间不够报的错。这样我就可以一直通过 df  去缩小出错目录的范围，直到找到问题。
理解这些命令的区别能让我们串联使用这些工具，从而更快的定位并解决我们所面临的绝大多数的问题。</description>
    </item>
    
    <item>
      <title>一文搞懂ASCII、Unicode和UTF</title>
      <link>https://www.kcode.icu/posts/ascii-unicode-utf/</link>
      <pubDate>Fri, 18 Sep 2020 09:27:13 +0000</pubDate>
      
      <guid>https://www.kcode.icu/posts/ascii-unicode-utf/</guid>
      <description>起因 最初在学习 Go 语言的各种类型时发现内置字符类型有两种类型，一种是 byte（1 字节表示一个 ASCII 字符），还有一个就是 rune 类型，可能从其他语言转过来的开发者都会对 rune 觉得非常陌生，我自己也是仅仅停留在会用的阶段上，久而久之就会特别乱，所以写一篇博客介绍一下各种字符以及编码方便彼此学习，彻底解决这类问题。
什么是ASCII，为什么又要引入Unicode 都应该了解过 ASCII、Unicode、Unicode 码点、UTF-8等一系列名词。先说 ASCII（American Standard Code for Information Interchange: 美国信息交换标准代码），它是一种字符集，说白了就是一个字符和数字的一一对应关系，你想找这个字符怎么办，计算机又不认识字符？给出他的对应的数字就行了。最初只有美国等一些使用英文的国家使用，所以 128 个字符完全够用，它包含了标点符号、数字和字母等。但是随着世界上使用计算机的国家越来越多，这 128 个字符是完全不够用的。所以 Unicode 字符集 就出现了。Unicode 包含了世界上绝大多数的字符，给他们提供了一一对应关系，比如“知”字对应 30693，即 U+77e5（16 进制形式）。所以说白了 ASCII 和 Unicode 就是一种字符集，一种字符对应关系，Unicode 中每个字符被称为一个 Code Point（码点），而 Go 语言中的 rune 类型正是代表了这样一个单位，即一个 rune 代表了一个 unicode 字符。
那么大家肯定都听说过 UTF-8，UTF-16 吧，那问题来了， UTF 又是什么呢，UTF-8 和 UTF-16 到底又有什么关系呢？
UTF（Unicode Transformation Format） 从字面上你就应该能看出来，这就是一个 Unicode 转换格式。什么是转换格式，为什么需要转换格式？上文说了 Unicode 就是提供了字符间的一一对应关系，比如“知”对应了 30693，那计算机怎么表示这个数（计算机只认识二进制）？它要做到：
在很长的文本中准确获取到每个字符，不能找错 **Unicode 表示一个字符可以使用 1 - 4 个字节。**它的转换规则如下：</description>
    </item>
    
    <item>
      <title>OBS显示器捕获黑屏解决方案</title>
      <link>https://www.kcode.icu/posts/chore/obs/</link>
      <pubDate>Sun, 26 Apr 2020 11:34:13 +0000</pubDate>
      
      <guid>https://www.kcode.icu/posts/chore/obs/</guid>
      <description>问题起因 由于我最近重新安装了系统，在重新下载 OBS 后发现捕获不到桌面。我之前解决方法就是直接在显卡控制面板里将 OBS 设置为集显就行了。但是这次设置了也不行，有可能是我下载的显卡驱动版本不对。。于是就找到了这个终极解决方案，基本电脑上有这个功能的都能解决。
问题环境 操作系统：Win10 64位 专业版 - 1909
CPU 集成显卡型号：Inter(R) UHD Graphics 630
独立显卡型号：NVIDIA GeForce GTX 1050
OBS 版本：25.0.4(64 bit)
 注：配置和我不一样也有可能解决，不用纠结
 问题描述 在来源中添加显示器捕获后 ，是黑屏，无法捕获到显示器。
问题分析 目前网上能搜集到的解决方案大部分是以下几种：
 右键 OBS 属性 - 兼容性 - 兼容模式 - 以兼容模式运行这个程序（win7）设置 - 以管理员方式运行 桌面上右键打开 NVIDIA 控制面板，管理 3D 设置 - 程序设置，找到 OBS，设置为集成图形。  但是我都试了都解决不了，我就去搜了一下问题的原因，最终发现 OBS 只能捕捉到和自己跟自己使用相同显卡的应用，然后我右键打开任务管理器，发现笔记本桌面使用的是我的集显。所以就需要把 OBS 设置为应用集显。
解决方法 左下角开始按钮 - 设置 - 系统 - 显示 - 图形设置 - 经典应用里浏览添加 OBS ，点击选项，设置为节能，节能就是使用集显。然后你再打开 OBS&amp;hellip;&amp;hellip;</description>
    </item>
    
    <item>
      <title>《一起学 Go》</title>
      <link>https://www.kcode.icu/go/</link>
      <pubDate>Sat, 21 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.kcode.icu/go/</guid>
      <description>我不怎么喜欢左写写，右写写，因此总是在不知不觉中写了不少的内容，希望对你有所帮助。
 一：HTTP 应用  「连载一」Go 介绍与环境安装 「连载二」Gin搭建Blog API&amp;rsquo;s （一） 「连载三」Gin搭建Blog API&amp;rsquo;s （二） 「连载四」Gin搭建Blog API&amp;rsquo;s （三） 「连载五」使用 JWT 进行身份校验 「连载六」编写一个简单的文件日志 「连载七」优雅的重启服务  「连载八」为它加上Swagger 「连载九」将Golang应用部署到Docker 「连载十」定制 GORM Callbacks 「连载十一」Cron定时任务 「连载十二」优化配置结构及实现图片上传 「连载十三」优化你的应用结构和实现Redis缓存 「连载十四」实现导出、导入 Excel 「连载十五」生成二维码、合并海报 「连载十六」在图片上绘制文字 「连载十七」用Nginx部署Go应用 「番外」Golang 交叉编译 「番外」请入门 Makefile     二：gRPC 应用  「连载一」gRPC及相关介绍 「连载二」gRPC Client and Server 「连载三」gRPC Streaming, Client and Server 「连载四」TLS 证书认证 「连载五」基于 CA 的 TLS 证书认证 「连载六」Unary and Stream interceptor 「连载七」让你的服务同时提供 HTTP 接口 「连载八」对 RPC 方法做自定义认证 「连载九」gRPC Deadlines 「连载十」分布式链路追踪 gRPC + Opentracing + Zipkin   三：grpc+grpc-gateway 应用  「连载一」gRPC介绍与环境安装 「连载二」Hello World 「连载三」Swagger了解一下 「连载四」gRPC+gRPC Gateway 能不能不用证书？    我的公众号 暂不推广.</description>
    </item>
    
    <item>
      <title>《学习总结》</title>
      <link>https://www.kcode.icu/summary/</link>
      <pubDate>Mon, 16 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.kcode.icu/summary/</guid>
      <description>这里记录了我在学习过程中的总结感悟，在不断添加中。那么为什么要放出来呢，当然是为了催更自己。
一文搞懂 ASCII、Unicode、rune 和 UTF 记人生中的前几次面试 RPC VS. HTTP 手写一个简单的RPC Framework  我的公众号 暂不推广.</description>
    </item>
    
  </channel>
</rss>
