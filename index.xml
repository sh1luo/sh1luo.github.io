<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>wasabi</title><link>https://kcode.icu/</link><description>Recent content on wasabi</description><generator>Hugo -- gohugo.io</generator><language>zh-hans</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Wed, 01 Dec 2021 16:04:20 +0000</lastBuildDate><atom:link href="https://kcode.icu/index.xml" rel="self" type="application/rss+xml"/><item><title>Go 语言代码安全指南</title><link>https://kcode.icu/posts/go/2021-12-01-go%E5%AE%89%E5%85%A8%E8%A7%84%E8%8C%83/</link><pubDate>Wed, 01 Dec 2021 16:04:20 +0000</pubDate><guid>https://kcode.icu/posts/go/2021-12-01-go%E5%AE%89%E5%85%A8%E8%A7%84%E8%8C%83/</guid><description>这是一些关于 Go 安全编码方案，旨在从源头规避漏洞。
通用类 1. 代码实现类 1.1 内存管理 1.1.1【必须】切片长度校验 在对slice进行操作时，必须判断长度是否合法，防止程序panic // bad: 未判断data的长度，可导致 index out of range func decode(data []byte) bool { if data[0] == &amp;#39;F&amp;#39; &amp;amp;&amp;amp; data[1] == &amp;#39;U&amp;#39; &amp;amp;&amp;amp; data[2] == &amp;#39;Z&amp;#39; &amp;amp;&amp;amp; data[3] == &amp;#39;Z&amp;#39; &amp;amp;&amp;amp; data[4] == &amp;#39;E&amp;#39; &amp;amp;&amp;amp; data[5] == &amp;#39;R&amp;#39; { fmt.Println(&amp;#34;Bad&amp;#34;) return true } return false } // bad: slice bounds out of range func foo() { var slice = []int{0, 1, 2, 3, 4, 5, 6} fmt.</description></item><item><title>聊聊 22 届秋招的体验</title><link>https://kcode.icu/posts/interview/2021-12-interview/</link><pubDate>Sun, 21 Nov 2021 21:22:20 +0000</pubDate><guid>https://kcode.icu/posts/interview/2021-12-interview/</guid><description>今年的秋招早已结束了，因为我躺平了一个多月，所以这篇博客就拖到了现在。
我的秋招结束的比较早，一共拿到了 6 家公司的 Offer：腾讯/字节/美团/百度/ThoughtWorks/好未来，其中有白菜也有 SSP。比较有趣的是，好未来这家公司在其他家公司都在薪资/意向沟通的时候，给我打来电话说的却是 Offer 被取消，原因是今年集团问题，不再招收校招生，以实习转正优先。打来电话是说明 如果有其他 Offer 可以签了，不用等好未来了，也算很良心了，没有钓鱼。。
惊讶的是字节在最后给我开出了 SSP 的评级，给出的薪资应该是今年开发岗天花板。
Offer 的情况都比较普通，我想着重聊聊我对 22 届互联网秋招的看法。
敲门砖 学历 和 简历 依然是很重要的首要因素。
学历 事实是，现在互联网中大厂应该普遍不接受专科及以下的学历了，对二/三本也有一些意见，例如有一位三本同学在拿到小红书的 SSP 的 Offer 后，被告知 Offer 审批不通过，给了个最低的价格，也俗称白菜价。评论区一致认为就是学历的锅，我也不置可否。
快速发展的互联网行业，越来越多的研究生大军不断涌入，也属实没什么办法。
简历 逛多了牛客/脉脉等求职平台，对一些同学的简历实在是无力吐槽，说好听点，叫对自己的定位不够清楚，说难听点，叫没有点 B 树。曾经献过血，有驾照，支教，当过超市服务员都往上写，实在是怕对面觉得你经历不够丰富。
信息差是存在的，我经常给身边的朋友、同学推荐 超级简历 这个平台，没什么优点，就是简洁。因为我觉得在写简历这个过程中，最大的阻力应该是 排版，而不是内容。我们需要有一个专业的平台或者什么告诉我们该怎么写，而写什么别人没法教，也教不了。
找一份标准的排版，把你的教育经历、实习经历、项目经历、专业技能和个人相关（可省略）逐条写上去，做到清晰，干净即可，目标是让别人一眼看出你的求职意愿，你的特长优势。我们只需要专注于内容本身，而不用去过度纠结该把这段字设置成 4 号还是 5 号。
秋招流程 秋招的战线比较长，且有不断增长的趋势，这意味着我们有更多的时间去准备。
实习 有一段大厂的实习经历会让你的秋招事半功倍。因为你相当于经过了一次筛选，大厂帮他们提前面试了一次，面试的一部分话题可以从传统八股文转变到实习与项目经历上来，这对我们是非常有利的，因为这是难得的主动权由我们掌握，另一个是自我介绍。
你想想让面试官追着你细扣 epoll 源码简单，还是问你在实习中做了什么简单？
所以我的建议是，能去大厂实习尽量去大厂实习一次，2 个月以上，实在不行去中等规模的也行，但是不要去太小的，因为你得不到太多的锻炼，更多的是打杂。
这其中存在的问题是大多数同学大三无法出去实习，毕竟不是所有人的学校都是北上广深等，这里我推荐我的两种方法，线上实习 和 开源经历。
线上实习 现在有不少公司/公司的部门支持线上支持，往往这些部门没有机密性，不必强行到岗，只要完成任务即可，实话实说，这类机会比较少。而能否线上实习是和具体的部门有关，你需要去和部门 mentor/leader 沟通。我是在大三拿到腾讯实习 Offer 后，遭遇公司所在地疫情，遂线上入职，后续就连续线上实习直到离职了。我个人认为，对于技术岗而言，线上实习不是最优解，反而是下策。毕竟线下实习除了获得经历外，最重要的是体验公司/工作，而且线上不方便交流，线下的话你直接跑到导师工位面基，线上就得问 在吗。。而且往往效率低。
开源经历 我强烈推荐大家参与一些开源项目，用代码证明自己的经历与实力，简单粗暴。现在有许多开源活动，主要参与人群就是大学生，例如 GSOC（Google Summer of Code），还有国内新起的 CSOC（China &amp;hellip;），你只需要定期贡献，在报名时写一份 Proposal，说明自己曾经的贡献，实力，参加的决心即可，这个 Proposal 类似简历。不但有名师指导，开源经历，还有钱拿。据我所知，GSOC 现在结项后可以拿到 13kRMB左右，前两年可以拿到 18k。国内的 CSOC 是12K，至少今年是，分两次，中期报告和结项报告，各一半。税后到手10K+。感兴趣的同学可以去了解下。</description></item><item><title>最近两个月及远程实习半个月小记</title><link>https://kcode.icu/posts/chore/2021-06-19-recent-life/</link><pubDate>Sat, 19 Jun 2021 15:00:13 +0000</pubDate><guid>https://kcode.icu/posts/chore/2021-06-19-recent-life/</guid><description>自 3 月末完成许多轮线上面试，4 月初拿到 offer，到现在因疫情远程实习，已经过去2个多月了，时间真的一晃就过去了，虽说还没拿到正式的秋招 offer，但也距离面试不远了，有必要记录一下这段时间的生活，顺便总结反思。
前段时间 在拿到实习 offer 后，和之前学习状态相比有点佛系，一方面是因为阶段性的目标没了，短时间内没有下一个目标；另一方面是把重心从看/背知识点转移到了深入思考，理解上来了。因为在准备时有一些知识难免是死记硬背的，或者理解不透彻，需要复现并弄清楚。
针对第一方面，其实我之前已经有了另一个目标的雏形，也是针对我的简历项目比较薄弱。就是寻找一个 “亮眼” 的项目来丰富简历上的项目部分，思前想后主要有四大块方向，竞赛类项目，开源贡献，造轮子，还有 秒杀/CRUD 类。
竞赛类项目是一些参加比赛的项目，比如一年一次的微信小程序开发大赛，用小程序解决一个实际问题或者开发一个趣味游戏。这个我现在来不及了，不适合。开源贡献这块我一直在关注 GSoC，奈何要求确实略高，另外需要提前至少 1-2 个月进行准备，为目标社区的项目贡献，联系导师等，之前加入了国内 GSoC 的 Gitter 社区讨论群，在 5 月恰巧看到群里有人说国内也搞了个开源夏令营，模仿谷歌的，是第二年举办，我就参加了，贡献了半个多月，累计 PR 10 个左右 ，也是常常肝到凌晨，目前结果怎么样还未知，不过学习到的东西真的很多，例如更多的 Git 用法，开源规范，还有具体项目的知识。这个如果成功了我觉得也应该比单纯的 CRUD 好（希望😄
参加这类夏令营，大多都不看重 proposal，也就是申请书/简历一类的，强调在实际贡献中体现代码及工程能力，所以要提前一段时间准备，了解项目。
造轮子就是创造一些小工具，这个需要有一定的代码能力，做得好了也很加分，但是我觉得写 用 tcp 实现 http，json 解析器之类的可以自己写，就没必要写简历上了，一来没啥问的，二来没啥实际用途。我个人是用 Go 写了个 rpc 框架的小轮子，不过难点也很多，很容易被怼。
秒杀/CRUD 类就是常见的 xx管理系统，多做一些 CRUD 的操作，不推荐，除非吃透不怕问，不过我觉得面试官比你更懂秒杀（​逃😆
除了简历，我也在思考一些常见问题如何回答的更深入，例如常见的 https，select/poll/epoll，memory，file system等等，这些问题想要答的透彻，基本都要看源码，看底层设计实现，比较耗时，但是能将清楚非常加分，也是拿到 sp/ssp 的关键一环。
近期实习 由于疫情远程参与了实习，前期也比较闲，主要是熟悉产品，在内网逛逛😄，不得不说，来大厂实习的一大好处就是可以体验一下大厂内部的环境。好多都是自研，确实方便。
很多资料，格式/规范，除非一部分实习生没权限之外（比如腾讯的乐问），技术资料都公开。因为可能是出售的产品，所以有的代码是不能访问，需要开权限才能访问。当然内部开源的工具的源码还是随便看的。
等疫情过去，7 月多我就过去线下实习体验一下，还是挺期待现场实习的。
2021.6.30 16:02更新，已入选~
顺便吐槽一下，入选有时候真的看运气，有的项目4、5个人，卷的飞起，10 几个PR不一定能进，有的没人，可能写个申请书随便交点PR就进了 😂</description></item><item><title>面试官：如何只使用一个指针域实现双向链表</title><link>https://kcode.icu/posts/interview/2021-06-05-%E5%A6%82%E4%BD%95%E5%8F%AA%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E5%9F%9F%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link><pubDate>Sat, 05 Jun 2021 14:36:20 +0000</pubDate><guid>https://kcode.icu/posts/interview/2021-06-05-%E5%A6%82%E4%BD%95%E5%8F%AA%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E5%9F%9F%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid><description>这是来自某学习群的群友提供的，一道 便利蜂 的实习面试题，恰好被看到了（不是
问题是：只使用一个指针如何实现双向链表，乍一想好像不可能，我当时的大致思路是这样的：原来直接使用 -&amp;gt;right 或者 -&amp;gt;left 就能访问到左右节点，现在只有一个指针，就要修改指针的含义，不能直接存储下一个节点的地址了，大概率是要根据某些条件算出下一个地址。
事实呢？为了了解具体做法，我去翻了维基百科关于这部分的 详细解释 ，并本地实现了一遍完整代码，记录在这里。
实现原理 这种链表被称为 异或链表（XOR Linked List），能够达到只使用一个指针域实现双向链表的效果，从而降低空间复杂度。当然它也不是没有缺点，如果只有一个节点，无法向两个方向遍历，必须有连续的两个节点地址。
回到之前说的问题，问题的关键就是如何只使用一个指针实现双向访问的效果，再来看链表名，异或链表。
任何一个节点的指针域的值为 它的前一个节点和下一个节点的地址异或。
假如现在有 3 个节点分别为 A,B 和 C，地址分别为 0x1,0x2,0x3，那么，
A.next = null^0x2 B.next = 0x1^0x3 C.next = 0x2^null XOR linked List +--- -----+ next=0x1 +---------+ next=0x1^0x3 +---------+ | *A=0x1 +--------- | *B=0x2 +------------ | *C=0x3 | +---------+ +---------+ +------+--+ | | | next=0x2 | | | next=0x1 | | +------+--+ +---------+ | null | | null | +---------+ +---------+ 这个图之所以没有画出箭头是因为这里并不是直接指向下一个节点的地址，而是需要和前一个节点异或计算才能得到下一个节点的地址。</description></item><item><title>正/反向代理与科学上网</title><link>https://kcode.icu/posts/2021-05-31-%E6%AD%A3%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</link><pubDate>Mon, 31 May 2021 15:33:50 +0000</pubDate><guid>https://kcode.icu/posts/2021-05-31-%E6%AD%A3%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</guid><description>代理
你可能听过许多 反向代理（Reverse Proxy） 软件例如 Nginx、Apache 等，它们性能优越，被广泛应用于实际场景中，那么你是否知道 “反向” 是什么意思，为什么叫反向呢，明白这个问题有助于我们更深入的理解它们。还有许多框架中常用的的 控制反转（IOC）/依赖注入（DI） 等概念，你是否理解 反转 或 注入 的真正含义。
既然有反向代理，就有正向代理，常用的科学上网就是使用了这个技术，你所见过的例如 ss/ssr/socks5 等等仅仅是协议名，配合上一些混淆方式，它们的技术原理还是 正向代理（ Forward Proxy）。
之前我在「刷」面试题的时候，就遇到过相关问题，“墙以及科学上网的原理”。相信读完这本文你会得到答案。
在了解正反向代理之前先牢记一句话，反向代理 代理并 隐藏服务端，正向代理与之相反，隐藏客户端。
反向代理 OK，记住了这句话，想想 Nginx/Apache 的功能，你将服务部署在服务器上，只公开了 80/443 端口，而内部服务有很多个，通过不同域名访问，然后使用 Nginx/Apache 来接受外界请求，利用提供的指令，例如 sever_name，listen，index，location 来控制其进行转发到不同的内部端口上，由于其使用了非常高效的 epoll IO多路复用模型，效率非常高。
那么你的脑海中应该有大致这么一张图，类似这样：
Reverse Proxy +------------------------------------------------------+ | | | +---------+ | | +-------&amp;gt; | Server1 | | | | +---------+ | +--------------+ | +-----------------+ | | | | | | | | +---------+ | | Client +-----------+--&amp;gt;| google.</description></item><item><title>极客时间专栏《RPC实战与核心原理》读后笔记</title><link>https://kcode.icu/posts/rpc/geektime-rpc/</link><pubDate>Fri, 14 May 2021 21:45:13 +0000</pubDate><guid>https://kcode.icu/posts/rpc/geektime-rpc/</guid><description>对 RPC 相关的学习也有了一段时间，算是有了一个初步的认识，回过头来读 极客时间的专栏 感觉思路清晰了不少，顺利了许多，再回头看 rpcx 的源码也没有那么费劲了。我把我在这个专栏中学到的一些内容记录下来，共同学习。
本文不再解释 RPC 相关基础概念，有需要可在上文链接或者往期文章中学习。
以下的二级标题均对应专栏的课程大纲，同样分单元总结。
开篇词 开篇词介绍了 RPC 的使用场景，重要意义，作为引文。
RPC 即远程过程调用，目的是使调用另一台机器上的程序就像调用本地程序一样简单。总是和 “微服务”，SOA 联系，其实理论上来说，任何牵扯到网络通信的系统都可能需要使用 RPC。比如分布式各个组件间或与应用间的通信，比如 etcd 作为统一的配置服务，客户端就是通过 gRPC 框架与服务端进行通信的。
RPC 是解决分布式系统通信问题的一大利器。 RPC 的通信原理十分简单，可是想完美驾驭却不那么容易，这个过程除了调用过程之外，还主要包括：通信节点查找，连接的建立与状态管理，数据传输的编解码，序列化与反序列化等等，每一项都十分复杂。
而完整的 RPC 框架却对上述过程进行了封装，使得网络通信逻辑的开发变得十分简单，效率也会更高。
最初的我学习 RPC 也是由浅入深，从 “字面意思” 出发，即如何调用远程主机上的某个函数，实现了编解码，序列化等等一整套调用流程，成功执行了远程主机的程序，当然了，这还是点对点的。
后来我发现这些仅仅是基础，冰山下的还包括一系列服务治理功能：连接管理，健康检测，负载均衡，优雅启停机，异常重试，业务分组以及熔断限流等等。十分复杂又充满了挑战性。</description></item><item><title>MIT 6.828 课程学习记录</title><link>https://kcode.icu/posts/os/mitos/</link><pubDate>Sun, 25 Apr 2021 23:35:20 +0000</pubDate><guid>https://kcode.icu/posts/os/mitos/</guid><description>介绍 好多人推荐这个国外的课程，就找了一下课程，下载了一份讲义，打开第一眼就看到大名鼎鼎的 rsc 大佬，偶像啊，Go 的当下掌舵人。就冲这名必须得看完了（狗头😄）。 开个玩笑，我个人对计算机基础最感兴趣的就是组成原理、操作系统和汇编语言，除此之外就是分布式了，等搞定这个之后也去跟一下 MIT 6.824 分布式部分（开新坑🕳️ ）
待更&amp;hellip;.</description></item><item><title>Go 使用的 plan9 汇编语言初探</title><link>https://kcode.icu/posts/go/2021-03-20-go-%E4%BD%BF%E7%94%A8%E7%9A%84-plan9-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%88%9D%E6%8E%A2/</link><pubDate>Sun, 04 Apr 2021 20:30:20 +0000</pubDate><guid>https://kcode.icu/posts/go/2021-03-20-go-%E4%BD%BF%E7%94%A8%E7%9A%84-plan9-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%88%9D%E6%8E%A2/</guid><description>plan9 汇编既不同于 Intel-x86 家族的汇编，也不与 AT&amp;amp;T 标准相同，作者是 unix 操作系统的同一批人，bell 实验室所开发的，其实 plan9 是一个操作系统，我们主要关注构建它的汇编语言。
Go 语言早在 1.5 版本就实现了自举，即 使用 Go 语言去写 Go 语言。Go 的底层实现是使用 plan9 汇编完成的，并不是我们常见的 Intel 家族汇编，它与其他的汇编有几个不同点，在下文中一边比较一边介绍。
伪寄存器 plan9 抽象了 4 种伪寄存器：
FP（Frame Pointer），帧指针，快速访问函数的参数和返回值。 SP（Stack Pointer），栈指针，指向栈顶。 SB（Static base pointer），静态基址，全局变量。 PC（Program Counter），其实就是 IP（Instruction Pointer）的别名，指向下一条指令的地址。jmp等跳转指令还有分支控制等原理就是通过修改这个值。在 8086 机里等价于 CS:IP。 其实就是对 CPU 的重新抽象，这个抽象结构与具体的 CPU 结构无关。
它们之间的具体关系如下图：
与x86汇编的差异 许多人之前广泛了解的汇编可能是 AT&amp;amp;T 格式或者传统 Intel-x86 格式，AT&amp;amp;T 规范与 x86 有许多不同，而 plan9 与 AT&amp;amp;T 有许多相似的地方，比如操作数顺序许多是相同的，但 不完全等价。还是需要我们重新学习，这里列举一些常见区别。
Mnemonic | Go operands | AT&amp;amp;T operands ================================================ BOUNDW | m16&amp;amp;16, r16 | r16, m16&amp;amp;16 BOUNDL | m32&amp;amp;32, r32 | r32, m32&amp;amp;32 CMPB | AL, imm8 | imm8, AL CMPW | AX, imm16 | imm16, AX CMPL | EAX, imm32 | imm32, EAX CMPQ | RAX, imm32 | imm32, RAX CMPW | r/m16, imm16 | imm16, r/m16 CMPW | r/m16, imm8 | imm8, r/m16 CMPW | r/m16, r16 | r16, r/m16 CMPL | r/m32, imm32 | imm32, r/m32 CMPL | r/m32, imm8 | imm8, r/m32 CMPL | r/m32, r32 | r32, r/m32 CMPQ | r/m64, imm32 | imm32, r/m64 CMPQ | r/m64, imm8 | imm8, r/m64 CMPQ | r/m64, r64 | r64, r/m64 CMPB | r/m8, imm8 | imm8, r/m8 CMPB | r/m8, imm8 | imm8, r/m8 CMPB | r/m8, r8 | r8, r/m8 CMPB | r/m8, r8 | r8, r/m8 CMPW | r16, r/m16 | r/m16, r16 CMPL | r32, r/m32 | r/m32, r32 CMPQ | r64, r/m64 | r/m64, r64 CMPB | r8, r/m8 | r/m8, r8 CMPB | r8, r/m8 | r/m8, r8 CMPPD | imm8, xmm1, xmm2/m128 | imm8, xmm2/m128, xmm1 CMPPS | imm8, xmm1, xmm2/m128 | imm8, xmm2/m128, xmm1 CMPSD | imm8, xmm1, xmm2/m64 | imm8, xmm2/m64, xmm1 CMPSS | imm8, xmm1, xmm2/m32 | imm8, xmm2/m32, xmm1 ENTER | 0, imm16 | imm16, 0 ENTER | 1, imm16 | imm16, 1 操作数顺序不同 在 x86 中，一些常见指令是这样的：</description></item><item><title>大三上学期好未来字节腾讯实习面经</title><link>https://kcode.icu/posts/interview/2021-3-nowcoder/</link><pubDate>Tue, 30 Mar 2021 17:20:20 +0000</pubDate><guid>https://kcode.icu/posts/interview/2021-3-nowcoder/</guid><description>说在前面 经常“吸”社区，也要时不时反馈一点，一起延续开源精神。
个人情况：22 届双非一本，从去年 12 月开始面试找寒假的实习，由于学校疫情原因没去成功，于是经过寒假复习“二战”。先后面了跟谁学，腾讯，字节，阿里。
由于我个人情况特殊，从大一开始使用 Go 语言到现在，了解比较多，C++ 用来写题，有的问题可能不具有参考价值，理性看待。
另外有的问题确实记不得了，大家不要太看重问题，因为大部分都是八股的题型，网上一搜一大堆，博客的总结能几万字，但是没有面试官喜欢听这种东西，都是搞技术的不喜欢花里胡哨，我曾经就因为答协程区别和特点被反问 你这个有点像背的，，不过我也没反驳，下次总结避免就好了。你要答出问题的本质，底层的思考，说出跟别人不一样的地方，用有些面试官的话来说就是 这个问题我只想听你说一句话，我看我能不能听到。说白了就是你说了一大堆可能在对面听来都没听到，说不到点子上等于没说。
另外本文我主要突出面试过程，不是面试问题的总结帖（有的问题我真的记不得了 :(。
好了，不说废话了，大家看正文吧，有什么问题欢迎找我聊~
跟谁学两面 oc，第一次面试 一面 自我介绍
项目：
用go写的rpc框架的具体功能细节，注册中心单机还是分布式的，其中一个挂了怎么办？一致性，可靠性怎么保证的。超时控制，加锁和管道支持并发，单机（考虑了多机情况，说了已经在todo里了）。
Go+QML 利用cgo实现的跨平台桌面应用功能，场景，为什么要写这个东西？ 我说为了性能，追问性能如何体现，如何测试的，如何优化。答宏观上从任务管理器，top中看，细节上从pprof进行性能定位调优，从火焰图上看。追问pprof还有什么功能，你一般是怎么定位问题的？回答还是先具体再细节。
这时候我就俩项目，后面怕不够，又想拿go写个web的，正好学校说需要重构某个子选课系统，就跟同学接了，这个下面说。
写个快排？时分复杂度分析？看你了解过go的标准库实现，说说go的快排源码怎么实现的，答三数取中，根据数据量选择多种排序方式组合，追问细节我就不知道i了，，确实没看过这个。。他说没事。
协程与线程区别？为什么快，快在哪了？自定义了4个伪寄存器 fp sp sb pc，轻量，初始2KB动态伸缩，由runtime管理，对os透明等等各种原因，又说了以下gmp调度的优势。追问寄存器是什么，你对寄存器还有什么了解。我说了一点关于go和c 在寄存器方面使用的不同，函数传参，调用堆栈等等，扯了点汇编区别，就又问了几个汇编指令，过了。
虚拟地址，物理地址区别
rpc与http区别，使用场景，自己总结一下再说几条
还有点八股没啥难的 有点忘了。。
也没问啥难点一面就过了
二面部门leader 详细聊虚拟地址与物理地址，为什么分这俩，段页作用，为什么内存占用能比实际要大的多（还是虚拟地址作用），循序渐进的从现象到技术实现来问，不是考试。
go+qml项目问了几个关于cgo的特性，聊了聊优劣势，看得出来这个项目好多面试官也不懂，cgo特性一是用起来结合其他语言的时候确实有坑点，二是拿go写gui有点杀马特，不招人待见？
闲聊网络跟os，最后问了个智力问题，就过了。
总结 感觉难度不大，缺人进来打杂，要求不高。问了一下前辈，说加班严重，校招的话工资高了可以放备选考虑去。。面试体验还不错，自己缺乏一点回答技巧上的经验，聊技术不能一下到点子上，废话略多。
字节二面挂，腾讯二面挂 这俩对我帮助最大。
字节 字节对我最大的帮助是深度思考算法，为什么要这么写，别的方法行不行？
自己感觉有了点面试方面的经验，就投了较大的厂，遭到毒打。
字节一面是算法面，最后写了个单链表归并非递归，勉强通过。
二面上来扣20分钟rpc项目，挖出你这个项目的所有特点为止：
序列化方式有哪几个，区别是什么，自己写过吗 协议用的哪个，为啥不用udp &amp;hellip;鞭打。。。 当时确实缺少对项目的深度思考，也是参考了声哥的项目，不过他是java写的，用go写起来参考了不少框架源码，rpcx，grpc，实现起来略费劲，时间仓促，底层思考略少。
二面挂是因为问了个快排复杂度，详细分析这三个时间复杂度的结果，怎么来的这个值，举例子说明等等，自己算法这方面当时确实弱项，挂了正常。
腾讯 腾讯对我最大的帮助是看源码，有的东西嚼别人的东西是不够的，应该学习一手资料，详情参考曹大的博客《工程师应该怎么学习》。还是太菜了，缺乏深度思考
几个亿找中位数
搜索树旋转过程
对面应该是c++的，问我map，我说我用go，他就说go也行，你说说go map 时间复杂度，为啥是这个值，为什么这么多数，O1能直接访问到，当时map只了解了一点，遂答的浅。</description></item><item><title>Go unsafe.Pointer、uintptr、Pointer 之间的区别与联系</title><link>https://kcode.icu/posts/go/2021-03-14-go-unsafe.pointeruintptr%E4%B8%8E%E6%8C%87%E9%92%88/</link><pubDate>Sun, 14 Mar 2021 13:35:20 +0000</pubDate><guid>https://kcode.icu/posts/go/2021-03-14-go-unsafe.pointeruintptr%E4%B8%8E%E6%8C%87%E9%92%88/</guid><description>前几天见到了一个问题：
uintptr与 unsafe.Pointer 有什么区别？ 你可能曾经看到过类似这样的代码：
type T struct { a uint8 b bool c string } t := T{a: 1, b: true, c: &amp;#34;goooo&amp;#34;} Tc := *(*string)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;amp;a)) + unsafe.Offsetof(T{}.c))) fmt.Println(Tc) 这一行代码看似实现的功能非常复杂，其实它就是等价于：
fmt.Println(t.c) 从某种意义上来说，这好像没什么用（确实没啥作用&amp;hellip;），那你再看一段代码：
//go:nosplit func Bytes2String(bs []byte) string { return *(*string)(unsafe.Pointer(&amp;amp;bs)) } //go:nosplit func String2Bytes(s string) []byte { ss := *[2]uintptr(unsafe.Pointer(&amp;amp;s)) b := [3]uintptr{ss[0], ss[1], ss[1]} return *(*[]byte)(unsafe.Pointer(&amp;amp;b)) } 这两个函数实现了 []Byte 与 string 的互转，并且不需要申请任何内存，因为他们共享底层数据空间。
函数前的类似注释的一行是一些指令，用来指示编译器进行一些用户的行为，Go 中的栈帧是可以根据需要动态增长的，一开始只有 2048Byte，是固定在源码中的。而 go:nosplit 就是表明函数栈空间无需动态增长，这在一定程度上增加了效率，但是如果你申请了过量的空间，就会导致程序因为爆栈而 panic。</description></item></channel></rss>